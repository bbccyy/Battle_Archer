// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/BuffData.proto

#ifndef PROTOBUF_module_2fBuffData_2eproto__INCLUDED
#define PROTOBUF_module_2fBuffData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/BuffDataBase.pb.h"
#include "module/BuffDataBase2.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fBuffData_2eproto();
void protobuf_AssignDesc_module_2fBuffData_2eproto();
void protobuf_ShutdownFile_module_2fBuffData_2eproto();

class SpecialHitModel;
class BuffModAbsorbDamageConfig;
class BuffModNonTargettableConfig;
class BuffModNonHostileTargettableConfig;
class BuffModReflectDamageConfig;
class BuffModReflectSkillConfig;
class BuffModBuffImmunityConfig;
class BuffModSkillImmunityConfig;
class BuffModHitActionImmunityConfig;
class BuffModDispelConfig;
class BuffModStealHpConfig;
class BuffModDamageShareConfig;
class BuffModDamageCopyConfig;
class BuffModHealCopyConfig;
class BuffModHpConfig;
class BuffModRageConfig;
class BuffModRecordDataConfig;
class BuffModHarmOnMoveConfig;
class BuffModDamageImmunityConfig;
class BuffData;

// ===================================================================

/*FOR2LUA
<Record>
	<name>SpecialHitModel</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SpecialHitModel : public ::google::protobuf::Message {
 public:
  SpecialHitModel();
  virtual ~SpecialHitModel();

  SpecialHitModel(const SpecialHitModel& from);

  inline SpecialHitModel& operator=(const SpecialHitModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpecialHitModel& default_instance();

  void Swap(SpecialHitModel* other);

  // implements Message ----------------------------------------------

  SpecialHitModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpecialHitModel& from);
  void MergeFrom(const SpecialHitModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 HitType = 1;
  inline bool has_hittype() const;
  inline void clear_hittype();
  static const int kHitTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>hittype</name>
  		<replaceName>HitType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_hittype</name>
  		<replaceName>HitType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_hittype</name>
  		<replaceName>HitType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 hittype() const;
  inline void set_hittype(::google::protobuf::int32 value);

  // optional int32 BuffType = 2;
  inline bool has_bufftype() const;
  inline void clear_bufftype();
  static const int kBuffTypeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>bufftype</name>
  		<replaceName>BuffType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_bufftype</name>
  		<replaceName>BuffType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_bufftype</name>
  		<replaceName>BuffType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 bufftype() const;
  inline void set_bufftype(::google::protobuf::int32 value);

  // repeated int32 BuffList = 3;
  inline int bufflist_size() const;
  inline void clear_bufflist();
  static const int kBuffListFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>bufflist_size</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 bufflist(int index) const;
  inline void set_bufflist(int index, ::google::protobuf::int32 value);
  inline void add_bufflist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bufflist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bufflist();

  // optional bool AdjustScale = 4;
  inline bool has_adjustscale() const;
  inline void clear_adjustscale();
  static const int kAdjustScaleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>adjustscale</name>
  		<replaceName>AdjustScale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_adjustscale</name>
  		<replaceName>AdjustScale</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_adjustscale</name>
  		<replaceName>AdjustScale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool adjustscale() const;
  inline void set_adjustscale(bool value);

  // repeated int32 BuffLastTime = 5;
  inline int bufflasttime_size() const;
  inline void clear_bufflasttime();
  static const int kBuffLastTimeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>bufflasttime</name>
  		<replaceName>BuffLastTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_bufflasttime</name>
  		<replaceName>BuffLastTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_bufflasttime</name>
  		<replaceName>BuffLastTime</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_bufflasttime</name>
  		<replaceName>BuffLastTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>bufflasttime_size</name>
  		<replaceName>BuffLastTime</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 bufflasttime(int index) const;
  inline void set_bufflasttime(int index, ::google::protobuf::int32 value);
  inline void add_bufflasttime(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bufflasttime() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bufflasttime();

  // repeated int32 BuffEffect = 6;
  inline int buffeffect_size() const;
  inline void clear_buffeffect();
  static const int kBuffEffectFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>buffeffect</name>
  		<replaceName>BuffEffect</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_buffeffect</name>
  		<replaceName>BuffEffect</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_buffeffect</name>
  		<replaceName>BuffEffect</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffeffect</name>
  		<replaceName>BuffEffect</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>buffeffect_size</name>
  		<replaceName>BuffEffect</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 buffeffect(int index) const;
  inline void set_buffeffect(int index, ::google::protobuf::int32 value);
  inline void add_buffeffect(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      buffeffect() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_buffeffect();

  // repeated int32 BuffHitRate = 7;
  inline int buffhitrate_size() const;
  inline void clear_buffhitrate();
  static const int kBuffHitRateFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>buffhitrate</name>
  		<replaceName>BuffHitRate</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_buffhitrate</name>
  		<replaceName>BuffHitRate</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_buffhitrate</name>
  		<replaceName>BuffHitRate</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffhitrate</name>
  		<replaceName>BuffHitRate</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>buffhitrate_size</name>
  		<replaceName>BuffHitRate</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 buffhitrate(int index) const;
  inline void set_buffhitrate(int index, ::google::protobuf::int32 value);
  inline void add_buffhitrate(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      buffhitrate() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_buffhitrate();

  // optional bool UpdateEffect = 8;
  inline bool has_updateeffect() const;
  inline void clear_updateeffect();
  static const int kUpdateEffectFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>SpecialHitModel</name>
  	<Function>
  		<name>updateeffect</name>
  		<replaceName>UpdateEffect</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_updateeffect</name>
  		<replaceName>UpdateEffect</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_updateeffect</name>
  		<replaceName>UpdateEffect</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool updateeffect() const;
  inline void set_updateeffect(bool value);

  // @@protoc_insertion_point(class_scope:pb.SpecialHitModel)
 private:
  inline void set_has_hittype();
  inline void clear_has_hittype();
  inline void set_has_bufftype();
  inline void clear_has_bufftype();
  inline void set_has_adjustscale();
  inline void clear_has_adjustscale();
  inline void set_has_updateeffect();
  inline void clear_has_updateeffect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 hittype_;
  ::google::protobuf::int32 bufftype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bufflist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bufflasttime_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > buffeffect_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > buffhitrate_;
  bool adjustscale_;
  bool updateeffect_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static SpecialHitModel* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModAbsorbDamageConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModAbsorbDamageConfig : public ::google::protobuf::Message {
 public:
  BuffModAbsorbDamageConfig();
  virtual ~BuffModAbsorbDamageConfig();

  BuffModAbsorbDamageConfig(const BuffModAbsorbDamageConfig& from);

  inline BuffModAbsorbDamageConfig& operator=(const BuffModAbsorbDamageConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModAbsorbDamageConfig& default_instance();

  void Swap(BuffModAbsorbDamageConfig* other);

  // implements Message ----------------------------------------------

  BuffModAbsorbDamageConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModAbsorbDamageConfig& from);
  void MergeFrom(const BuffModAbsorbDamageConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 ValueParma = 3;
  inline bool has_valueparma() const;
  inline void clear_valueparma();
  static const int kValueParmaFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>valueparma</name>
  		<replaceName>ValueParma</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_valueparma</name>
  		<replaceName>ValueParma</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_valueparma</name>
  		<replaceName>ValueParma</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 valueparma() const;
  inline void set_valueparma(::google::protobuf::int32 value);

  // optional int32 ValueGrowth = 4;
  inline bool has_valuegrowth() const;
  inline void clear_valuegrowth();
  static const int kValueGrowthFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 valuegrowth() const;
  inline void set_valuegrowth(::google::protobuf::int32 value);

  // optional int32 IsCureSelf = 5;
  inline bool has_iscureself() const;
  inline void clear_iscureself();
  static const int kIsCureSelfFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>iscureself</name>
  		<replaceName>IsCureSelf</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_iscureself</name>
  		<replaceName>IsCureSelf</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_iscureself</name>
  		<replaceName>IsCureSelf</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 iscureself() const;
  inline void set_iscureself(::google::protobuf::int32 value);

  // optional int32 PercentParam = 6;
  inline bool has_percentparam() const;
  inline void clear_percentparam();
  static const int kPercentParamFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentparam() const;
  inline void set_percentparam(::google::protobuf::int32 value);

  // optional int32 PercentGrowth = 7;
  inline bool has_percentgrowth() const;
  inline void clear_percentgrowth();
  static const int kPercentGrowthFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentgrowth() const;
  inline void set_percentgrowth(::google::protobuf::int32 value);

  // optional int32 AbsorbCalculateType = 8;
  inline bool has_absorbcalculatetype() const;
  inline void clear_absorbcalculatetype();
  static const int kAbsorbCalculateTypeFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>absorbcalculatetype</name>
  		<replaceName>AbsorbCalculateType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_absorbcalculatetype</name>
  		<replaceName>AbsorbCalculateType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_absorbcalculatetype</name>
  		<replaceName>AbsorbCalculateType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 absorbcalculatetype() const;
  inline void set_absorbcalculatetype(::google::protobuf::int32 value);

  // optional int32 AttributeOriginal = 9;
  inline bool has_attributeoriginal() const;
  inline void clear_attributeoriginal();
  static const int kAttributeOriginalFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>attributeoriginal</name>
  		<replaceName>AttributeOriginal</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributeoriginal</name>
  		<replaceName>AttributeOriginal</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributeoriginal</name>
  		<replaceName>AttributeOriginal</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributeoriginal() const;
  inline void set_attributeoriginal(::google::protobuf::int32 value);

  // optional int32 AttributeType = 10;
  inline bool has_attributetype() const;
  inline void clear_attributetype();
  static const int kAttributeTypeFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>attributetype</name>
  		<replaceName>AttributeType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributetype</name>
  		<replaceName>AttributeType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributetype</name>
  		<replaceName>AttributeType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributetype() const;
  inline void set_attributetype(::google::protobuf::int32 value);

  // optional int32 AttributePercenteParam = 11;
  inline bool has_attributepercenteparam() const;
  inline void clear_attributepercenteparam();
  static const int kAttributePercenteParamFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>attributepercenteparam</name>
  		<replaceName>AttributePercenteParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributepercenteparam</name>
  		<replaceName>AttributePercenteParam</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributepercenteparam</name>
  		<replaceName>AttributePercenteParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributepercenteparam() const;
  inline void set_attributepercenteparam(::google::protobuf::int32 value);

  // optional int32 AttributePercenteGrowth = 12;
  inline bool has_attributepercentegrowth() const;
  inline void clear_attributepercentegrowth();
  static const int kAttributePercenteGrowthFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>attributepercentegrowth</name>
  		<replaceName>AttributePercenteGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributepercentegrowth</name>
  		<replaceName>AttributePercenteGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributepercentegrowth</name>
  		<replaceName>AttributePercenteGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributepercentegrowth() const;
  inline void set_attributepercentegrowth(::google::protobuf::int32 value);

  // optional int32 AbsorbType = 13;
  inline bool has_absorbtype() const;
  inline void clear_absorbtype();
  static const int kAbsorbTypeFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>absorbtype</name>
  		<replaceName>AbsorbType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_absorbtype</name>
  		<replaceName>AbsorbType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_absorbtype</name>
  		<replaceName>AbsorbType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 absorbtype() const;
  inline void set_absorbtype(::google::protobuf::int32 value);

  // optional int32 AbsorbCount = 14;
  inline bool has_absorbcount() const;
  inline void clear_absorbcount();
  static const int kAbsorbCountFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>absorbcount</name>
  		<replaceName>AbsorbCount</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_absorbcount</name>
  		<replaceName>AbsorbCount</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_absorbcount</name>
  		<replaceName>AbsorbCount</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 absorbcount() const;
  inline void set_absorbcount(::google::protobuf::int32 value);

  // optional int32 Threshold = 15;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>BuffModAbsorbDamageConfig</name>
  	<Function>
  		<name>threshold</name>
  		<replaceName>Threshold</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_threshold</name>
  		<replaceName>Threshold</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_threshold</name>
  		<replaceName>Threshold</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 threshold() const;
  inline void set_threshold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModAbsorbDamageConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_valueparma();
  inline void clear_has_valueparma();
  inline void set_has_valuegrowth();
  inline void clear_has_valuegrowth();
  inline void set_has_iscureself();
  inline void clear_has_iscureself();
  inline void set_has_percentparam();
  inline void clear_has_percentparam();
  inline void set_has_percentgrowth();
  inline void clear_has_percentgrowth();
  inline void set_has_absorbcalculatetype();
  inline void clear_has_absorbcalculatetype();
  inline void set_has_attributeoriginal();
  inline void clear_has_attributeoriginal();
  inline void set_has_attributetype();
  inline void clear_has_attributetype();
  inline void set_has_attributepercenteparam();
  inline void clear_has_attributepercenteparam();
  inline void set_has_attributepercentegrowth();
  inline void clear_has_attributepercentegrowth();
  inline void set_has_absorbtype();
  inline void clear_has_absorbtype();
  inline void set_has_absorbcount();
  inline void clear_has_absorbcount();
  inline void set_has_threshold();
  inline void clear_has_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 valueparma_;
  ::google::protobuf::int32 valuegrowth_;
  ::google::protobuf::int32 iscureself_;
  ::google::protobuf::int32 percentparam_;
  ::google::protobuf::int32 percentgrowth_;
  ::google::protobuf::int32 absorbcalculatetype_;
  ::google::protobuf::int32 attributeoriginal_;
  ::google::protobuf::int32 attributetype_;
  ::google::protobuf::int32 attributepercenteparam_;
  ::google::protobuf::int32 attributepercentegrowth_;
  ::google::protobuf::int32 absorbtype_;
  ::google::protobuf::int32 absorbcount_;
  ::google::protobuf::int32 threshold_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModAbsorbDamageConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModNonTargettableConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModNonTargettableConfig : public ::google::protobuf::Message {
 public:
  BuffModNonTargettableConfig();
  virtual ~BuffModNonTargettableConfig();

  BuffModNonTargettableConfig(const BuffModNonTargettableConfig& from);

  inline BuffModNonTargettableConfig& operator=(const BuffModNonTargettableConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModNonTargettableConfig& default_instance();

  void Swap(BuffModNonTargettableConfig* other);

  // implements Message ----------------------------------------------

  BuffModNonTargettableConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModNonTargettableConfig& from);
  void MergeFrom(const BuffModNonTargettableConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModNonTargettableConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModNonTargettableConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // repeated int32 WhiteList = 3;
  inline int whitelist_size() const;
  inline void clear_whitelist();
  static const int kWhiteListFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModNonTargettableConfig</name>
  	<Function>
  		<name>whitelist</name>
  		<replaceName>WhiteList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_whitelist</name>
  		<replaceName>WhiteList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_whitelist</name>
  		<replaceName>WhiteList</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_whitelist</name>
  		<replaceName>WhiteList</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>whitelist_size</name>
  		<replaceName>WhiteList</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 whitelist(int index) const;
  inline void set_whitelist(int index, ::google::protobuf::int32 value);
  inline void add_whitelist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      whitelist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_whitelist();

  // @@protoc_insertion_point(class_scope:pb.BuffModNonTargettableConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > whitelist_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModNonTargettableConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModNonHostileTargettableConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModNonHostileTargettableConfig : public ::google::protobuf::Message {
 public:
  BuffModNonHostileTargettableConfig();
  virtual ~BuffModNonHostileTargettableConfig();

  BuffModNonHostileTargettableConfig(const BuffModNonHostileTargettableConfig& from);

  inline BuffModNonHostileTargettableConfig& operator=(const BuffModNonHostileTargettableConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModNonHostileTargettableConfig& default_instance();

  void Swap(BuffModNonHostileTargettableConfig* other);

  // implements Message ----------------------------------------------

  BuffModNonHostileTargettableConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModNonHostileTargettableConfig& from);
  void MergeFrom(const BuffModNonHostileTargettableConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModNonHostileTargettableConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModNonHostileTargettableConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModNonHostileTargettableConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModNonHostileTargettableConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModReflectDamageConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModReflectDamageConfig : public ::google::protobuf::Message {
 public:
  BuffModReflectDamageConfig();
  virtual ~BuffModReflectDamageConfig();

  BuffModReflectDamageConfig(const BuffModReflectDamageConfig& from);

  inline BuffModReflectDamageConfig& operator=(const BuffModReflectDamageConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModReflectDamageConfig& default_instance();

  void Swap(BuffModReflectDamageConfig* other);

  // implements Message ----------------------------------------------

  BuffModReflectDamageConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModReflectDamageConfig& from);
  void MergeFrom(const BuffModReflectDamageConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 ReboundType = 3;
  inline bool has_reboundtype() const;
  inline void clear_reboundtype();
  static const int kReboundTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>reboundtype</name>
  		<replaceName>ReboundType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_reboundtype</name>
  		<replaceName>ReboundType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_reboundtype</name>
  		<replaceName>ReboundType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 reboundtype() const;
  inline void set_reboundtype(::google::protobuf::int32 value);

  // optional .pb.BuffDataModel ReboundData = 4;
  inline bool has_rebounddata() const;
  inline void clear_rebounddata();
  static const int kReboundDataFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>rebounddata</name>
  		<replaceName>ReboundData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rebounddata</name>
  		<replaceName>ReboundData</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rebounddata</name>
  		<replaceName>ReboundData</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rebounddata</name>
  		<replaceName>ReboundData</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffDataModel& rebounddata() const;
  inline ::pb::BuffDataModel* mutable_rebounddata();
  inline ::pb::BuffDataModel* release_rebounddata();
  inline void set_allocated_rebounddata(::pb::BuffDataModel* rebounddata);

  // optional int32 ReboundCalculateType = 5;
  inline bool has_reboundcalculatetype() const;
  inline void clear_reboundcalculatetype();
  static const int kReboundCalculateTypeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>reboundcalculatetype</name>
  		<replaceName>ReboundCalculateType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_reboundcalculatetype</name>
  		<replaceName>ReboundCalculateType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_reboundcalculatetype</name>
  		<replaceName>ReboundCalculateType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 reboundcalculatetype() const;
  inline void set_reboundcalculatetype(::google::protobuf::int32 value);

  // optional int32 AttributeOriginal = 6;
  inline bool has_attributeoriginal() const;
  inline void clear_attributeoriginal();
  static const int kAttributeOriginalFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>attributeoriginal</name>
  		<replaceName>AttributeOriginal</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributeoriginal</name>
  		<replaceName>AttributeOriginal</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributeoriginal</name>
  		<replaceName>AttributeOriginal</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributeoriginal() const;
  inline void set_attributeoriginal(::google::protobuf::int32 value);

  // optional int32 AttributeType = 7;
  inline bool has_attributetype() const;
  inline void clear_attributetype();
  static const int kAttributeTypeFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>attributetype</name>
  		<replaceName>AttributeType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributetype</name>
  		<replaceName>AttributeType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributetype</name>
  		<replaceName>AttributeType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributetype() const;
  inline void set_attributetype(::google::protobuf::int32 value);

  // optional int32 AttributePercenteParam = 8;
  inline bool has_attributepercenteparam() const;
  inline void clear_attributepercenteparam();
  static const int kAttributePercenteParamFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>attributepercenteparam</name>
  		<replaceName>AttributePercenteParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributepercenteparam</name>
  		<replaceName>AttributePercenteParam</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributepercenteparam</name>
  		<replaceName>AttributePercenteParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributepercenteparam() const;
  inline void set_attributepercenteparam(::google::protobuf::int32 value);

  // optional int32 AttributePercenteGrowth = 9;
  inline bool has_attributepercentegrowth() const;
  inline void clear_attributepercentegrowth();
  static const int kAttributePercenteGrowthFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectDamageConfig</name>
  	<Function>
  		<name>attributepercentegrowth</name>
  		<replaceName>AttributePercenteGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attributepercentegrowth</name>
  		<replaceName>AttributePercenteGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attributepercentegrowth</name>
  		<replaceName>AttributePercenteGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 attributepercentegrowth() const;
  inline void set_attributepercentegrowth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModReflectDamageConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_reboundtype();
  inline void clear_has_reboundtype();
  inline void set_has_rebounddata();
  inline void clear_has_rebounddata();
  inline void set_has_reboundcalculatetype();
  inline void clear_has_reboundcalculatetype();
  inline void set_has_attributeoriginal();
  inline void clear_has_attributeoriginal();
  inline void set_has_attributetype();
  inline void clear_has_attributetype();
  inline void set_has_attributepercenteparam();
  inline void clear_has_attributepercenteparam();
  inline void set_has_attributepercentegrowth();
  inline void clear_has_attributepercentegrowth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::pb::BuffDataModel* rebounddata_;
  ::google::protobuf::int32 reboundtype_;
  ::google::protobuf::int32 reboundcalculatetype_;
  ::google::protobuf::int32 attributeoriginal_;
  ::google::protobuf::int32 attributetype_;
  ::google::protobuf::int32 attributepercenteparam_;
  ::google::protobuf::int32 attributepercentegrowth_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModReflectDamageConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModReflectSkillConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModReflectSkillConfig : public ::google::protobuf::Message {
 public:
  BuffModReflectSkillConfig();
  virtual ~BuffModReflectSkillConfig();

  BuffModReflectSkillConfig(const BuffModReflectSkillConfig& from);

  inline BuffModReflectSkillConfig& operator=(const BuffModReflectSkillConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModReflectSkillConfig& default_instance();

  void Swap(BuffModReflectSkillConfig* other);

  // implements Message ----------------------------------------------

  BuffModReflectSkillConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModReflectSkillConfig& from);
  void MergeFrom(const BuffModReflectSkillConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectSkillConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectSkillConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 ReboundCount = 3;
  inline bool has_reboundcount() const;
  inline void clear_reboundcount();
  static const int kReboundCountFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectSkillConfig</name>
  	<Function>
  		<name>reboundcount</name>
  		<replaceName>ReboundCount</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_reboundcount</name>
  		<replaceName>ReboundCount</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_reboundcount</name>
  		<replaceName>ReboundCount</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 reboundcount() const;
  inline void set_reboundcount(::google::protobuf::int32 value);

  // optional int32 ReboundType = 4;
  inline bool has_reboundtype() const;
  inline void clear_reboundtype();
  static const int kReboundTypeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModReflectSkillConfig</name>
  	<Function>
  		<name>reboundtype</name>
  		<replaceName>ReboundType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_reboundtype</name>
  		<replaceName>ReboundType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_reboundtype</name>
  		<replaceName>ReboundType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 reboundtype() const;
  inline void set_reboundtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModReflectSkillConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_reboundcount();
  inline void clear_has_reboundcount();
  inline void set_has_reboundtype();
  inline void clear_has_reboundtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 reboundcount_;
  ::google::protobuf::int32 reboundtype_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModReflectSkillConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModBuffImmunityConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModBuffImmunityConfig : public ::google::protobuf::Message {
 public:
  BuffModBuffImmunityConfig();
  virtual ~BuffModBuffImmunityConfig();

  BuffModBuffImmunityConfig(const BuffModBuffImmunityConfig& from);

  inline BuffModBuffImmunityConfig& operator=(const BuffModBuffImmunityConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModBuffImmunityConfig& default_instance();

  void Swap(BuffModBuffImmunityConfig* other);

  // implements Message ----------------------------------------------

  BuffModBuffImmunityConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModBuffImmunityConfig& from);
  void MergeFrom(const BuffModBuffImmunityConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModBuffImmunityConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModBuffImmunityConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 PurgeType = 3;
  inline bool has_purgetype() const;
  inline void clear_purgetype();
  static const int kPurgeTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModBuffImmunityConfig</name>
  	<Function>
  		<name>purgetype</name>
  		<replaceName>PurgeType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_purgetype</name>
  		<replaceName>PurgeType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_purgetype</name>
  		<replaceName>PurgeType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 purgetype() const;
  inline void set_purgetype(::google::protobuf::int32 value);

  // repeated int32 Data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModBuffImmunityConfig</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::int32 value);
  inline void add_data(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // optional bool ShowHint = 5;
  inline bool has_showhint() const;
  inline void clear_showhint();
  static const int kShowHintFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModBuffImmunityConfig</name>
  	<Function>
  		<name>showhint</name>
  		<replaceName>ShowHint</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_showhint</name>
  		<replaceName>ShowHint</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_showhint</name>
  		<replaceName>ShowHint</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool showhint() const;
  inline void set_showhint(bool value);

  // @@protoc_insertion_point(class_scope:pb.BuffModBuffImmunityConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_purgetype();
  inline void clear_has_purgetype();
  inline void set_has_showhint();
  inline void clear_has_showhint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 purgetype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  bool active_;
  bool showhint_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModBuffImmunityConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModSkillImmunityConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModSkillImmunityConfig : public ::google::protobuf::Message {
 public:
  BuffModSkillImmunityConfig();
  virtual ~BuffModSkillImmunityConfig();

  BuffModSkillImmunityConfig(const BuffModSkillImmunityConfig& from);

  inline BuffModSkillImmunityConfig& operator=(const BuffModSkillImmunityConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModSkillImmunityConfig& default_instance();

  void Swap(BuffModSkillImmunityConfig* other);

  // implements Message ----------------------------------------------

  BuffModSkillImmunityConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModSkillImmunityConfig& from);
  void MergeFrom(const BuffModSkillImmunityConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModSkillImmunityConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional bool ShowHint = 2;
  inline bool has_showhint() const;
  inline void clear_showhint();
  static const int kShowHintFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModSkillImmunityConfig</name>
  	<Function>
  		<name>showhint</name>
  		<replaceName>ShowHint</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_showhint</name>
  		<replaceName>ShowHint</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_showhint</name>
  		<replaceName>ShowHint</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool showhint() const;
  inline void set_showhint(bool value);

  // optional int32 ImmuneType = 3;
  inline bool has_immunetype() const;
  inline void clear_immunetype();
  static const int kImmuneTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModSkillImmunityConfig</name>
  	<Function>
  		<name>immunetype</name>
  		<replaceName>ImmuneType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_immunetype</name>
  		<replaceName>ImmuneType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_immunetype</name>
  		<replaceName>ImmuneType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 immunetype() const;
  inline void set_immunetype(::google::protobuf::int32 value);

  // repeated int32 Data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModSkillImmunityConfig</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::int32 value);
  inline void add_data(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // optional int32 DelayTime = 5;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModSkillImmunityConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModSkillImmunityConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_showhint();
  inline void clear_has_showhint();
  inline void set_has_immunetype();
  inline void clear_has_immunetype();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  bool showhint_;
  ::google::protobuf::int32 immunetype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  ::google::protobuf::int32 delaytime_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModSkillImmunityConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModHitActionImmunityConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModHitActionImmunityConfig : public ::google::protobuf::Message {
 public:
  BuffModHitActionImmunityConfig();
  virtual ~BuffModHitActionImmunityConfig();

  BuffModHitActionImmunityConfig(const BuffModHitActionImmunityConfig& from);

  inline BuffModHitActionImmunityConfig& operator=(const BuffModHitActionImmunityConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModHitActionImmunityConfig& default_instance();

  void Swap(BuffModHitActionImmunityConfig* other);

  // implements Message ----------------------------------------------

  BuffModHitActionImmunityConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModHitActionImmunityConfig& from);
  void MergeFrom(const BuffModHitActionImmunityConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModHitActionImmunityConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModHitActionImmunityConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModHitActionImmunityConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModHitActionImmunityConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModDispelConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModDispelConfig : public ::google::protobuf::Message {
 public:
  BuffModDispelConfig();
  virtual ~BuffModDispelConfig();

  BuffModDispelConfig(const BuffModDispelConfig& from);

  inline BuffModDispelConfig& operator=(const BuffModDispelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModDispelConfig& default_instance();

  void Swap(BuffModDispelConfig* other);

  // implements Message ----------------------------------------------

  BuffModDispelConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModDispelConfig& from);
  void MergeFrom(const BuffModDispelConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 CleanType = 3;
  inline bool has_cleantype() const;
  inline void clear_cleantype();
  static const int kCleanTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>cleantype</name>
  		<replaceName>CleanType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_cleantype</name>
  		<replaceName>CleanType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cleantype</name>
  		<replaceName>CleanType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 cleantype() const;
  inline void set_cleantype(::google::protobuf::int32 value);

  // repeated int32 BuffList = 4;
  inline int bufflist_size() const;
  inline void clear_bufflist();
  static const int kBuffListFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_bufflist</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>bufflist_size</name>
  		<replaceName>BuffList</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 bufflist(int index) const;
  inline void set_bufflist(int index, ::google::protobuf::int32 value);
  inline void add_bufflist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bufflist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bufflist();

  // optional bool IsPartof = 5;
  inline bool has_ispartof() const;
  inline void clear_ispartof();
  static const int kIsPartofFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>ispartof</name>
  		<replaceName>IsPartof</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_ispartof</name>
  		<replaceName>IsPartof</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_ispartof</name>
  		<replaceName>IsPartof</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool ispartof() const;
  inline void set_ispartof(bool value);

  // optional int32 Count = 6;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 CleanLevel = 7;
  inline bool has_cleanlevel() const;
  inline void clear_cleanlevel();
  static const int kCleanLevelFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>cleanlevel</name>
  		<replaceName>CleanLevel</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_cleanlevel</name>
  		<replaceName>CleanLevel</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cleanlevel</name>
  		<replaceName>CleanLevel</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 cleanlevel() const;
  inline void set_cleanlevel(::google::protobuf::int32 value);

  // optional bool IsOnNum = 8;
  inline bool has_isonnum() const;
  inline void clear_isonnum();
  static const int kIsOnNumFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BuffModDispelConfig</name>
  	<Function>
  		<name>isonnum</name>
  		<replaceName>IsOnNum</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_isonnum</name>
  		<replaceName>IsOnNum</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_isonnum</name>
  		<replaceName>IsOnNum</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool isonnum() const;
  inline void set_isonnum(bool value);

  // @@protoc_insertion_point(class_scope:pb.BuffModDispelConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_cleantype();
  inline void clear_has_cleantype();
  inline void set_has_ispartof();
  inline void clear_has_ispartof();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_cleanlevel();
  inline void clear_has_cleanlevel();
  inline void set_has_isonnum();
  inline void clear_has_isonnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 cleantype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bufflist_;
  bool active_;
  bool ispartof_;
  bool isonnum_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 cleanlevel_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModDispelConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModStealHpConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModStealHpConfig : public ::google::protobuf::Message {
 public:
  BuffModStealHpConfig();
  virtual ~BuffModStealHpConfig();

  BuffModStealHpConfig(const BuffModStealHpConfig& from);

  inline BuffModStealHpConfig& operator=(const BuffModStealHpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModStealHpConfig& default_instance();

  void Swap(BuffModStealHpConfig* other);

  // implements Message ----------------------------------------------

  BuffModStealHpConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModStealHpConfig& from);
  void MergeFrom(const BuffModStealHpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModStealHpConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModStealHpConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 StealLifeType = 3;
  inline bool has_steallifetype() const;
  inline void clear_steallifetype();
  static const int kStealLifeTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModStealHpConfig</name>
  	<Function>
  		<name>steallifetype</name>
  		<replaceName>StealLifeType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_steallifetype</name>
  		<replaceName>StealLifeType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_steallifetype</name>
  		<replaceName>StealLifeType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 steallifetype() const;
  inline void set_steallifetype(::google::protobuf::int32 value);

  // optional .pb.BuffDataModel StealLifeData = 4;
  inline bool has_steallifedata() const;
  inline void clear_steallifedata();
  static const int kStealLifeDataFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModStealHpConfig</name>
  	<Function>
  		<name>steallifedata</name>
  		<replaceName>StealLifeData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_steallifedata</name>
  		<replaceName>StealLifeData</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_steallifedata</name>
  		<replaceName>StealLifeData</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_steallifedata</name>
  		<replaceName>StealLifeData</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffDataModel& steallifedata() const;
  inline ::pb::BuffDataModel* mutable_steallifedata();
  inline ::pb::BuffDataModel* release_steallifedata();
  inline void set_allocated_steallifedata(::pb::BuffDataModel* steallifedata);

  // optional int32 StealMoment = 5;
  inline bool has_stealmoment() const;
  inline void clear_stealmoment();
  static const int kStealMomentFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModStealHpConfig</name>
  	<Function>
  		<name>stealmoment</name>
  		<replaceName>StealMoment</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_stealmoment</name>
  		<replaceName>StealMoment</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_stealmoment</name>
  		<replaceName>StealMoment</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 stealmoment() const;
  inline void set_stealmoment(::google::protobuf::int32 value);

  // repeated int32 BuffSubTypeFilter = 6;
  inline int buffsubtypefilter_size() const;
  inline void clear_buffsubtypefilter();
  static const int kBuffSubTypeFilterFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffModStealHpConfig</name>
  	<Function>
  		<name>buffsubtypefilter</name>
  		<replaceName>BuffSubTypeFilter</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_buffsubtypefilter</name>
  		<replaceName>BuffSubTypeFilter</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_buffsubtypefilter</name>
  		<replaceName>BuffSubTypeFilter</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffsubtypefilter</name>
  		<replaceName>BuffSubTypeFilter</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>buffsubtypefilter_size</name>
  		<replaceName>BuffSubTypeFilter</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 buffsubtypefilter(int index) const;
  inline void set_buffsubtypefilter(int index, ::google::protobuf::int32 value);
  inline void add_buffsubtypefilter(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      buffsubtypefilter() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_buffsubtypefilter();

  // @@protoc_insertion_point(class_scope:pb.BuffModStealHpConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_steallifetype();
  inline void clear_has_steallifetype();
  inline void set_has_steallifedata();
  inline void clear_has_steallifedata();
  inline void set_has_stealmoment();
  inline void clear_has_stealmoment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::pb::BuffDataModel* steallifedata_;
  ::google::protobuf::int32 steallifetype_;
  ::google::protobuf::int32 stealmoment_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > buffsubtypefilter_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModStealHpConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModDamageShareConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModDamageShareConfig : public ::google::protobuf::Message {
 public:
  BuffModDamageShareConfig();
  virtual ~BuffModDamageShareConfig();

  BuffModDamageShareConfig(const BuffModDamageShareConfig& from);

  inline BuffModDamageShareConfig& operator=(const BuffModDamageShareConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModDamageShareConfig& default_instance();

  void Swap(BuffModDamageShareConfig* other);

  // implements Message ----------------------------------------------

  BuffModDamageShareConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModDamageShareConfig& from);
  void MergeFrom(const BuffModDamageShareConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageShareConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageShareConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 PercentParam = 3;
  inline bool has_percentparam() const;
  inline void clear_percentparam();
  static const int kPercentParamFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageShareConfig</name>
  	<Function>
  		<name>percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentparam() const;
  inline void set_percentparam(::google::protobuf::int32 value);

  // optional int32 PercentGrowth = 4;
  inline bool has_percentgrowth() const;
  inline void clear_percentgrowth();
  static const int kPercentGrowthFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageShareConfig</name>
  	<Function>
  		<name>percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentgrowth() const;
  inline void set_percentgrowth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModDamageShareConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_percentparam();
  inline void clear_has_percentparam();
  inline void set_has_percentgrowth();
  inline void clear_has_percentgrowth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 percentparam_;
  ::google::protobuf::int32 percentgrowth_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModDamageShareConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModDamageCopyConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModDamageCopyConfig : public ::google::protobuf::Message {
 public:
  BuffModDamageCopyConfig();
  virtual ~BuffModDamageCopyConfig();

  BuffModDamageCopyConfig(const BuffModDamageCopyConfig& from);

  inline BuffModDamageCopyConfig& operator=(const BuffModDamageCopyConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModDamageCopyConfig& default_instance();

  void Swap(BuffModDamageCopyConfig* other);

  // implements Message ----------------------------------------------

  BuffModDamageCopyConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModDamageCopyConfig& from);
  void MergeFrom(const BuffModDamageCopyConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageCopyConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageCopyConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 PercentParam = 3;
  inline bool has_percentparam() const;
  inline void clear_percentparam();
  static const int kPercentParamFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageCopyConfig</name>
  	<Function>
  		<name>percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentparam() const;
  inline void set_percentparam(::google::protobuf::int32 value);

  // optional int32 PercentGrowth = 4;
  inline bool has_percentgrowth() const;
  inline void clear_percentgrowth();
  static const int kPercentGrowthFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageCopyConfig</name>
  	<Function>
  		<name>percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentgrowth() const;
  inline void set_percentgrowth(::google::protobuf::int32 value);

  // optional bool IgnoreSelf = 5;
  inline bool has_ignoreself() const;
  inline void clear_ignoreself();
  static const int kIgnoreSelfFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageCopyConfig</name>
  	<Function>
  		<name>ignoreself</name>
  		<replaceName>IgnoreSelf</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_ignoreself</name>
  		<replaceName>IgnoreSelf</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_ignoreself</name>
  		<replaceName>IgnoreSelf</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool ignoreself() const;
  inline void set_ignoreself(bool value);

  // @@protoc_insertion_point(class_scope:pb.BuffModDamageCopyConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_percentparam();
  inline void clear_has_percentparam();
  inline void set_has_percentgrowth();
  inline void clear_has_percentgrowth();
  inline void set_has_ignoreself();
  inline void clear_has_ignoreself();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 percentparam_;
  bool active_;
  bool ignoreself_;
  ::google::protobuf::int32 percentgrowth_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModDamageCopyConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModHealCopyConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModHealCopyConfig : public ::google::protobuf::Message {
 public:
  BuffModHealCopyConfig();
  virtual ~BuffModHealCopyConfig();

  BuffModHealCopyConfig(const BuffModHealCopyConfig& from);

  inline BuffModHealCopyConfig& operator=(const BuffModHealCopyConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModHealCopyConfig& default_instance();

  void Swap(BuffModHealCopyConfig* other);

  // implements Message ----------------------------------------------

  BuffModHealCopyConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModHealCopyConfig& from);
  void MergeFrom(const BuffModHealCopyConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModHealCopyConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModHealCopyConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 PercentParam = 3;
  inline bool has_percentparam() const;
  inline void clear_percentparam();
  static const int kPercentParamFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModHealCopyConfig</name>
  	<Function>
  		<name>percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentparam</name>
  		<replaceName>PercentParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentparam() const;
  inline void set_percentparam(::google::protobuf::int32 value);

  // optional int32 PercentGrowth = 4;
  inline bool has_percentgrowth() const;
  inline void clear_percentgrowth();
  static const int kPercentGrowthFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModHealCopyConfig</name>
  	<Function>
  		<name>percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentgrowth() const;
  inline void set_percentgrowth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModHealCopyConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_percentparam();
  inline void clear_has_percentparam();
  inline void set_has_percentgrowth();
  inline void clear_has_percentgrowth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 percentparam_;
  ::google::protobuf::int32 percentgrowth_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModHealCopyConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModHpConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModHpConfig : public ::google::protobuf::Message {
 public:
  BuffModHpConfig();
  virtual ~BuffModHpConfig();

  BuffModHpConfig(const BuffModHpConfig& from);

  inline BuffModHpConfig& operator=(const BuffModHpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModHpConfig& default_instance();

  void Swap(BuffModHpConfig* other);

  // implements Message ----------------------------------------------

  BuffModHpConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModHpConfig& from);
  void MergeFrom(const BuffModHpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 Count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 Interval = 4;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>interval</name>
  		<replaceName>Interval</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_interval</name>
  		<replaceName>Interval</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_interval</name>
  		<replaceName>Interval</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);

  // optional int32 Type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .pb.BuffDatasModel Data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffDatasModel& data() const;
  inline ::pb::BuffDatasModel* mutable_data();
  inline ::pb::BuffDatasModel* release_data();
  inline void set_allocated_data(::pb::BuffDatasModel* data);

  // optional int32 PercentGrowth = 8;
  inline bool has_percentgrowth() const;
  inline void clear_percentgrowth();
  static const int kPercentGrowthFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentgrowth() const;
  inline void set_percentgrowth(::google::protobuf::int32 value);

  // optional int32 ValueGrowth = 9;
  inline bool has_valuegrowth() const;
  inline void clear_valuegrowth();
  static const int kValueGrowthFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>BuffModHpConfig</name>
  	<Function>
  		<name>valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 valuegrowth() const;
  inline void set_valuegrowth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModHpConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_percentgrowth();
  inline void clear_has_percentgrowth();
  inline void set_has_valuegrowth();
  inline void clear_has_valuegrowth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 interval_;
  ::pb::BuffDatasModel* data_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 percentgrowth_;
  ::google::protobuf::int32 valuegrowth_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModHpConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModRageConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModRageConfig : public ::google::protobuf::Message {
 public:
  BuffModRageConfig();
  virtual ~BuffModRageConfig();

  BuffModRageConfig(const BuffModRageConfig& from);

  inline BuffModRageConfig& operator=(const BuffModRageConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModRageConfig& default_instance();

  void Swap(BuffModRageConfig* other);

  // implements Message ----------------------------------------------

  BuffModRageConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModRageConfig& from);
  void MergeFrom(const BuffModRageConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 Count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 Interval = 4;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>interval</name>
  		<replaceName>Interval</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_interval</name>
  		<replaceName>Interval</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_interval</name>
  		<replaceName>Interval</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);

  // optional int32 Type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .pb.BuffDatasModel Data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffDatasModel& data() const;
  inline ::pb::BuffDatasModel* mutable_data();
  inline ::pb::BuffDatasModel* release_data();
  inline void set_allocated_data(::pb::BuffDatasModel* data);

  // optional int32 PercentGrowth = 7;
  inline bool has_percentgrowth() const;
  inline void clear_percentgrowth();
  static const int kPercentGrowthFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_percentgrowth</name>
  		<replaceName>PercentGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 percentgrowth() const;
  inline void set_percentgrowth(::google::protobuf::int32 value);

  // optional int32 ValueGrowth = 8;
  inline bool has_valuegrowth() const;
  inline void clear_valuegrowth();
  static const int kValueGrowthFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BuffModRageConfig</name>
  	<Function>
  		<name>valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_valuegrowth</name>
  		<replaceName>ValueGrowth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 valuegrowth() const;
  inline void set_valuegrowth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModRageConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_percentgrowth();
  inline void clear_has_percentgrowth();
  inline void set_has_valuegrowth();
  inline void clear_has_valuegrowth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 interval_;
  ::pb::BuffDatasModel* data_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 percentgrowth_;
  ::google::protobuf::int32 valuegrowth_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModRageConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModRecordDataConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModRecordDataConfig : public ::google::protobuf::Message {
 public:
  BuffModRecordDataConfig();
  virtual ~BuffModRecordDataConfig();

  BuffModRecordDataConfig(const BuffModRecordDataConfig& from);

  inline BuffModRecordDataConfig& operator=(const BuffModRecordDataConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModRecordDataConfig& default_instance();

  void Swap(BuffModRecordDataConfig* other);

  // implements Message ----------------------------------------------

  BuffModRecordDataConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModRecordDataConfig& from);
  void MergeFrom(const BuffModRecordDataConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModRecordDataConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 DelayTime = 2;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModRecordDataConfig</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 delaytime() const;
  inline void set_delaytime(::google::protobuf::int32 value);

  // optional int32 TypeMajor = 3;
  inline bool has_typemajor() const;
  inline void clear_typemajor();
  static const int kTypeMajorFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffModRecordDataConfig</name>
  	<Function>
  		<name>typemajor</name>
  		<replaceName>TypeMajor</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_typemajor</name>
  		<replaceName>TypeMajor</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_typemajor</name>
  		<replaceName>TypeMajor</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 typemajor() const;
  inline void set_typemajor(::google::protobuf::int32 value);

  // optional int32 TriggerBody = 4;
  inline bool has_triggerbody() const;
  inline void clear_triggerbody();
  static const int kTriggerBodyFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffModRecordDataConfig</name>
  	<Function>
  		<name>triggerbody</name>
  		<replaceName>TriggerBody</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggerbody</name>
  		<replaceName>TriggerBody</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggerbody</name>
  		<replaceName>TriggerBody</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 triggerbody() const;
  inline void set_triggerbody(::google::protobuf::int32 value);

  // optional int32 DataType = 5;
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDataTypeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BuffModRecordDataConfig</name>
  	<Function>
  		<name>datatype</name>
  		<replaceName>DataType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_datatype</name>
  		<replaceName>DataType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_datatype</name>
  		<replaceName>DataType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 datatype() const;
  inline void set_datatype(::google::protobuf::int32 value);

  // optional int32 TypeSub = 6;
  inline bool has_typesub() const;
  inline void clear_typesub();
  static const int kTypeSubFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffModRecordDataConfig</name>
  	<Function>
  		<name>typesub</name>
  		<replaceName>TypeSub</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_typesub</name>
  		<replaceName>TypeSub</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_typesub</name>
  		<replaceName>TypeSub</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 typesub() const;
  inline void set_typesub(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModRecordDataConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_typemajor();
  inline void clear_has_typemajor();
  inline void set_has_triggerbody();
  inline void clear_has_triggerbody();
  inline void set_has_datatype();
  inline void clear_has_datatype();
  inline void set_has_typesub();
  inline void clear_has_typesub();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 delaytime_;
  ::google::protobuf::int32 typemajor_;
  ::google::protobuf::int32 triggerbody_;
  ::google::protobuf::int32 datatype_;
  ::google::protobuf::int32 typesub_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModRecordDataConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModHarmOnMoveConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModHarmOnMoveConfig : public ::google::protobuf::Message {
 public:
  BuffModHarmOnMoveConfig();
  virtual ~BuffModHarmOnMoveConfig();

  BuffModHarmOnMoveConfig(const BuffModHarmOnMoveConfig& from);

  inline BuffModHarmOnMoveConfig& operator=(const BuffModHarmOnMoveConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModHarmOnMoveConfig& default_instance();

  void Swap(BuffModHarmOnMoveConfig* other);

  // implements Message ----------------------------------------------

  BuffModHarmOnMoveConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModHarmOnMoveConfig& from);
  void MergeFrom(const BuffModHarmOnMoveConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModHarmOnMoveConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 SkillId = 2;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModHarmOnMoveConfig</name>
  	<Function>
  		<name>skillid</name>
  		<replaceName>SkillId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_skillid</name>
  		<replaceName>SkillId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_skillid</name>
  		<replaceName>SkillId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModHarmOnMoveConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 skillid_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModHarmOnMoveConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffModDamageImmunityConfig</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffModDamageImmunityConfig : public ::google::protobuf::Message {
 public:
  BuffModDamageImmunityConfig();
  virtual ~BuffModDamageImmunityConfig();

  BuffModDamageImmunityConfig(const BuffModDamageImmunityConfig& from);

  inline BuffModDamageImmunityConfig& operator=(const BuffModDamageImmunityConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffModDamageImmunityConfig& default_instance();

  void Swap(BuffModDamageImmunityConfig* other);

  // implements Message ----------------------------------------------

  BuffModDamageImmunityConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffModDamageImmunityConfig& from);
  void MergeFrom(const BuffModDamageImmunityConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageImmunityConfig</name>
  	<Function>
  		<name>active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_active</name>
  		<replaceName>Active</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool active() const;
  inline void set_active(bool value);

  // optional int32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffModDamageImmunityConfig</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BuffModDamageImmunityConfig)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffModDamageImmunityConfig* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BuffData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BuffData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BuffData : public ::google::protobuf::Message {
 public:
  BuffData();
  virtual ~BuffData();

  BuffData(const BuffData& from);

  inline BuffData& operator=(const BuffData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffData& default_instance();

  void Swap(BuffData* other);

  // implements Message ----------------------------------------------

  BuffData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffData& from);
  void MergeFrom(const BuffData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .pb.BuffBaseDataModel BaseDataModel = 2;
  inline bool has_basedatamodel() const;
  inline void clear_basedatamodel();
  static const int kBaseDataModelFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>basedatamodel</name>
  		<replaceName>BaseDataModel</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_basedatamodel</name>
  		<replaceName>BaseDataModel</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_basedatamodel</name>
  		<replaceName>BaseDataModel</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_basedatamodel</name>
  		<replaceName>BaseDataModel</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffBaseDataModel& basedatamodel() const;
  inline ::pb::BuffBaseDataModel* mutable_basedatamodel();
  inline ::pb::BuffBaseDataModel* release_basedatamodel();
  inline void set_allocated_basedatamodel(::pb::BuffBaseDataModel* basedatamodel);

  // optional .pb.SpecialHitModel SpecialHitModel = 3;
  inline bool has_specialhitmodel() const;
  inline void clear_specialhitmodel();
  static const int kSpecialHitModelFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>specialhitmodel</name>
  		<replaceName>SpecialHitModel</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_specialhitmodel</name>
  		<replaceName>SpecialHitModel</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_specialhitmodel</name>
  		<replaceName>SpecialHitModel</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_specialhitmodel</name>
  		<replaceName>SpecialHitModel</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SpecialHitModel& specialhitmodel() const;
  inline ::pb::SpecialHitModel* mutable_specialhitmodel();
  inline ::pb::SpecialHitModel* release_specialhitmodel();
  inline void set_allocated_specialhitmodel(::pb::SpecialHitModel* specialhitmodel);

  // optional .pb.BuffModHpConfig BuffModHpConfig = 27;
  inline bool has_buffmodhpconfig() const;
  inline void clear_buffmodhpconfig();
  static const int kBuffModHpConfigFieldNumber = 27;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodhpconfig</name>
  		<replaceName>BuffModHpConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodhpconfig</name>
  		<replaceName>BuffModHpConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodhpconfig</name>
  		<replaceName>BuffModHpConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodhpconfig</name>
  		<replaceName>BuffModHpConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModHpConfig& buffmodhpconfig() const;
  inline ::pb::BuffModHpConfig* mutable_buffmodhpconfig();
  inline ::pb::BuffModHpConfig* release_buffmodhpconfig();
  inline void set_allocated_buffmodhpconfig(::pb::BuffModHpConfig* buffmodhpconfig);

  // optional .pb.BuffModReflectDamageConfig BuffModReflectDamageConfig = 17;
  inline bool has_buffmodreflectdamageconfig() const;
  inline void clear_buffmodreflectdamageconfig();
  static const int kBuffModReflectDamageConfigFieldNumber = 17;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodreflectdamageconfig</name>
  		<replaceName>BuffModReflectDamageConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodreflectdamageconfig</name>
  		<replaceName>BuffModReflectDamageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodreflectdamageconfig</name>
  		<replaceName>BuffModReflectDamageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodreflectdamageconfig</name>
  		<replaceName>BuffModReflectDamageConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModReflectDamageConfig& buffmodreflectdamageconfig() const;
  inline ::pb::BuffModReflectDamageConfig* mutable_buffmodreflectdamageconfig();
  inline ::pb::BuffModReflectDamageConfig* release_buffmodreflectdamageconfig();
  inline void set_allocated_buffmodreflectdamageconfig(::pb::BuffModReflectDamageConfig* buffmodreflectdamageconfig);

  // optional .pb.BuffModReflectSkillConfig BuffModReflectSkillConfig = 18;
  inline bool has_buffmodreflectskillconfig() const;
  inline void clear_buffmodreflectskillconfig();
  static const int kBuffModReflectSkillConfigFieldNumber = 18;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodreflectskillconfig</name>
  		<replaceName>BuffModReflectSkillConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodreflectskillconfig</name>
  		<replaceName>BuffModReflectSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodreflectskillconfig</name>
  		<replaceName>BuffModReflectSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodreflectskillconfig</name>
  		<replaceName>BuffModReflectSkillConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModReflectSkillConfig& buffmodreflectskillconfig() const;
  inline ::pb::BuffModReflectSkillConfig* mutable_buffmodreflectskillconfig();
  inline ::pb::BuffModReflectSkillConfig* release_buffmodreflectskillconfig();
  inline void set_allocated_buffmodreflectskillconfig(::pb::BuffModReflectSkillConfig* buffmodreflectskillconfig);

  // optional .pb.BuffModBuffImmunityConfig BuffModBuffImmunityConfig = 19;
  inline bool has_buffmodbuffimmunityconfig() const;
  inline void clear_buffmodbuffimmunityconfig();
  static const int kBuffModBuffImmunityConfigFieldNumber = 19;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodbuffimmunityconfig</name>
  		<replaceName>BuffModBuffImmunityConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodbuffimmunityconfig</name>
  		<replaceName>BuffModBuffImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodbuffimmunityconfig</name>
  		<replaceName>BuffModBuffImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodbuffimmunityconfig</name>
  		<replaceName>BuffModBuffImmunityConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModBuffImmunityConfig& buffmodbuffimmunityconfig() const;
  inline ::pb::BuffModBuffImmunityConfig* mutable_buffmodbuffimmunityconfig();
  inline ::pb::BuffModBuffImmunityConfig* release_buffmodbuffimmunityconfig();
  inline void set_allocated_buffmodbuffimmunityconfig(::pb::BuffModBuffImmunityConfig* buffmodbuffimmunityconfig);

  // optional .pb.BuffModPropertyConfig BuffModPropertyConfig = 36;
  inline bool has_buffmodpropertyconfig() const;
  inline void clear_buffmodpropertyconfig();
  static const int kBuffModPropertyConfigFieldNumber = 36;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodpropertyconfig</name>
  		<replaceName>BuffModPropertyConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodpropertyconfig</name>
  		<replaceName>BuffModPropertyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodpropertyconfig</name>
  		<replaceName>BuffModPropertyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodpropertyconfig</name>
  		<replaceName>BuffModPropertyConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModPropertyConfig& buffmodpropertyconfig() const;
  inline ::pb::BuffModPropertyConfig* mutable_buffmodpropertyconfig();
  inline ::pb::BuffModPropertyConfig* release_buffmodpropertyconfig();
  inline void set_allocated_buffmodpropertyconfig(::pb::BuffModPropertyConfig* buffmodpropertyconfig);

  // optional .pb.BuffModAttackSpeedConfig BuffModAttackSpeedConfig = 6;
  inline bool has_buffmodattackspeedconfig() const;
  inline void clear_buffmodattackspeedconfig();
  static const int kBuffModAttackSpeedConfigFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodattackspeedconfig</name>
  		<replaceName>BuffModAttackSpeedConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodattackspeedconfig</name>
  		<replaceName>BuffModAttackSpeedConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodattackspeedconfig</name>
  		<replaceName>BuffModAttackSpeedConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodattackspeedconfig</name>
  		<replaceName>BuffModAttackSpeedConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModAttackSpeedConfig& buffmodattackspeedconfig() const;
  inline ::pb::BuffModAttackSpeedConfig* mutable_buffmodattackspeedconfig();
  inline ::pb::BuffModAttackSpeedConfig* release_buffmodattackspeedconfig();
  inline void set_allocated_buffmodattackspeedconfig(::pb::BuffModAttackSpeedConfig* buffmodattackspeedconfig);

  // optional .pb.BuffModRageConfig BuffModRageConfig = 28;
  inline bool has_buffmodrageconfig() const;
  inline void clear_buffmodrageconfig();
  static const int kBuffModRageConfigFieldNumber = 28;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodrageconfig</name>
  		<replaceName>BuffModRageConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodrageconfig</name>
  		<replaceName>BuffModRageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodrageconfig</name>
  		<replaceName>BuffModRageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodrageconfig</name>
  		<replaceName>BuffModRageConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRageConfig& buffmodrageconfig() const;
  inline ::pb::BuffModRageConfig* mutable_buffmodrageconfig();
  inline ::pb::BuffModRageConfig* release_buffmodrageconfig();
  inline void set_allocated_buffmodrageconfig(::pb::BuffModRageConfig* buffmodrageconfig);

  // optional .pb.BuffModAbsorbDamageConfig BuffModAbsorbDamageConfig = 14;
  inline bool has_buffmodabsorbdamageconfig() const;
  inline void clear_buffmodabsorbdamageconfig();
  static const int kBuffModAbsorbDamageConfigFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodabsorbdamageconfig</name>
  		<replaceName>BuffModAbsorbDamageConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodabsorbdamageconfig</name>
  		<replaceName>BuffModAbsorbDamageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodabsorbdamageconfig</name>
  		<replaceName>BuffModAbsorbDamageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodabsorbdamageconfig</name>
  		<replaceName>BuffModAbsorbDamageConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModAbsorbDamageConfig& buffmodabsorbdamageconfig() const;
  inline ::pb::BuffModAbsorbDamageConfig* mutable_buffmodabsorbdamageconfig();
  inline ::pb::BuffModAbsorbDamageConfig* release_buffmodabsorbdamageconfig();
  inline void set_allocated_buffmodabsorbdamageconfig(::pb::BuffModAbsorbDamageConfig* buffmodabsorbdamageconfig);

  // optional .pb.BuffModNonHostileTargettableConfig BuffModNonHostileTargettableConfig = 37;
  inline bool has_buffmodnonhostiletargettableconfig() const;
  inline void clear_buffmodnonhostiletargettableconfig();
  static const int kBuffModNonHostileTargettableConfigFieldNumber = 37;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnonhostiletargettableconfig</name>
  		<replaceName>BuffModNonHostileTargettableConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnonhostiletargettableconfig</name>
  		<replaceName>BuffModNonHostileTargettableConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnonhostiletargettableconfig</name>
  		<replaceName>BuffModNonHostileTargettableConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnonhostiletargettableconfig</name>
  		<replaceName>BuffModNonHostileTargettableConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNonHostileTargettableConfig& buffmodnonhostiletargettableconfig() const;
  inline ::pb::BuffModNonHostileTargettableConfig* mutable_buffmodnonhostiletargettableconfig();
  inline ::pb::BuffModNonHostileTargettableConfig* release_buffmodnonhostiletargettableconfig();
  inline void set_allocated_buffmodnonhostiletargettableconfig(::pb::BuffModNonHostileTargettableConfig* buffmodnonhostiletargettableconfig);

  // optional .pb.BuffModNonTargettableConfig BuffModNonTargettableConfig = 16;
  inline bool has_buffmodnontargettableconfig() const;
  inline void clear_buffmodnontargettableconfig();
  static const int kBuffModNonTargettableConfigFieldNumber = 16;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnontargettableconfig</name>
  		<replaceName>BuffModNonTargettableConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnontargettableconfig</name>
  		<replaceName>BuffModNonTargettableConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnontargettableconfig</name>
  		<replaceName>BuffModNonTargettableConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnontargettableconfig</name>
  		<replaceName>BuffModNonTargettableConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNonTargettableConfig& buffmodnontargettableconfig() const;
  inline ::pb::BuffModNonTargettableConfig* mutable_buffmodnontargettableconfig();
  inline ::pb::BuffModNonTargettableConfig* release_buffmodnontargettableconfig();
  inline void set_allocated_buffmodnontargettableconfig(::pb::BuffModNonTargettableConfig* buffmodnontargettableconfig);

  // optional .pb.BuffModDamageShareConfig BuffModDamageShareConfig = 24;
  inline bool has_buffmoddamageshareconfig() const;
  inline void clear_buffmoddamageshareconfig();
  static const int kBuffModDamageShareConfigFieldNumber = 24;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddamageshareconfig</name>
  		<replaceName>BuffModDamageShareConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddamageshareconfig</name>
  		<replaceName>BuffModDamageShareConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddamageshareconfig</name>
  		<replaceName>BuffModDamageShareConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddamageshareconfig</name>
  		<replaceName>BuffModDamageShareConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDamageShareConfig& buffmoddamageshareconfig() const;
  inline ::pb::BuffModDamageShareConfig* mutable_buffmoddamageshareconfig();
  inline ::pb::BuffModDamageShareConfig* release_buffmoddamageshareconfig();
  inline void set_allocated_buffmoddamageshareconfig(::pb::BuffModDamageShareConfig* buffmoddamageshareconfig);

  // optional .pb.BuffModHealCopyConfig BuffModHealCopyConfig = 26;
  inline bool has_buffmodhealcopyconfig() const;
  inline void clear_buffmodhealcopyconfig();
  static const int kBuffModHealCopyConfigFieldNumber = 26;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodhealcopyconfig</name>
  		<replaceName>BuffModHealCopyConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodhealcopyconfig</name>
  		<replaceName>BuffModHealCopyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodhealcopyconfig</name>
  		<replaceName>BuffModHealCopyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodhealcopyconfig</name>
  		<replaceName>BuffModHealCopyConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModHealCopyConfig& buffmodhealcopyconfig() const;
  inline ::pb::BuffModHealCopyConfig* mutable_buffmodhealcopyconfig();
  inline ::pb::BuffModHealCopyConfig* release_buffmodhealcopyconfig();
  inline void set_allocated_buffmodhealcopyconfig(::pb::BuffModHealCopyConfig* buffmodhealcopyconfig);

  // optional .pb.BuffModStealHpConfig BuffModStealHpConfig = 21;
  inline bool has_buffmodstealhpconfig() const;
  inline void clear_buffmodstealhpconfig();
  static const int kBuffModStealHpConfigFieldNumber = 21;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodstealhpconfig</name>
  		<replaceName>BuffModStealHpConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodstealhpconfig</name>
  		<replaceName>BuffModStealHpConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodstealhpconfig</name>
  		<replaceName>BuffModStealHpConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodstealhpconfig</name>
  		<replaceName>BuffModStealHpConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModStealHpConfig& buffmodstealhpconfig() const;
  inline ::pb::BuffModStealHpConfig* mutable_buffmodstealhpconfig();
  inline ::pb::BuffModStealHpConfig* release_buffmodstealhpconfig();
  inline void set_allocated_buffmodstealhpconfig(::pb::BuffModStealHpConfig* buffmodstealhpconfig);

  // optional .pb.BuffModSkillImmunityConfig BuffModSkillImmunityConfig = 34;
  inline bool has_buffmodskillimmunityconfig() const;
  inline void clear_buffmodskillimmunityconfig();
  static const int kBuffModSkillImmunityConfigFieldNumber = 34;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodskillimmunityconfig</name>
  		<replaceName>BuffModSkillImmunityConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodskillimmunityconfig</name>
  		<replaceName>BuffModSkillImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodskillimmunityconfig</name>
  		<replaceName>BuffModSkillImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodskillimmunityconfig</name>
  		<replaceName>BuffModSkillImmunityConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModSkillImmunityConfig& buffmodskillimmunityconfig() const;
  inline ::pb::BuffModSkillImmunityConfig* mutable_buffmodskillimmunityconfig();
  inline ::pb::BuffModSkillImmunityConfig* release_buffmodskillimmunityconfig();
  inline void set_allocated_buffmodskillimmunityconfig(::pb::BuffModSkillImmunityConfig* buffmodskillimmunityconfig);

  // optional .pb.BuffModToughnessConfig BuffModToughnessConfig = 35;
  inline bool has_buffmodtoughnessconfig() const;
  inline void clear_buffmodtoughnessconfig();
  static const int kBuffModToughnessConfigFieldNumber = 35;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtoughnessconfig</name>
  		<replaceName>BuffModToughnessConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtoughnessconfig</name>
  		<replaceName>BuffModToughnessConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtoughnessconfig</name>
  		<replaceName>BuffModToughnessConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtoughnessconfig</name>
  		<replaceName>BuffModToughnessConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModToughnessConfig& buffmodtoughnessconfig() const;
  inline ::pb::BuffModToughnessConfig* mutable_buffmodtoughnessconfig();
  inline ::pb::BuffModToughnessConfig* release_buffmodtoughnessconfig();
  inline void set_allocated_buffmodtoughnessconfig(::pb::BuffModToughnessConfig* buffmodtoughnessconfig);

  // optional .pb.BuffModDispelConfig BuffModDispelConfig = 33;
  inline bool has_buffmoddispelconfig() const;
  inline void clear_buffmoddispelconfig();
  static const int kBuffModDispelConfigFieldNumber = 33;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddispelconfig</name>
  		<replaceName>BuffModDispelConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddispelconfig</name>
  		<replaceName>BuffModDispelConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddispelconfig</name>
  		<replaceName>BuffModDispelConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddispelconfig</name>
  		<replaceName>BuffModDispelConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDispelConfig& buffmoddispelconfig() const;
  inline ::pb::BuffModDispelConfig* mutable_buffmoddispelconfig();
  inline ::pb::BuffModDispelConfig* release_buffmoddispelconfig();
  inline void set_allocated_buffmoddispelconfig(::pb::BuffModDispelConfig* buffmoddispelconfig);

  // optional .pb.BuffModDamageImmunityConfig BuffModDamageImmunityConfig = 41;
  inline bool has_buffmoddamageimmunityconfig() const;
  inline void clear_buffmoddamageimmunityconfig();
  static const int kBuffModDamageImmunityConfigFieldNumber = 41;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddamageimmunityconfig</name>
  		<replaceName>BuffModDamageImmunityConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddamageimmunityconfig</name>
  		<replaceName>BuffModDamageImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddamageimmunityconfig</name>
  		<replaceName>BuffModDamageImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddamageimmunityconfig</name>
  		<replaceName>BuffModDamageImmunityConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDamageImmunityConfig& buffmoddamageimmunityconfig() const;
  inline ::pb::BuffModDamageImmunityConfig* mutable_buffmoddamageimmunityconfig();
  inline ::pb::BuffModDamageImmunityConfig* release_buffmoddamageimmunityconfig();
  inline void set_allocated_buffmoddamageimmunityconfig(::pb::BuffModDamageImmunityConfig* buffmoddamageimmunityconfig);

  // optional .pb.BuffModHitActionImmunityConfig BuffModHitActionImmunityConfig = 40;
  inline bool has_buffmodhitactionimmunityconfig() const;
  inline void clear_buffmodhitactionimmunityconfig();
  static const int kBuffModHitActionImmunityConfigFieldNumber = 40;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodhitactionimmunityconfig</name>
  		<replaceName>BuffModHitActionImmunityConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodhitactionimmunityconfig</name>
  		<replaceName>BuffModHitActionImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodhitactionimmunityconfig</name>
  		<replaceName>BuffModHitActionImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodhitactionimmunityconfig</name>
  		<replaceName>BuffModHitActionImmunityConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModHitActionImmunityConfig& buffmodhitactionimmunityconfig() const;
  inline ::pb::BuffModHitActionImmunityConfig* mutable_buffmodhitactionimmunityconfig();
  inline ::pb::BuffModHitActionImmunityConfig* release_buffmodhitactionimmunityconfig();
  inline void set_allocated_buffmodhitactionimmunityconfig(::pb::BuffModHitActionImmunityConfig* buffmodhitactionimmunityconfig);

  // optional .pb.BuffModArmAttrAddConfig BuffModArmAttrAddConfig = 42;
  inline bool has_buffmodarmattraddconfig() const;
  inline void clear_buffmodarmattraddconfig();
  static const int kBuffModArmAttrAddConfigFieldNumber = 42;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodarmattraddconfig</name>
  		<replaceName>BuffModArmAttrAddConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodarmattraddconfig</name>
  		<replaceName>BuffModArmAttrAddConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodarmattraddconfig</name>
  		<replaceName>BuffModArmAttrAddConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodarmattraddconfig</name>
  		<replaceName>BuffModArmAttrAddConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModArmAttrAddConfig& buffmodarmattraddconfig() const;
  inline ::pb::BuffModArmAttrAddConfig* mutable_buffmodarmattraddconfig();
  inline ::pb::BuffModArmAttrAddConfig* release_buffmodarmattraddconfig();
  inline void set_allocated_buffmodarmattraddconfig(::pb::BuffModArmAttrAddConfig* buffmodarmattraddconfig);

  // optional .pb.BuffModSkillOnLowLifeConfig BuffModSkillOnLowLifeConfig = 43;
  inline bool has_buffmodskillonlowlifeconfig() const;
  inline void clear_buffmodskillonlowlifeconfig();
  static const int kBuffModSkillOnLowLifeConfigFieldNumber = 43;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodskillonlowlifeconfig</name>
  		<replaceName>BuffModSkillOnLowLifeConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodskillonlowlifeconfig</name>
  		<replaceName>BuffModSkillOnLowLifeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodskillonlowlifeconfig</name>
  		<replaceName>BuffModSkillOnLowLifeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodskillonlowlifeconfig</name>
  		<replaceName>BuffModSkillOnLowLifeConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModSkillOnLowLifeConfig& buffmodskillonlowlifeconfig() const;
  inline ::pb::BuffModSkillOnLowLifeConfig* mutable_buffmodskillonlowlifeconfig();
  inline ::pb::BuffModSkillOnLowLifeConfig* release_buffmodskillonlowlifeconfig();
  inline void set_allocated_buffmodskillonlowlifeconfig(::pb::BuffModSkillOnLowLifeConfig* buffmodskillonlowlifeconfig);

  // optional .pb.BuffModMoveControlImmunityConfig BuffModMoveControlImmunityConfig = 50;
  inline bool has_buffmodmovecontrolimmunityconfig() const;
  inline void clear_buffmodmovecontrolimmunityconfig();
  static const int kBuffModMoveControlImmunityConfigFieldNumber = 50;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodmovecontrolimmunityconfig</name>
  		<replaceName>BuffModMoveControlImmunityConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodmovecontrolimmunityconfig</name>
  		<replaceName>BuffModMoveControlImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodmovecontrolimmunityconfig</name>
  		<replaceName>BuffModMoveControlImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodmovecontrolimmunityconfig</name>
  		<replaceName>BuffModMoveControlImmunityConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModMoveControlImmunityConfig& buffmodmovecontrolimmunityconfig() const;
  inline ::pb::BuffModMoveControlImmunityConfig* mutable_buffmodmovecontrolimmunityconfig();
  inline ::pb::BuffModMoveControlImmunityConfig* release_buffmodmovecontrolimmunityconfig();
  inline void set_allocated_buffmodmovecontrolimmunityconfig(::pb::BuffModMoveControlImmunityConfig* buffmodmovecontrolimmunityconfig);

  // optional .pb.BuffModConditionChangeConfig BuffModConditionChangeConfig = 52;
  inline bool has_buffmodconditionchangeconfig() const;
  inline void clear_buffmodconditionchangeconfig();
  static const int kBuffModConditionChangeConfigFieldNumber = 52;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodconditionchangeconfig</name>
  		<replaceName>BuffModConditionChangeConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodconditionchangeconfig</name>
  		<replaceName>BuffModConditionChangeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodconditionchangeconfig</name>
  		<replaceName>BuffModConditionChangeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodconditionchangeconfig</name>
  		<replaceName>BuffModConditionChangeConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModConditionChangeConfig& buffmodconditionchangeconfig() const;
  inline ::pb::BuffModConditionChangeConfig* mutable_buffmodconditionchangeconfig();
  inline ::pb::BuffModConditionChangeConfig* release_buffmodconditionchangeconfig();
  inline void set_allocated_buffmodconditionchangeconfig(::pb::BuffModConditionChangeConfig* buffmodconditionchangeconfig);

  // optional .pb.BuffModPropertyDecConfig BuffModPropertyDecConfig = 55;
  inline bool has_buffmodpropertydecconfig() const;
  inline void clear_buffmodpropertydecconfig();
  static const int kBuffModPropertyDecConfigFieldNumber = 55;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodpropertydecconfig</name>
  		<replaceName>BuffModPropertyDecConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodpropertydecconfig</name>
  		<replaceName>BuffModPropertyDecConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodpropertydecconfig</name>
  		<replaceName>BuffModPropertyDecConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodpropertydecconfig</name>
  		<replaceName>BuffModPropertyDecConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModPropertyDecConfig& buffmodpropertydecconfig() const;
  inline ::pb::BuffModPropertyDecConfig* mutable_buffmodpropertydecconfig();
  inline ::pb::BuffModPropertyDecConfig* release_buffmodpropertydecconfig();
  inline void set_allocated_buffmodpropertydecconfig(::pb::BuffModPropertyDecConfig* buffmodpropertydecconfig);

  // optional .pb.BuffModChangeDmgByBuffSubConfig BuffModChangeDmgByBuffSubConfig = 56;
  inline bool has_buffmodchangedmgbybuffsubconfig() const;
  inline void clear_buffmodchangedmgbybuffsubconfig();
  static const int kBuffModChangeDmgByBuffSubConfigFieldNumber = 56;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodchangedmgbybuffsubconfig</name>
  		<replaceName>BuffModChangeDmgByBuffSubConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodchangedmgbybuffsubconfig</name>
  		<replaceName>BuffModChangeDmgByBuffSubConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodchangedmgbybuffsubconfig</name>
  		<replaceName>BuffModChangeDmgByBuffSubConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodchangedmgbybuffsubconfig</name>
  		<replaceName>BuffModChangeDmgByBuffSubConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModChangeDmgByBuffSubConfig& buffmodchangedmgbybuffsubconfig() const;
  inline ::pb::BuffModChangeDmgByBuffSubConfig* mutable_buffmodchangedmgbybuffsubconfig();
  inline ::pb::BuffModChangeDmgByBuffSubConfig* release_buffmodchangedmgbybuffsubconfig();
  inline void set_allocated_buffmodchangedmgbybuffsubconfig(::pb::BuffModChangeDmgByBuffSubConfig* buffmodchangedmgbybuffsubconfig);

  // optional .pb.BuffModShrinkControlDurationConfig BuffModShrinkControlDurationConfig = 62;
  inline bool has_buffmodshrinkcontroldurationconfig() const;
  inline void clear_buffmodshrinkcontroldurationconfig();
  static const int kBuffModShrinkControlDurationConfigFieldNumber = 62;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodshrinkcontroldurationconfig</name>
  		<replaceName>BuffModShrinkControlDurationConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodshrinkcontroldurationconfig</name>
  		<replaceName>BuffModShrinkControlDurationConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodshrinkcontroldurationconfig</name>
  		<replaceName>BuffModShrinkControlDurationConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodshrinkcontroldurationconfig</name>
  		<replaceName>BuffModShrinkControlDurationConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModShrinkControlDurationConfig& buffmodshrinkcontroldurationconfig() const;
  inline ::pb::BuffModShrinkControlDurationConfig* mutable_buffmodshrinkcontroldurationconfig();
  inline ::pb::BuffModShrinkControlDurationConfig* release_buffmodshrinkcontroldurationconfig();
  inline void set_allocated_buffmodshrinkcontroldurationconfig(::pb::BuffModShrinkControlDurationConfig* buffmodshrinkcontroldurationconfig);

  // optional .pb.BuffModUnlimitedShieldConfig BuffModUnlimitedShieldConfig = 64;
  inline bool has_buffmodunlimitedshieldconfig() const;
  inline void clear_buffmodunlimitedshieldconfig();
  static const int kBuffModUnlimitedShieldConfigFieldNumber = 64;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodunlimitedshieldconfig</name>
  		<replaceName>BuffModUnlimitedShieldConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodunlimitedshieldconfig</name>
  		<replaceName>BuffModUnlimitedShieldConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodunlimitedshieldconfig</name>
  		<replaceName>BuffModUnlimitedShieldConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodunlimitedshieldconfig</name>
  		<replaceName>BuffModUnlimitedShieldConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModUnlimitedShieldConfig& buffmodunlimitedshieldconfig() const;
  inline ::pb::BuffModUnlimitedShieldConfig* mutable_buffmodunlimitedshieldconfig();
  inline ::pb::BuffModUnlimitedShieldConfig* release_buffmodunlimitedshieldconfig();
  inline void set_allocated_buffmodunlimitedshieldconfig(::pb::BuffModUnlimitedShieldConfig* buffmodunlimitedshieldconfig);

  // optional .pb.BuffModReflectBuffConfig BuffModReflectBuffConfig = 65;
  inline bool has_buffmodreflectbuffconfig() const;
  inline void clear_buffmodreflectbuffconfig();
  static const int kBuffModReflectBuffConfigFieldNumber = 65;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodreflectbuffconfig</name>
  		<replaceName>BuffModReflectBuffConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodreflectbuffconfig</name>
  		<replaceName>BuffModReflectBuffConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodreflectbuffconfig</name>
  		<replaceName>BuffModReflectBuffConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodreflectbuffconfig</name>
  		<replaceName>BuffModReflectBuffConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModReflectBuffConfig& buffmodreflectbuffconfig() const;
  inline ::pb::BuffModReflectBuffConfig* mutable_buffmodreflectbuffconfig();
  inline ::pb::BuffModReflectBuffConfig* release_buffmodreflectbuffconfig();
  inline void set_allocated_buffmodreflectbuffconfig(::pb::BuffModReflectBuffConfig* buffmodreflectbuffconfig);

  // optional .pb.BuffModFatalDmgShiftConfig BuffModFatalDmgShiftConfig = 66;
  inline bool has_buffmodfataldmgshiftconfig() const;
  inline void clear_buffmodfataldmgshiftconfig();
  static const int kBuffModFatalDmgShiftConfigFieldNumber = 66;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodfataldmgshiftconfig</name>
  		<replaceName>BuffModFatalDmgShiftConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodfataldmgshiftconfig</name>
  		<replaceName>BuffModFatalDmgShiftConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodfataldmgshiftconfig</name>
  		<replaceName>BuffModFatalDmgShiftConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodfataldmgshiftconfig</name>
  		<replaceName>BuffModFatalDmgShiftConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModFatalDmgShiftConfig& buffmodfataldmgshiftconfig() const;
  inline ::pb::BuffModFatalDmgShiftConfig* mutable_buffmodfataldmgshiftconfig();
  inline ::pb::BuffModFatalDmgShiftConfig* release_buffmodfataldmgshiftconfig();
  inline void set_allocated_buffmodfataldmgshiftconfig(::pb::BuffModFatalDmgShiftConfig* buffmodfataldmgshiftconfig);

  // optional .pb.BuffModRageImmunityConfig BuffModRageImmunityConfig = 68;
  inline bool has_buffmodrageimmunityconfig() const;
  inline void clear_buffmodrageimmunityconfig();
  static const int kBuffModRageImmunityConfigFieldNumber = 68;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodrageimmunityconfig</name>
  		<replaceName>BuffModRageImmunityConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodrageimmunityconfig</name>
  		<replaceName>BuffModRageImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodrageimmunityconfig</name>
  		<replaceName>BuffModRageImmunityConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodrageimmunityconfig</name>
  		<replaceName>BuffModRageImmunityConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRageImmunityConfig& buffmodrageimmunityconfig() const;
  inline ::pb::BuffModRageImmunityConfig* mutable_buffmodrageimmunityconfig();
  inline ::pb::BuffModRageImmunityConfig* release_buffmodrageimmunityconfig();
  inline void set_allocated_buffmodrageimmunityconfig(::pb::BuffModRageImmunityConfig* buffmodrageimmunityconfig);

  // optional .pb.BuffModIgnoreShieldConfig BuffModIgnoreShieldConfig = 74;
  inline bool has_buffmodignoreshieldconfig() const;
  inline void clear_buffmodignoreshieldconfig();
  static const int kBuffModIgnoreShieldConfigFieldNumber = 74;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodignoreshieldconfig</name>
  		<replaceName>BuffModIgnoreShieldConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodignoreshieldconfig</name>
  		<replaceName>BuffModIgnoreShieldConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodignoreshieldconfig</name>
  		<replaceName>BuffModIgnoreShieldConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodignoreshieldconfig</name>
  		<replaceName>BuffModIgnoreShieldConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModIgnoreShieldConfig& buffmodignoreshieldconfig() const;
  inline ::pb::BuffModIgnoreShieldConfig* mutable_buffmodignoreshieldconfig();
  inline ::pb::BuffModIgnoreShieldConfig* release_buffmodignoreshieldconfig();
  inline void set_allocated_buffmodignoreshieldconfig(::pb::BuffModIgnoreShieldConfig* buffmodignoreshieldconfig);

  // optional .pb.BuffModRevertStateOnEndConfig BuffModRevertStateOnEndConfig = 77;
  inline bool has_buffmodrevertstateonendconfig() const;
  inline void clear_buffmodrevertstateonendconfig();
  static const int kBuffModRevertStateOnEndConfigFieldNumber = 77;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodrevertstateonendconfig</name>
  		<replaceName>BuffModRevertStateOnEndConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodrevertstateonendconfig</name>
  		<replaceName>BuffModRevertStateOnEndConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodrevertstateonendconfig</name>
  		<replaceName>BuffModRevertStateOnEndConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodrevertstateonendconfig</name>
  		<replaceName>BuffModRevertStateOnEndConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRevertStateOnEndConfig& buffmodrevertstateonendconfig() const;
  inline ::pb::BuffModRevertStateOnEndConfig* mutable_buffmodrevertstateonendconfig();
  inline ::pb::BuffModRevertStateOnEndConfig* release_buffmodrevertstateonendconfig();
  inline void set_allocated_buffmodrevertstateonendconfig(::pb::BuffModRevertStateOnEndConfig* buffmodrevertstateonendconfig);

  // optional .pb.BuffModChangeCastRangeConfig BuffModChangeCastRangeConfig = 78;
  inline bool has_buffmodchangecastrangeconfig() const;
  inline void clear_buffmodchangecastrangeconfig();
  static const int kBuffModChangeCastRangeConfigFieldNumber = 78;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodchangecastrangeconfig</name>
  		<replaceName>BuffModChangeCastRangeConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodchangecastrangeconfig</name>
  		<replaceName>BuffModChangeCastRangeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodchangecastrangeconfig</name>
  		<replaceName>BuffModChangeCastRangeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodchangecastrangeconfig</name>
  		<replaceName>BuffModChangeCastRangeConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModChangeCastRangeConfig& buffmodchangecastrangeconfig() const;
  inline ::pb::BuffModChangeCastRangeConfig* mutable_buffmodchangecastrangeconfig();
  inline ::pb::BuffModChangeCastRangeConfig* release_buffmodchangecastrangeconfig();
  inline void set_allocated_buffmodchangecastrangeconfig(::pb::BuffModChangeCastRangeConfig* buffmodchangecastrangeconfig);

  // optional .pb.BuffModSetMaxLoseHPConfig BuffModSetMaxLoseHPConfig = 81;
  inline bool has_buffmodsetmaxlosehpconfig() const;
  inline void clear_buffmodsetmaxlosehpconfig();
  static const int kBuffModSetMaxLoseHPConfigFieldNumber = 81;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodsetmaxlosehpconfig</name>
  		<replaceName>BuffModSetMaxLoseHPConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodsetmaxlosehpconfig</name>
  		<replaceName>BuffModSetMaxLoseHPConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodsetmaxlosehpconfig</name>
  		<replaceName>BuffModSetMaxLoseHPConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodsetmaxlosehpconfig</name>
  		<replaceName>BuffModSetMaxLoseHPConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModSetMaxLoseHPConfig& buffmodsetmaxlosehpconfig() const;
  inline ::pb::BuffModSetMaxLoseHPConfig* mutable_buffmodsetmaxlosehpconfig();
  inline ::pb::BuffModSetMaxLoseHPConfig* release_buffmodsetmaxlosehpconfig();
  inline void set_allocated_buffmodsetmaxlosehpconfig(::pb::BuffModSetMaxLoseHPConfig* buffmodsetmaxlosehpconfig);

  // optional .pb.BuffModAdjustReflectedDamageConfig BuffModAdjustReflectedDamageConfig = 82;
  inline bool has_buffmodadjustreflecteddamageconfig() const;
  inline void clear_buffmodadjustreflecteddamageconfig();
  static const int kBuffModAdjustReflectedDamageConfigFieldNumber = 82;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodadjustreflecteddamageconfig</name>
  		<replaceName>BuffModAdjustReflectedDamageConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodadjustreflecteddamageconfig</name>
  		<replaceName>BuffModAdjustReflectedDamageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodadjustreflecteddamageconfig</name>
  		<replaceName>BuffModAdjustReflectedDamageConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodadjustreflecteddamageconfig</name>
  		<replaceName>BuffModAdjustReflectedDamageConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModAdjustReflectedDamageConfig& buffmodadjustreflecteddamageconfig() const;
  inline ::pb::BuffModAdjustReflectedDamageConfig* mutable_buffmodadjustreflecteddamageconfig();
  inline ::pb::BuffModAdjustReflectedDamageConfig* release_buffmodadjustreflecteddamageconfig();
  inline void set_allocated_buffmodadjustreflecteddamageconfig(::pb::BuffModAdjustReflectedDamageConfig* buffmodadjustreflecteddamageconfig);

  // optional .pb.BuffModActiveUIEffectConfig BuffModActiveUIEffectConfig = 83;
  inline bool has_buffmodactiveuieffectconfig() const;
  inline void clear_buffmodactiveuieffectconfig();
  static const int kBuffModActiveUIEffectConfigFieldNumber = 83;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodactiveuieffectconfig</name>
  		<replaceName>BuffModActiveUIEffectConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodactiveuieffectconfig</name>
  		<replaceName>BuffModActiveUIEffectConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodactiveuieffectconfig</name>
  		<replaceName>BuffModActiveUIEffectConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodactiveuieffectconfig</name>
  		<replaceName>BuffModActiveUIEffectConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModActiveUIEffectConfig& buffmodactiveuieffectconfig() const;
  inline ::pb::BuffModActiveUIEffectConfig* mutable_buffmodactiveuieffectconfig();
  inline ::pb::BuffModActiveUIEffectConfig* release_buffmodactiveuieffectconfig();
  inline void set_allocated_buffmodactiveuieffectconfig(::pb::BuffModActiveUIEffectConfig* buffmodactiveuieffectconfig);

  // optional .pb.BuffModAdjustBuffHitRateConfig BuffModAdjustBuffHitRateConfig = 84;
  inline bool has_buffmodadjustbuffhitrateconfig() const;
  inline void clear_buffmodadjustbuffhitrateconfig();
  static const int kBuffModAdjustBuffHitRateConfigFieldNumber = 84;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodadjustbuffhitrateconfig</name>
  		<replaceName>BuffModAdjustBuffHitRateConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodadjustbuffhitrateconfig</name>
  		<replaceName>BuffModAdjustBuffHitRateConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodadjustbuffhitrateconfig</name>
  		<replaceName>BuffModAdjustBuffHitRateConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodadjustbuffhitrateconfig</name>
  		<replaceName>BuffModAdjustBuffHitRateConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModAdjustBuffHitRateConfig& buffmodadjustbuffhitrateconfig() const;
  inline ::pb::BuffModAdjustBuffHitRateConfig* mutable_buffmodadjustbuffhitrateconfig();
  inline ::pb::BuffModAdjustBuffHitRateConfig* release_buffmodadjustbuffhitrateconfig();
  inline void set_allocated_buffmodadjustbuffhitrateconfig(::pb::BuffModAdjustBuffHitRateConfig* buffmodadjustbuffhitrateconfig);

  // optional .pb.BuffModLimitByMaxHpRateConfig BuffModLimitByMaxHpRateConfig = 85;
  inline bool has_buffmodlimitbymaxhprateconfig() const;
  inline void clear_buffmodlimitbymaxhprateconfig();
  static const int kBuffModLimitByMaxHpRateConfigFieldNumber = 85;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodlimitbymaxhprateconfig</name>
  		<replaceName>BuffModLimitByMaxHpRateConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodlimitbymaxhprateconfig</name>
  		<replaceName>BuffModLimitByMaxHpRateConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodlimitbymaxhprateconfig</name>
  		<replaceName>BuffModLimitByMaxHpRateConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodlimitbymaxhprateconfig</name>
  		<replaceName>BuffModLimitByMaxHpRateConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModLimitByMaxHpRateConfig& buffmodlimitbymaxhprateconfig() const;
  inline ::pb::BuffModLimitByMaxHpRateConfig* mutable_buffmodlimitbymaxhprateconfig();
  inline ::pb::BuffModLimitByMaxHpRateConfig* release_buffmodlimitbymaxhprateconfig();
  inline void set_allocated_buffmodlimitbymaxhprateconfig(::pb::BuffModLimitByMaxHpRateConfig* buffmodlimitbymaxhprateconfig);

  // optional .pb.BuffModBattleArcherModifyConfig BuffModBattleArcherModifyConfig = 86;
  inline bool has_buffmodbattlearchermodifyconfig() const;
  inline void clear_buffmodbattlearchermodifyconfig();
  static const int kBuffModBattleArcherModifyConfigFieldNumber = 86;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodbattlearchermodifyconfig</name>
  		<replaceName>BuffModBattleArcherModifyConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodbattlearchermodifyconfig</name>
  		<replaceName>BuffModBattleArcherModifyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodbattlearchermodifyconfig</name>
  		<replaceName>BuffModBattleArcherModifyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodbattlearchermodifyconfig</name>
  		<replaceName>BuffModBattleArcherModifyConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModBattleArcherModifyConfig& buffmodbattlearchermodifyconfig() const;
  inline ::pb::BuffModBattleArcherModifyConfig* mutable_buffmodbattlearchermodifyconfig();
  inline ::pb::BuffModBattleArcherModifyConfig* release_buffmodbattlearchermodifyconfig();
  inline void set_allocated_buffmodbattlearchermodifyconfig(::pb::BuffModBattleArcherModifyConfig* buffmodbattlearchermodifyconfig);

  // optional .pb.BuffModNoMoveConfig BuffModNoMoveConfig = 7;
  inline bool has_buffmodnomoveconfig() const;
  inline void clear_buffmodnomoveconfig();
  static const int kBuffModNoMoveConfigFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnomoveconfig</name>
  		<replaceName>BuffModNoMoveConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnomoveconfig</name>
  		<replaceName>BuffModNoMoveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnomoveconfig</name>
  		<replaceName>BuffModNoMoveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnomoveconfig</name>
  		<replaceName>BuffModNoMoveConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNoMoveConfig& buffmodnomoveconfig() const;
  inline ::pb::BuffModNoMoveConfig* mutable_buffmodnomoveconfig();
  inline ::pb::BuffModNoMoveConfig* release_buffmodnomoveconfig();
  inline void set_allocated_buffmodnomoveconfig(::pb::BuffModNoMoveConfig* buffmodnomoveconfig);

  // optional .pb.BuffModNoNormalSkillConfig BuffModNoNormalSkillConfig = 8;
  inline bool has_buffmodnonormalskillconfig() const;
  inline void clear_buffmodnonormalskillconfig();
  static const int kBuffModNoNormalSkillConfigFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnonormalskillconfig</name>
  		<replaceName>BuffModNoNormalSkillConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnonormalskillconfig</name>
  		<replaceName>BuffModNoNormalSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnonormalskillconfig</name>
  		<replaceName>BuffModNoNormalSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnonormalskillconfig</name>
  		<replaceName>BuffModNoNormalSkillConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNoNormalSkillConfig& buffmodnonormalskillconfig() const;
  inline ::pb::BuffModNoNormalSkillConfig* mutable_buffmodnonormalskillconfig();
  inline ::pb::BuffModNoNormalSkillConfig* release_buffmodnonormalskillconfig();
  inline void set_allocated_buffmodnonormalskillconfig(::pb::BuffModNoNormalSkillConfig* buffmodnonormalskillconfig);

  // optional .pb.BuffModNoSkillConfig BuffModNoSkillConfig = 9;
  inline bool has_buffmodnoskillconfig() const;
  inline void clear_buffmodnoskillconfig();
  static const int kBuffModNoSkillConfigFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnoskillconfig</name>
  		<replaceName>BuffModNoSkillConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnoskillconfig</name>
  		<replaceName>BuffModNoSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnoskillconfig</name>
  		<replaceName>BuffModNoSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnoskillconfig</name>
  		<replaceName>BuffModNoSkillConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNoSkillConfig& buffmodnoskillconfig() const;
  inline ::pb::BuffModNoSkillConfig* mutable_buffmodnoskillconfig();
  inline ::pb::BuffModNoSkillConfig* release_buffmodnoskillconfig();
  inline void set_allocated_buffmodnoskillconfig(::pb::BuffModNoSkillConfig* buffmodnoskillconfig);

  // optional .pb.BuffModDizzinessConfig BuffModDizzinessConfig = 10;
  inline bool has_buffmoddizzinessconfig() const;
  inline void clear_buffmoddizzinessconfig();
  static const int kBuffModDizzinessConfigFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddizzinessconfig</name>
  		<replaceName>BuffModDizzinessConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddizzinessconfig</name>
  		<replaceName>BuffModDizzinessConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddizzinessconfig</name>
  		<replaceName>BuffModDizzinessConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddizzinessconfig</name>
  		<replaceName>BuffModDizzinessConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDizzinessConfig& buffmoddizzinessconfig() const;
  inline ::pb::BuffModDizzinessConfig* mutable_buffmoddizzinessconfig();
  inline ::pb::BuffModDizzinessConfig* release_buffmoddizzinessconfig();
  inline void set_allocated_buffmoddizzinessconfig(::pb::BuffModDizzinessConfig* buffmoddizzinessconfig);

  // optional .pb.BuffModFreezeConfig BuffModFreezeConfig = 11;
  inline bool has_buffmodfreezeconfig() const;
  inline void clear_buffmodfreezeconfig();
  static const int kBuffModFreezeConfigFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodfreezeconfig</name>
  		<replaceName>BuffModFreezeConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodfreezeconfig</name>
  		<replaceName>BuffModFreezeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodfreezeconfig</name>
  		<replaceName>BuffModFreezeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodfreezeconfig</name>
  		<replaceName>BuffModFreezeConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModFreezeConfig& buffmodfreezeconfig() const;
  inline ::pb::BuffModFreezeConfig* mutable_buffmodfreezeconfig();
  inline ::pb::BuffModFreezeConfig* release_buffmodfreezeconfig();
  inline void set_allocated_buffmodfreezeconfig(::pb::BuffModFreezeConfig* buffmodfreezeconfig);

  // optional .pb.BuffModCharmedConfig BuffModCharmedConfig = 31;
  inline bool has_buffmodcharmedconfig() const;
  inline void clear_buffmodcharmedconfig();
  static const int kBuffModCharmedConfigFieldNumber = 31;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodcharmedconfig</name>
  		<replaceName>BuffModCharmedConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodcharmedconfig</name>
  		<replaceName>BuffModCharmedConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodcharmedconfig</name>
  		<replaceName>BuffModCharmedConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodcharmedconfig</name>
  		<replaceName>BuffModCharmedConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModCharmedConfig& buffmodcharmedconfig() const;
  inline ::pb::BuffModCharmedConfig* mutable_buffmodcharmedconfig();
  inline ::pb::BuffModCharmedConfig* release_buffmodcharmedconfig();
  inline void set_allocated_buffmodcharmedconfig(::pb::BuffModCharmedConfig* buffmodcharmedconfig);

  // optional .pb.BuffModChaosConfig BuffModChaosConfig = 32;
  inline bool has_buffmodchaosconfig() const;
  inline void clear_buffmodchaosconfig();
  static const int kBuffModChaosConfigFieldNumber = 32;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodchaosconfig</name>
  		<replaceName>BuffModChaosConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodchaosconfig</name>
  		<replaceName>BuffModChaosConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodchaosconfig</name>
  		<replaceName>BuffModChaosConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodchaosconfig</name>
  		<replaceName>BuffModChaosConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModChaosConfig& buffmodchaosconfig() const;
  inline ::pb::BuffModChaosConfig* mutable_buffmodchaosconfig();
  inline ::pb::BuffModChaosConfig* release_buffmodchaosconfig();
  inline void set_allocated_buffmodchaosconfig(::pb::BuffModChaosConfig* buffmodchaosconfig);

  // optional .pb.BuffModRandomMoveConfig BuffModRandomMoveConfig = 12;
  inline bool has_buffmodrandommoveconfig() const;
  inline void clear_buffmodrandommoveconfig();
  static const int kBuffModRandomMoveConfigFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodrandommoveconfig</name>
  		<replaceName>BuffModRandomMoveConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodrandommoveconfig</name>
  		<replaceName>BuffModRandomMoveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodrandommoveconfig</name>
  		<replaceName>BuffModRandomMoveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodrandommoveconfig</name>
  		<replaceName>BuffModRandomMoveConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRandomMoveConfig& buffmodrandommoveconfig() const;
  inline ::pb::BuffModRandomMoveConfig* mutable_buffmodrandommoveconfig();
  inline ::pb::BuffModRandomMoveConfig* release_buffmodrandommoveconfig();
  inline void set_allocated_buffmodrandommoveconfig(::pb::BuffModRandomMoveConfig* buffmodrandommoveconfig);

  // optional .pb.BuffModDamageCopyConfig BuffModDamageCopyConfig = 25;
  inline bool has_buffmoddamagecopyconfig() const;
  inline void clear_buffmoddamagecopyconfig();
  static const int kBuffModDamageCopyConfigFieldNumber = 25;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddamagecopyconfig</name>
  		<replaceName>BuffModDamageCopyConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddamagecopyconfig</name>
  		<replaceName>BuffModDamageCopyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddamagecopyconfig</name>
  		<replaceName>BuffModDamageCopyConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddamagecopyconfig</name>
  		<replaceName>BuffModDamageCopyConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDamageCopyConfig& buffmoddamagecopyconfig() const;
  inline ::pb::BuffModDamageCopyConfig* mutable_buffmoddamagecopyconfig();
  inline ::pb::BuffModDamageCopyConfig* release_buffmoddamagecopyconfig();
  inline void set_allocated_buffmoddamagecopyconfig(::pb::BuffModDamageCopyConfig* buffmoddamagecopyconfig);

  // optional .pb.BuffModTauntConfig BuffModTauntConfig = 30;
  inline bool has_buffmodtauntconfig() const;
  inline void clear_buffmodtauntconfig();
  static const int kBuffModTauntConfigFieldNumber = 30;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtauntconfig</name>
  		<replaceName>BuffModTauntConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtauntconfig</name>
  		<replaceName>BuffModTauntConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtauntconfig</name>
  		<replaceName>BuffModTauntConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtauntconfig</name>
  		<replaceName>BuffModTauntConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTauntConfig& buffmodtauntconfig() const;
  inline ::pb::BuffModTauntConfig* mutable_buffmodtauntconfig();
  inline ::pb::BuffModTauntConfig* release_buffmodtauntconfig();
  inline void set_allocated_buffmodtauntconfig(::pb::BuffModTauntConfig* buffmodtauntconfig);

  // optional .pb.BuffModNoRageRecoverConfig BuffModNoRageRecoverConfig = 53;
  inline bool has_buffmodnoragerecoverconfig() const;
  inline void clear_buffmodnoragerecoverconfig();
  static const int kBuffModNoRageRecoverConfigFieldNumber = 53;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnoragerecoverconfig</name>
  		<replaceName>BuffModNoRageRecoverConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnoragerecoverconfig</name>
  		<replaceName>BuffModNoRageRecoverConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnoragerecoverconfig</name>
  		<replaceName>BuffModNoRageRecoverConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnoragerecoverconfig</name>
  		<replaceName>BuffModNoRageRecoverConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNoRageRecoverConfig& buffmodnoragerecoverconfig() const;
  inline ::pb::BuffModNoRageRecoverConfig* mutable_buffmodnoragerecoverconfig();
  inline ::pb::BuffModNoRageRecoverConfig* release_buffmodnoragerecoverconfig();
  inline void set_allocated_buffmodnoragerecoverconfig(::pb::BuffModNoRageRecoverConfig* buffmodnoragerecoverconfig);

  // optional .pb.BuffModDisableConfig BuffModDisableConfig = 57;
  inline bool has_buffmoddisableconfig() const;
  inline void clear_buffmoddisableconfig();
  static const int kBuffModDisableConfigFieldNumber = 57;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddisableconfig</name>
  		<replaceName>BuffModDisableConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddisableconfig</name>
  		<replaceName>BuffModDisableConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddisableconfig</name>
  		<replaceName>BuffModDisableConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddisableconfig</name>
  		<replaceName>BuffModDisableConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDisableConfig& buffmoddisableconfig() const;
  inline ::pb::BuffModDisableConfig* mutable_buffmoddisableconfig();
  inline ::pb::BuffModDisableConfig* release_buffmoddisableconfig();
  inline void set_allocated_buffmoddisableconfig(::pb::BuffModDisableConfig* buffmoddisableconfig);

  // optional .pb.BuffModHarmOnMoveConfig BuffModHarmOnMoveConfig = 63;
  inline bool has_buffmodharmonmoveconfig() const;
  inline void clear_buffmodharmonmoveconfig();
  static const int kBuffModHarmOnMoveConfigFieldNumber = 63;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodharmonmoveconfig</name>
  		<replaceName>BuffModHarmOnMoveConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodharmonmoveconfig</name>
  		<replaceName>BuffModHarmOnMoveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodharmonmoveconfig</name>
  		<replaceName>BuffModHarmOnMoveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodharmonmoveconfig</name>
  		<replaceName>BuffModHarmOnMoveConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModHarmOnMoveConfig& buffmodharmonmoveconfig() const;
  inline ::pb::BuffModHarmOnMoveConfig* mutable_buffmodharmonmoveconfig();
  inline ::pb::BuffModHarmOnMoveConfig* release_buffmodharmonmoveconfig();
  inline void set_allocated_buffmodharmonmoveconfig(::pb::BuffModHarmOnMoveConfig* buffmodharmonmoveconfig);

  // optional .pb.BuffModFearConfig BuffModFearConfig = 67;
  inline bool has_buffmodfearconfig() const;
  inline void clear_buffmodfearconfig();
  static const int kBuffModFearConfigFieldNumber = 67;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodfearconfig</name>
  		<replaceName>BuffModFearConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodfearconfig</name>
  		<replaceName>BuffModFearConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodfearconfig</name>
  		<replaceName>BuffModFearConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodfearconfig</name>
  		<replaceName>BuffModFearConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModFearConfig& buffmodfearconfig() const;
  inline ::pb::BuffModFearConfig* mutable_buffmodfearconfig();
  inline ::pb::BuffModFearConfig* release_buffmodfearconfig();
  inline void set_allocated_buffmodfearconfig(::pb::BuffModFearConfig* buffmodfearconfig);

  // optional .pb.BuffModNoSuckBloodConfig BuffModNoSuckBloodConfig = 75;
  inline bool has_buffmodnosuckbloodconfig() const;
  inline void clear_buffmodnosuckbloodconfig();
  static const int kBuffModNoSuckBloodConfigFieldNumber = 75;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnosuckbloodconfig</name>
  		<replaceName>BuffModNoSuckBloodConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnosuckbloodconfig</name>
  		<replaceName>BuffModNoSuckBloodConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnosuckbloodconfig</name>
  		<replaceName>BuffModNoSuckBloodConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnosuckbloodconfig</name>
  		<replaceName>BuffModNoSuckBloodConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNoSuckBloodConfig& buffmodnosuckbloodconfig() const;
  inline ::pb::BuffModNoSuckBloodConfig* mutable_buffmodnosuckbloodconfig();
  inline ::pb::BuffModNoSuckBloodConfig* release_buffmodnosuckbloodconfig();
  inline void set_allocated_buffmodnosuckbloodconfig(::pb::BuffModNoSuckBloodConfig* buffmodnosuckbloodconfig);

  // optional .pb.BuffModNoReviveConfig BuffModNoReviveConfig = 79;
  inline bool has_buffmodnoreviveconfig() const;
  inline void clear_buffmodnoreviveconfig();
  static const int kBuffModNoReviveConfigFieldNumber = 79;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnoreviveconfig</name>
  		<replaceName>BuffModNoReviveConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnoreviveconfig</name>
  		<replaceName>BuffModNoReviveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnoreviveconfig</name>
  		<replaceName>BuffModNoReviveConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnoreviveconfig</name>
  		<replaceName>BuffModNoReviveConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNoReviveConfig& buffmodnoreviveconfig() const;
  inline ::pb::BuffModNoReviveConfig* mutable_buffmodnoreviveconfig();
  inline ::pb::BuffModNoReviveConfig* release_buffmodnoreviveconfig();
  inline void set_allocated_buffmodnoreviveconfig(::pb::BuffModNoReviveConfig* buffmodnoreviveconfig);

  // optional .pb.BuffModTransformationConfig BuffModTransformationConfig = 20;
  inline bool has_buffmodtransformationconfig() const;
  inline void clear_buffmodtransformationconfig();
  static const int kBuffModTransformationConfigFieldNumber = 20;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtransformationconfig</name>
  		<replaceName>BuffModTransformationConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtransformationconfig</name>
  		<replaceName>BuffModTransformationConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtransformationconfig</name>
  		<replaceName>BuffModTransformationConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtransformationconfig</name>
  		<replaceName>BuffModTransformationConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTransformationConfig& buffmodtransformationconfig() const;
  inline ::pb::BuffModTransformationConfig* mutable_buffmodtransformationconfig();
  inline ::pb::BuffModTransformationConfig* release_buffmodtransformationconfig();
  inline void set_allocated_buffmodtransformationconfig(::pb::BuffModTransformationConfig* buffmodtransformationconfig);

  // optional .pb.BuffModNothingConfig BuffModNothingConfig = 4;
  inline bool has_buffmodnothingconfig() const;
  inline void clear_buffmodnothingconfig();
  static const int kBuffModNothingConfigFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodnothingconfig</name>
  		<replaceName>BuffModNothingConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodnothingconfig</name>
  		<replaceName>BuffModNothingConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodnothingconfig</name>
  		<replaceName>BuffModNothingConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodnothingconfig</name>
  		<replaceName>BuffModNothingConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModNothingConfig& buffmodnothingconfig() const;
  inline ::pb::BuffModNothingConfig* mutable_buffmodnothingconfig();
  inline ::pb::BuffModNothingConfig* release_buffmodnothingconfig();
  inline void set_allocated_buffmodnothingconfig(::pb::BuffModNothingConfig* buffmodnothingconfig);

  // optional .pb.BuffModTransformScaleConfig BuffModTransformScaleConfig = 13;
  inline bool has_buffmodtransformscaleconfig() const;
  inline void clear_buffmodtransformscaleconfig();
  static const int kBuffModTransformScaleConfigFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtransformscaleconfig</name>
  		<replaceName>BuffModTransformScaleConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtransformscaleconfig</name>
  		<replaceName>BuffModTransformScaleConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtransformscaleconfig</name>
  		<replaceName>BuffModTransformScaleConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtransformscaleconfig</name>
  		<replaceName>BuffModTransformScaleConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTransformScaleConfig& buffmodtransformscaleconfig() const;
  inline ::pb::BuffModTransformScaleConfig* mutable_buffmodtransformscaleconfig();
  inline ::pb::BuffModTransformScaleConfig* release_buffmodtransformscaleconfig();
  inline void set_allocated_buffmodtransformscaleconfig(::pb::BuffModTransformScaleConfig* buffmodtransformscaleconfig);

  // optional .pb.BuffModDieConfig BuffModDieConfig = 15;
  inline bool has_buffmoddieconfig() const;
  inline void clear_buffmoddieconfig();
  static const int kBuffModDieConfigFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmoddieconfig</name>
  		<replaceName>BuffModDieConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmoddieconfig</name>
  		<replaceName>BuffModDieConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmoddieconfig</name>
  		<replaceName>BuffModDieConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmoddieconfig</name>
  		<replaceName>BuffModDieConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModDieConfig& buffmoddieconfig() const;
  inline ::pb::BuffModDieConfig* mutable_buffmoddieconfig();
  inline ::pb::BuffModDieConfig* release_buffmoddieconfig();
  inline void set_allocated_buffmoddieconfig(::pb::BuffModDieConfig* buffmoddieconfig);

  // optional .pb.BuffModRepeatSkillConfig BuffModRepeatSkillConfig = 23;
  inline bool has_buffmodrepeatskillconfig() const;
  inline void clear_buffmodrepeatskillconfig();
  static const int kBuffModRepeatSkillConfigFieldNumber = 23;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodrepeatskillconfig</name>
  		<replaceName>BuffModRepeatSkillConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodrepeatskillconfig</name>
  		<replaceName>BuffModRepeatSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodrepeatskillconfig</name>
  		<replaceName>BuffModRepeatSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodrepeatskillconfig</name>
  		<replaceName>BuffModRepeatSkillConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRepeatSkillConfig& buffmodrepeatskillconfig() const;
  inline ::pb::BuffModRepeatSkillConfig* mutable_buffmodrepeatskillconfig();
  inline ::pb::BuffModRepeatSkillConfig* release_buffmodrepeatskillconfig();
  inline void set_allocated_buffmodrepeatskillconfig(::pb::BuffModRepeatSkillConfig* buffmodrepeatskillconfig);

  // optional .pb.BuffModSkillOnEndConfig BuffModSkillOnEndConfig = 29;
  inline bool has_buffmodskillonendconfig() const;
  inline void clear_buffmodskillonendconfig();
  static const int kBuffModSkillOnEndConfigFieldNumber = 29;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodskillonendconfig</name>
  		<replaceName>BuffModSkillOnEndConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodskillonendconfig</name>
  		<replaceName>BuffModSkillOnEndConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodskillonendconfig</name>
  		<replaceName>BuffModSkillOnEndConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodskillonendconfig</name>
  		<replaceName>BuffModSkillOnEndConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModSkillOnEndConfig& buffmodskillonendconfig() const;
  inline ::pb::BuffModSkillOnEndConfig* mutable_buffmodskillonendconfig();
  inline ::pb::BuffModSkillOnEndConfig* release_buffmodskillonendconfig();
  inline void set_allocated_buffmodskillonendconfig(::pb::BuffModSkillOnEndConfig* buffmodskillonendconfig);

  // optional .pb.BuffModSpecifySkillTidConfig BuffModSpecifySkillTidConfig = 39;
  inline bool has_buffmodspecifyskilltidconfig() const;
  inline void clear_buffmodspecifyskilltidconfig();
  static const int kBuffModSpecifySkillTidConfigFieldNumber = 39;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodspecifyskilltidconfig</name>
  		<replaceName>BuffModSpecifySkillTidConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodspecifyskilltidconfig</name>
  		<replaceName>BuffModSpecifySkillTidConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodspecifyskilltidconfig</name>
  		<replaceName>BuffModSpecifySkillTidConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodspecifyskilltidconfig</name>
  		<replaceName>BuffModSpecifySkillTidConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModSpecifySkillTidConfig& buffmodspecifyskilltidconfig() const;
  inline ::pb::BuffModSpecifySkillTidConfig* mutable_buffmodspecifyskilltidconfig();
  inline ::pb::BuffModSpecifySkillTidConfig* release_buffmodspecifyskilltidconfig();
  inline void set_allocated_buffmodspecifyskilltidconfig(::pb::BuffModSpecifySkillTidConfig* buffmodspecifyskilltidconfig);

  // optional .pb.BuffModResetBuffTimeConfig BuffModResetBuffTimeConfig = 44;
  inline bool has_buffmodresetbufftimeconfig() const;
  inline void clear_buffmodresetbufftimeconfig();
  static const int kBuffModResetBuffTimeConfigFieldNumber = 44;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodresetbufftimeconfig</name>
  		<replaceName>BuffModResetBuffTimeConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodresetbufftimeconfig</name>
  		<replaceName>BuffModResetBuffTimeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodresetbufftimeconfig</name>
  		<replaceName>BuffModResetBuffTimeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodresetbufftimeconfig</name>
  		<replaceName>BuffModResetBuffTimeConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModResetBuffTimeConfig& buffmodresetbufftimeconfig() const;
  inline ::pb::BuffModResetBuffTimeConfig* mutable_buffmodresetbufftimeconfig();
  inline ::pb::BuffModResetBuffTimeConfig* release_buffmodresetbufftimeconfig();
  inline void set_allocated_buffmodresetbufftimeconfig(::pb::BuffModResetBuffTimeConfig* buffmodresetbufftimeconfig);

  // optional .pb.BuffModAddSkillConfig BuffModAddSkillConfig = 45;
  inline bool has_buffmodaddskillconfig() const;
  inline void clear_buffmodaddskillconfig();
  static const int kBuffModAddSkillConfigFieldNumber = 45;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodaddskillconfig</name>
  		<replaceName>BuffModAddSkillConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodaddskillconfig</name>
  		<replaceName>BuffModAddSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodaddskillconfig</name>
  		<replaceName>BuffModAddSkillConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodaddskillconfig</name>
  		<replaceName>BuffModAddSkillConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModAddSkillConfig& buffmodaddskillconfig() const;
  inline ::pb::BuffModAddSkillConfig* mutable_buffmodaddskillconfig();
  inline ::pb::BuffModAddSkillConfig* release_buffmodaddskillconfig();
  inline void set_allocated_buffmodaddskillconfig(::pb::BuffModAddSkillConfig* buffmodaddskillconfig);

  // optional .pb.BuffModPropertyFormulaConfig BuffModPropertyFormulaConfig = 46;
  inline bool has_buffmodpropertyformulaconfig() const;
  inline void clear_buffmodpropertyformulaconfig();
  static const int kBuffModPropertyFormulaConfigFieldNumber = 46;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodpropertyformulaconfig</name>
  		<replaceName>BuffModPropertyFormulaConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodpropertyformulaconfig</name>
  		<replaceName>BuffModPropertyFormulaConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodpropertyformulaconfig</name>
  		<replaceName>BuffModPropertyFormulaConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodpropertyformulaconfig</name>
  		<replaceName>BuffModPropertyFormulaConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModPropertyFormulaConfig& buffmodpropertyformulaconfig() const;
  inline ::pb::BuffModPropertyFormulaConfig* mutable_buffmodpropertyformulaconfig();
  inline ::pb::BuffModPropertyFormulaConfig* release_buffmodpropertyformulaconfig();
  inline void set_allocated_buffmodpropertyformulaconfig(::pb::BuffModPropertyFormulaConfig* buffmodpropertyformulaconfig);

  // optional .pb.BuffModEffectInRangeConfig BuffModEffectInRangeConfig = 47;
  inline bool has_buffmodeffectinrangeconfig() const;
  inline void clear_buffmodeffectinrangeconfig();
  static const int kBuffModEffectInRangeConfigFieldNumber = 47;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodeffectinrangeconfig</name>
  		<replaceName>BuffModEffectInRangeConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodeffectinrangeconfig</name>
  		<replaceName>BuffModEffectInRangeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodeffectinrangeconfig</name>
  		<replaceName>BuffModEffectInRangeConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodeffectinrangeconfig</name>
  		<replaceName>BuffModEffectInRangeConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModEffectInRangeConfig& buffmodeffectinrangeconfig() const;
  inline ::pb::BuffModEffectInRangeConfig* mutable_buffmodeffectinrangeconfig();
  inline ::pb::BuffModEffectInRangeConfig* release_buffmodeffectinrangeconfig();
  inline void set_allocated_buffmodeffectinrangeconfig(::pb::BuffModEffectInRangeConfig* buffmodeffectinrangeconfig);

  // optional .pb.BuffModRecordDataConfig BuffModRecordDataConfig = 48;
  inline bool has_buffmodrecorddataconfig() const;
  inline void clear_buffmodrecorddataconfig();
  static const int kBuffModRecordDataConfigFieldNumber = 48;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodrecorddataconfig</name>
  		<replaceName>BuffModRecordDataConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodrecorddataconfig</name>
  		<replaceName>BuffModRecordDataConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodrecorddataconfig</name>
  		<replaceName>BuffModRecordDataConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodrecorddataconfig</name>
  		<replaceName>BuffModRecordDataConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRecordDataConfig& buffmodrecorddataconfig() const;
  inline ::pb::BuffModRecordDataConfig* mutable_buffmodrecorddataconfig();
  inline ::pb::BuffModRecordDataConfig* release_buffmodrecorddataconfig();
  inline void set_allocated_buffmodrecorddataconfig(::pb::BuffModRecordDataConfig* buffmodrecorddataconfig);

  // optional .pb.BuffModSkillOnEndConfig BuffModSkillOnEndBConfig = 49;
  inline bool has_buffmodskillonendbconfig() const;
  inline void clear_buffmodskillonendbconfig();
  static const int kBuffModSkillOnEndBConfigFieldNumber = 49;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodskillonendbconfig</name>
  		<replaceName>BuffModSkillOnEndBConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodskillonendbconfig</name>
  		<replaceName>BuffModSkillOnEndBConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodskillonendbconfig</name>
  		<replaceName>BuffModSkillOnEndBConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodskillonendbconfig</name>
  		<replaceName>BuffModSkillOnEndBConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModSkillOnEndConfig& buffmodskillonendbconfig() const;
  inline ::pb::BuffModSkillOnEndConfig* mutable_buffmodskillonendbconfig();
  inline ::pb::BuffModSkillOnEndConfig* release_buffmodskillonendbconfig();
  inline void set_allocated_buffmodskillonendbconfig(::pb::BuffModSkillOnEndConfig* buffmodskillonendbconfig);

  // optional .pb.BuffModHideSomeAppearanceConfig BuffModHideSomeAppearanceConfig = 51;
  inline bool has_buffmodhidesomeappearanceconfig() const;
  inline void clear_buffmodhidesomeappearanceconfig();
  static const int kBuffModHideSomeAppearanceConfigFieldNumber = 51;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodhidesomeappearanceconfig</name>
  		<replaceName>BuffModHideSomeAppearanceConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodhidesomeappearanceconfig</name>
  		<replaceName>BuffModHideSomeAppearanceConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodhidesomeappearanceconfig</name>
  		<replaceName>BuffModHideSomeAppearanceConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodhidesomeappearanceconfig</name>
  		<replaceName>BuffModHideSomeAppearanceConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModHideSomeAppearanceConfig& buffmodhidesomeappearanceconfig() const;
  inline ::pb::BuffModHideSomeAppearanceConfig* mutable_buffmodhidesomeappearanceconfig();
  inline ::pb::BuffModHideSomeAppearanceConfig* release_buffmodhidesomeappearanceconfig();
  inline void set_allocated_buffmodhidesomeappearanceconfig(::pb::BuffModHideSomeAppearanceConfig* buffmodhidesomeappearanceconfig);

  // optional .pb.BuffModInheritExistBuffStackConfig BuffModInheritExistBuffStackConfig = 54;
  inline bool has_buffmodinheritexistbuffstackconfig() const;
  inline void clear_buffmodinheritexistbuffstackconfig();
  static const int kBuffModInheritExistBuffStackConfigFieldNumber = 54;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodinheritexistbuffstackconfig</name>
  		<replaceName>BuffModInheritExistBuffStackConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodinheritexistbuffstackconfig</name>
  		<replaceName>BuffModInheritExistBuffStackConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodinheritexistbuffstackconfig</name>
  		<replaceName>BuffModInheritExistBuffStackConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodinheritexistbuffstackconfig</name>
  		<replaceName>BuffModInheritExistBuffStackConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModInheritExistBuffStackConfig& buffmodinheritexistbuffstackconfig() const;
  inline ::pb::BuffModInheritExistBuffStackConfig* mutable_buffmodinheritexistbuffstackconfig();
  inline ::pb::BuffModInheritExistBuffStackConfig* release_buffmodinheritexistbuffstackconfig();
  inline void set_allocated_buffmodinheritexistbuffstackconfig(::pb::BuffModInheritExistBuffStackConfig* buffmodinheritexistbuffstackconfig);

  // optional .pb.BuffModScaleTextConfig BuffModScaleTextConfig = 58;
  inline bool has_buffmodscaletextconfig() const;
  inline void clear_buffmodscaletextconfig();
  static const int kBuffModScaleTextConfigFieldNumber = 58;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodscaletextconfig</name>
  		<replaceName>BuffModScaleTextConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodscaletextconfig</name>
  		<replaceName>BuffModScaleTextConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodscaletextconfig</name>
  		<replaceName>BuffModScaleTextConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodscaletextconfig</name>
  		<replaceName>BuffModScaleTextConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModScaleTextConfig& buffmodscaletextconfig() const;
  inline ::pb::BuffModScaleTextConfig* mutable_buffmodscaletextconfig();
  inline ::pb::BuffModScaleTextConfig* release_buffmodscaletextconfig();
  inline void set_allocated_buffmodscaletextconfig(::pb::BuffModScaleTextConfig* buffmodscaletextconfig);

  // optional .pb.BuffModAddDefPointConfig BuffModAddDefPointConfig = 59;
  inline bool has_buffmodadddefpointconfig() const;
  inline void clear_buffmodadddefpointconfig();
  static const int kBuffModAddDefPointConfigFieldNumber = 59;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodadddefpointconfig</name>
  		<replaceName>BuffModAddDefPointConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodadddefpointconfig</name>
  		<replaceName>BuffModAddDefPointConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodadddefpointconfig</name>
  		<replaceName>BuffModAddDefPointConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodadddefpointconfig</name>
  		<replaceName>BuffModAddDefPointConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModAddDefPointConfig& buffmodadddefpointconfig() const;
  inline ::pb::BuffModAddDefPointConfig* mutable_buffmodadddefpointconfig();
  inline ::pb::BuffModAddDefPointConfig* release_buffmodadddefpointconfig();
  inline void set_allocated_buffmodadddefpointconfig(::pb::BuffModAddDefPointConfig* buffmodadddefpointconfig);

  // optional .pb.BuffModRemoveDefPointConfig BuffModRemoveDefPointConfig = 60;
  inline bool has_buffmodremovedefpointconfig() const;
  inline void clear_buffmodremovedefpointconfig();
  static const int kBuffModRemoveDefPointConfigFieldNumber = 60;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodremovedefpointconfig</name>
  		<replaceName>BuffModRemoveDefPointConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodremovedefpointconfig</name>
  		<replaceName>BuffModRemoveDefPointConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodremovedefpointconfig</name>
  		<replaceName>BuffModRemoveDefPointConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodremovedefpointconfig</name>
  		<replaceName>BuffModRemoveDefPointConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModRemoveDefPointConfig& buffmodremovedefpointconfig() const;
  inline ::pb::BuffModRemoveDefPointConfig* mutable_buffmodremovedefpointconfig();
  inline ::pb::BuffModRemoveDefPointConfig* release_buffmodremovedefpointconfig();
  inline void set_allocated_buffmodremovedefpointconfig(::pb::BuffModRemoveDefPointConfig* buffmodremovedefpointconfig);

  // optional .pb.BuffModEffectInRangeConditionConfig BuffModEffectInRangeConditionConfig = 61;
  inline bool has_buffmodeffectinrangeconditionconfig() const;
  inline void clear_buffmodeffectinrangeconditionconfig();
  static const int kBuffModEffectInRangeConditionConfigFieldNumber = 61;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodeffectinrangeconditionconfig</name>
  		<replaceName>BuffModEffectInRangeConditionConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodeffectinrangeconditionconfig</name>
  		<replaceName>BuffModEffectInRangeConditionConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodeffectinrangeconditionconfig</name>
  		<replaceName>BuffModEffectInRangeConditionConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodeffectinrangeconditionconfig</name>
  		<replaceName>BuffModEffectInRangeConditionConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModEffectInRangeConditionConfig& buffmodeffectinrangeconditionconfig() const;
  inline ::pb::BuffModEffectInRangeConditionConfig* mutable_buffmodeffectinrangeconditionconfig();
  inline ::pb::BuffModEffectInRangeConditionConfig* release_buffmodeffectinrangeconditionconfig();
  inline void set_allocated_buffmodeffectinrangeconditionconfig(::pb::BuffModEffectInRangeConditionConfig* buffmodeffectinrangeconditionconfig);

  // optional .pb.BuffModChangeDirConfig BuffModChangeDirConfig = 69;
  inline bool has_buffmodchangedirconfig() const;
  inline void clear_buffmodchangedirconfig();
  static const int kBuffModChangeDirConfigFieldNumber = 69;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodchangedirconfig</name>
  		<replaceName>BuffModChangeDirConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodchangedirconfig</name>
  		<replaceName>BuffModChangeDirConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodchangedirconfig</name>
  		<replaceName>BuffModChangeDirConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodchangedirconfig</name>
  		<replaceName>BuffModChangeDirConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModChangeDirConfig& buffmodchangedirconfig() const;
  inline ::pb::BuffModChangeDirConfig* mutable_buffmodchangedirconfig();
  inline ::pb::BuffModChangeDirConfig* release_buffmodchangedirconfig();
  inline void set_allocated_buffmodchangedirconfig(::pb::BuffModChangeDirConfig* buffmodchangedirconfig);

  // optional .pb.BuffModTDMoniterDefenderStateConfig BuffModTDMoniterDefenderStateConfig = 70;
  inline bool has_buffmodtdmoniterdefenderstateconfig() const;
  inline void clear_buffmodtdmoniterdefenderstateconfig();
  static const int kBuffModTDMoniterDefenderStateConfigFieldNumber = 70;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtdmoniterdefenderstateconfig</name>
  		<replaceName>BuffModTDMoniterDefenderStateConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtdmoniterdefenderstateconfig</name>
  		<replaceName>BuffModTDMoniterDefenderStateConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtdmoniterdefenderstateconfig</name>
  		<replaceName>BuffModTDMoniterDefenderStateConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtdmoniterdefenderstateconfig</name>
  		<replaceName>BuffModTDMoniterDefenderStateConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTDMoniterDefenderStateConfig& buffmodtdmoniterdefenderstateconfig() const;
  inline ::pb::BuffModTDMoniterDefenderStateConfig* mutable_buffmodtdmoniterdefenderstateconfig();
  inline ::pb::BuffModTDMoniterDefenderStateConfig* release_buffmodtdmoniterdefenderstateconfig();
  inline void set_allocated_buffmodtdmoniterdefenderstateconfig(::pb::BuffModTDMoniterDefenderStateConfig* buffmodtdmoniterdefenderstateconfig);

  // optional .pb.BuffModTDNoBeanConfig BuffModTDNoBeanConfig = 71;
  inline bool has_buffmodtdnobeanconfig() const;
  inline void clear_buffmodtdnobeanconfig();
  static const int kBuffModTDNoBeanConfigFieldNumber = 71;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtdnobeanconfig</name>
  		<replaceName>BuffModTDNoBeanConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtdnobeanconfig</name>
  		<replaceName>BuffModTDNoBeanConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtdnobeanconfig</name>
  		<replaceName>BuffModTDNoBeanConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtdnobeanconfig</name>
  		<replaceName>BuffModTDNoBeanConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTDNoBeanConfig& buffmodtdnobeanconfig() const;
  inline ::pb::BuffModTDNoBeanConfig* mutable_buffmodtdnobeanconfig();
  inline ::pb::BuffModTDNoBeanConfig* release_buffmodtdnobeanconfig();
  inline void set_allocated_buffmodtdnobeanconfig(::pb::BuffModTDNoBeanConfig* buffmodtdnobeanconfig);

  // optional .pb.BuffModTDRepeatSendBeanConfig BuffModTDRepeatSendBeanConfig = 72;
  inline bool has_buffmodtdrepeatsendbeanconfig() const;
  inline void clear_buffmodtdrepeatsendbeanconfig();
  static const int kBuffModTDRepeatSendBeanConfigFieldNumber = 72;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtdrepeatsendbeanconfig</name>
  		<replaceName>BuffModTDRepeatSendBeanConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtdrepeatsendbeanconfig</name>
  		<replaceName>BuffModTDRepeatSendBeanConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtdrepeatsendbeanconfig</name>
  		<replaceName>BuffModTDRepeatSendBeanConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtdrepeatsendbeanconfig</name>
  		<replaceName>BuffModTDRepeatSendBeanConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTDRepeatSendBeanConfig& buffmodtdrepeatsendbeanconfig() const;
  inline ::pb::BuffModTDRepeatSendBeanConfig* mutable_buffmodtdrepeatsendbeanconfig();
  inline ::pb::BuffModTDRepeatSendBeanConfig* release_buffmodtdrepeatsendbeanconfig();
  inline void set_allocated_buffmodtdrepeatsendbeanconfig(::pb::BuffModTDRepeatSendBeanConfig* buffmodtdrepeatsendbeanconfig);

  // optional .pb.BuffModTDRepeatCheckBeanConfig BuffModTDRepeatCheckBeanConfig = 73;
  inline bool has_buffmodtdrepeatcheckbeanconfig() const;
  inline void clear_buffmodtdrepeatcheckbeanconfig();
  static const int kBuffModTDRepeatCheckBeanConfigFieldNumber = 73;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodtdrepeatcheckbeanconfig</name>
  		<replaceName>BuffModTDRepeatCheckBeanConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodtdrepeatcheckbeanconfig</name>
  		<replaceName>BuffModTDRepeatCheckBeanConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodtdrepeatcheckbeanconfig</name>
  		<replaceName>BuffModTDRepeatCheckBeanConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodtdrepeatcheckbeanconfig</name>
  		<replaceName>BuffModTDRepeatCheckBeanConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModTDRepeatCheckBeanConfig& buffmodtdrepeatcheckbeanconfig() const;
  inline ::pb::BuffModTDRepeatCheckBeanConfig* mutable_buffmodtdrepeatcheckbeanconfig();
  inline ::pb::BuffModTDRepeatCheckBeanConfig* release_buffmodtdrepeatcheckbeanconfig();
  inline void set_allocated_buffmodtdrepeatcheckbeanconfig(::pb::BuffModTDRepeatCheckBeanConfig* buffmodtdrepeatcheckbeanconfig);

  // optional .pb.BuffModBuffOnStackConfig BuffModBuffOnStackConfig = 76;
  inline bool has_buffmodbuffonstackconfig() const;
  inline void clear_buffmodbuffonstackconfig();
  static const int kBuffModBuffOnStackConfigFieldNumber = 76;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodbuffonstackconfig</name>
  		<replaceName>BuffModBuffOnStackConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodbuffonstackconfig</name>
  		<replaceName>BuffModBuffOnStackConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodbuffonstackconfig</name>
  		<replaceName>BuffModBuffOnStackConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodbuffonstackconfig</name>
  		<replaceName>BuffModBuffOnStackConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModBuffOnStackConfig& buffmodbuffonstackconfig() const;
  inline ::pb::BuffModBuffOnStackConfig* mutable_buffmodbuffonstackconfig();
  inline ::pb::BuffModBuffOnStackConfig* release_buffmodbuffonstackconfig();
  inline void set_allocated_buffmodbuffonstackconfig(::pb::BuffModBuffOnStackConfig* buffmodbuffonstackconfig);

  // optional .pb.BuffModChangeSummonedAIConfig BuffModChangeSummonedAIConfig = 80;
  inline bool has_buffmodchangesummonedaiconfig() const;
  inline void clear_buffmodchangesummonedaiconfig();
  static const int kBuffModChangeSummonedAIConfigFieldNumber = 80;
  /*FOR2LUA
  <Record>
  	<name>BuffData</name>
  	<Function>
  		<name>buffmodchangesummonedaiconfig</name>
  		<replaceName>BuffModChangeSummonedAIConfig</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_buffmodchangesummonedaiconfig</name>
  		<replaceName>BuffModChangeSummonedAIConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_buffmodchangesummonedaiconfig</name>
  		<replaceName>BuffModChangeSummonedAIConfig</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_buffmodchangesummonedaiconfig</name>
  		<replaceName>BuffModChangeSummonedAIConfig</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BuffModChangeSummonedAIConfig& buffmodchangesummonedaiconfig() const;
  inline ::pb::BuffModChangeSummonedAIConfig* mutable_buffmodchangesummonedaiconfig();
  inline ::pb::BuffModChangeSummonedAIConfig* release_buffmodchangesummonedaiconfig();
  inline void set_allocated_buffmodchangesummonedaiconfig(::pb::BuffModChangeSummonedAIConfig* buffmodchangesummonedaiconfig);

  // @@protoc_insertion_point(class_scope:pb.BuffData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_basedatamodel();
  inline void clear_has_basedatamodel();
  inline void set_has_specialhitmodel();
  inline void clear_has_specialhitmodel();
  inline void set_has_buffmodhpconfig();
  inline void clear_has_buffmodhpconfig();
  inline void set_has_buffmodreflectdamageconfig();
  inline void clear_has_buffmodreflectdamageconfig();
  inline void set_has_buffmodreflectskillconfig();
  inline void clear_has_buffmodreflectskillconfig();
  inline void set_has_buffmodbuffimmunityconfig();
  inline void clear_has_buffmodbuffimmunityconfig();
  inline void set_has_buffmodpropertyconfig();
  inline void clear_has_buffmodpropertyconfig();
  inline void set_has_buffmodattackspeedconfig();
  inline void clear_has_buffmodattackspeedconfig();
  inline void set_has_buffmodrageconfig();
  inline void clear_has_buffmodrageconfig();
  inline void set_has_buffmodabsorbdamageconfig();
  inline void clear_has_buffmodabsorbdamageconfig();
  inline void set_has_buffmodnonhostiletargettableconfig();
  inline void clear_has_buffmodnonhostiletargettableconfig();
  inline void set_has_buffmodnontargettableconfig();
  inline void clear_has_buffmodnontargettableconfig();
  inline void set_has_buffmoddamageshareconfig();
  inline void clear_has_buffmoddamageshareconfig();
  inline void set_has_buffmodhealcopyconfig();
  inline void clear_has_buffmodhealcopyconfig();
  inline void set_has_buffmodstealhpconfig();
  inline void clear_has_buffmodstealhpconfig();
  inline void set_has_buffmodskillimmunityconfig();
  inline void clear_has_buffmodskillimmunityconfig();
  inline void set_has_buffmodtoughnessconfig();
  inline void clear_has_buffmodtoughnessconfig();
  inline void set_has_buffmoddispelconfig();
  inline void clear_has_buffmoddispelconfig();
  inline void set_has_buffmoddamageimmunityconfig();
  inline void clear_has_buffmoddamageimmunityconfig();
  inline void set_has_buffmodhitactionimmunityconfig();
  inline void clear_has_buffmodhitactionimmunityconfig();
  inline void set_has_buffmodarmattraddconfig();
  inline void clear_has_buffmodarmattraddconfig();
  inline void set_has_buffmodskillonlowlifeconfig();
  inline void clear_has_buffmodskillonlowlifeconfig();
  inline void set_has_buffmodmovecontrolimmunityconfig();
  inline void clear_has_buffmodmovecontrolimmunityconfig();
  inline void set_has_buffmodconditionchangeconfig();
  inline void clear_has_buffmodconditionchangeconfig();
  inline void set_has_buffmodpropertydecconfig();
  inline void clear_has_buffmodpropertydecconfig();
  inline void set_has_buffmodchangedmgbybuffsubconfig();
  inline void clear_has_buffmodchangedmgbybuffsubconfig();
  inline void set_has_buffmodshrinkcontroldurationconfig();
  inline void clear_has_buffmodshrinkcontroldurationconfig();
  inline void set_has_buffmodunlimitedshieldconfig();
  inline void clear_has_buffmodunlimitedshieldconfig();
  inline void set_has_buffmodreflectbuffconfig();
  inline void clear_has_buffmodreflectbuffconfig();
  inline void set_has_buffmodfataldmgshiftconfig();
  inline void clear_has_buffmodfataldmgshiftconfig();
  inline void set_has_buffmodrageimmunityconfig();
  inline void clear_has_buffmodrageimmunityconfig();
  inline void set_has_buffmodignoreshieldconfig();
  inline void clear_has_buffmodignoreshieldconfig();
  inline void set_has_buffmodrevertstateonendconfig();
  inline void clear_has_buffmodrevertstateonendconfig();
  inline void set_has_buffmodchangecastrangeconfig();
  inline void clear_has_buffmodchangecastrangeconfig();
  inline void set_has_buffmodsetmaxlosehpconfig();
  inline void clear_has_buffmodsetmaxlosehpconfig();
  inline void set_has_buffmodadjustreflecteddamageconfig();
  inline void clear_has_buffmodadjustreflecteddamageconfig();
  inline void set_has_buffmodactiveuieffectconfig();
  inline void clear_has_buffmodactiveuieffectconfig();
  inline void set_has_buffmodadjustbuffhitrateconfig();
  inline void clear_has_buffmodadjustbuffhitrateconfig();
  inline void set_has_buffmodlimitbymaxhprateconfig();
  inline void clear_has_buffmodlimitbymaxhprateconfig();
  inline void set_has_buffmodbattlearchermodifyconfig();
  inline void clear_has_buffmodbattlearchermodifyconfig();
  inline void set_has_buffmodnomoveconfig();
  inline void clear_has_buffmodnomoveconfig();
  inline void set_has_buffmodnonormalskillconfig();
  inline void clear_has_buffmodnonormalskillconfig();
  inline void set_has_buffmodnoskillconfig();
  inline void clear_has_buffmodnoskillconfig();
  inline void set_has_buffmoddizzinessconfig();
  inline void clear_has_buffmoddizzinessconfig();
  inline void set_has_buffmodfreezeconfig();
  inline void clear_has_buffmodfreezeconfig();
  inline void set_has_buffmodcharmedconfig();
  inline void clear_has_buffmodcharmedconfig();
  inline void set_has_buffmodchaosconfig();
  inline void clear_has_buffmodchaosconfig();
  inline void set_has_buffmodrandommoveconfig();
  inline void clear_has_buffmodrandommoveconfig();
  inline void set_has_buffmoddamagecopyconfig();
  inline void clear_has_buffmoddamagecopyconfig();
  inline void set_has_buffmodtauntconfig();
  inline void clear_has_buffmodtauntconfig();
  inline void set_has_buffmodnoragerecoverconfig();
  inline void clear_has_buffmodnoragerecoverconfig();
  inline void set_has_buffmoddisableconfig();
  inline void clear_has_buffmoddisableconfig();
  inline void set_has_buffmodharmonmoveconfig();
  inline void clear_has_buffmodharmonmoveconfig();
  inline void set_has_buffmodfearconfig();
  inline void clear_has_buffmodfearconfig();
  inline void set_has_buffmodnosuckbloodconfig();
  inline void clear_has_buffmodnosuckbloodconfig();
  inline void set_has_buffmodnoreviveconfig();
  inline void clear_has_buffmodnoreviveconfig();
  inline void set_has_buffmodtransformationconfig();
  inline void clear_has_buffmodtransformationconfig();
  inline void set_has_buffmodnothingconfig();
  inline void clear_has_buffmodnothingconfig();
  inline void set_has_buffmodtransformscaleconfig();
  inline void clear_has_buffmodtransformscaleconfig();
  inline void set_has_buffmoddieconfig();
  inline void clear_has_buffmoddieconfig();
  inline void set_has_buffmodrepeatskillconfig();
  inline void clear_has_buffmodrepeatskillconfig();
  inline void set_has_buffmodskillonendconfig();
  inline void clear_has_buffmodskillonendconfig();
  inline void set_has_buffmodspecifyskilltidconfig();
  inline void clear_has_buffmodspecifyskilltidconfig();
  inline void set_has_buffmodresetbufftimeconfig();
  inline void clear_has_buffmodresetbufftimeconfig();
  inline void set_has_buffmodaddskillconfig();
  inline void clear_has_buffmodaddskillconfig();
  inline void set_has_buffmodpropertyformulaconfig();
  inline void clear_has_buffmodpropertyformulaconfig();
  inline void set_has_buffmodeffectinrangeconfig();
  inline void clear_has_buffmodeffectinrangeconfig();
  inline void set_has_buffmodrecorddataconfig();
  inline void clear_has_buffmodrecorddataconfig();
  inline void set_has_buffmodskillonendbconfig();
  inline void clear_has_buffmodskillonendbconfig();
  inline void set_has_buffmodhidesomeappearanceconfig();
  inline void clear_has_buffmodhidesomeappearanceconfig();
  inline void set_has_buffmodinheritexistbuffstackconfig();
  inline void clear_has_buffmodinheritexistbuffstackconfig();
  inline void set_has_buffmodscaletextconfig();
  inline void clear_has_buffmodscaletextconfig();
  inline void set_has_buffmodadddefpointconfig();
  inline void clear_has_buffmodadddefpointconfig();
  inline void set_has_buffmodremovedefpointconfig();
  inline void clear_has_buffmodremovedefpointconfig();
  inline void set_has_buffmodeffectinrangeconditionconfig();
  inline void clear_has_buffmodeffectinrangeconditionconfig();
  inline void set_has_buffmodchangedirconfig();
  inline void clear_has_buffmodchangedirconfig();
  inline void set_has_buffmodtdmoniterdefenderstateconfig();
  inline void clear_has_buffmodtdmoniterdefenderstateconfig();
  inline void set_has_buffmodtdnobeanconfig();
  inline void clear_has_buffmodtdnobeanconfig();
  inline void set_has_buffmodtdrepeatsendbeanconfig();
  inline void clear_has_buffmodtdrepeatsendbeanconfig();
  inline void set_has_buffmodtdrepeatcheckbeanconfig();
  inline void clear_has_buffmodtdrepeatcheckbeanconfig();
  inline void set_has_buffmodbuffonstackconfig();
  inline void clear_has_buffmodbuffonstackconfig();
  inline void set_has_buffmodchangesummonedaiconfig();
  inline void clear_has_buffmodchangesummonedaiconfig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[3];
  mutable int _cached_size_;
  ::pb::BuffBaseDataModel* basedatamodel_;
  ::pb::SpecialHitModel* specialhitmodel_;
  ::pb::BuffModHpConfig* buffmodhpconfig_;
  ::pb::BuffModReflectDamageConfig* buffmodreflectdamageconfig_;
  ::pb::BuffModReflectSkillConfig* buffmodreflectskillconfig_;
  ::pb::BuffModBuffImmunityConfig* buffmodbuffimmunityconfig_;
  ::pb::BuffModPropertyConfig* buffmodpropertyconfig_;
  ::pb::BuffModAttackSpeedConfig* buffmodattackspeedconfig_;
  ::pb::BuffModRageConfig* buffmodrageconfig_;
  ::pb::BuffModAbsorbDamageConfig* buffmodabsorbdamageconfig_;
  ::pb::BuffModNonHostileTargettableConfig* buffmodnonhostiletargettableconfig_;
  ::pb::BuffModNonTargettableConfig* buffmodnontargettableconfig_;
  ::pb::BuffModDamageShareConfig* buffmoddamageshareconfig_;
  ::pb::BuffModHealCopyConfig* buffmodhealcopyconfig_;
  ::pb::BuffModStealHpConfig* buffmodstealhpconfig_;
  ::pb::BuffModSkillImmunityConfig* buffmodskillimmunityconfig_;
  ::pb::BuffModToughnessConfig* buffmodtoughnessconfig_;
  ::pb::BuffModDispelConfig* buffmoddispelconfig_;
  ::pb::BuffModDamageImmunityConfig* buffmoddamageimmunityconfig_;
  ::pb::BuffModHitActionImmunityConfig* buffmodhitactionimmunityconfig_;
  ::pb::BuffModArmAttrAddConfig* buffmodarmattraddconfig_;
  ::pb::BuffModSkillOnLowLifeConfig* buffmodskillonlowlifeconfig_;
  ::pb::BuffModMoveControlImmunityConfig* buffmodmovecontrolimmunityconfig_;
  ::pb::BuffModConditionChangeConfig* buffmodconditionchangeconfig_;
  ::pb::BuffModPropertyDecConfig* buffmodpropertydecconfig_;
  ::pb::BuffModChangeDmgByBuffSubConfig* buffmodchangedmgbybuffsubconfig_;
  ::pb::BuffModShrinkControlDurationConfig* buffmodshrinkcontroldurationconfig_;
  ::pb::BuffModUnlimitedShieldConfig* buffmodunlimitedshieldconfig_;
  ::pb::BuffModReflectBuffConfig* buffmodreflectbuffconfig_;
  ::pb::BuffModFatalDmgShiftConfig* buffmodfataldmgshiftconfig_;
  ::pb::BuffModRageImmunityConfig* buffmodrageimmunityconfig_;
  ::pb::BuffModIgnoreShieldConfig* buffmodignoreshieldconfig_;
  ::pb::BuffModRevertStateOnEndConfig* buffmodrevertstateonendconfig_;
  ::pb::BuffModChangeCastRangeConfig* buffmodchangecastrangeconfig_;
  ::pb::BuffModSetMaxLoseHPConfig* buffmodsetmaxlosehpconfig_;
  ::pb::BuffModAdjustReflectedDamageConfig* buffmodadjustreflecteddamageconfig_;
  ::pb::BuffModActiveUIEffectConfig* buffmodactiveuieffectconfig_;
  ::pb::BuffModAdjustBuffHitRateConfig* buffmodadjustbuffhitrateconfig_;
  ::pb::BuffModLimitByMaxHpRateConfig* buffmodlimitbymaxhprateconfig_;
  ::pb::BuffModBattleArcherModifyConfig* buffmodbattlearchermodifyconfig_;
  ::pb::BuffModNoMoveConfig* buffmodnomoveconfig_;
  ::pb::BuffModNoNormalSkillConfig* buffmodnonormalskillconfig_;
  ::pb::BuffModNoSkillConfig* buffmodnoskillconfig_;
  ::pb::BuffModDizzinessConfig* buffmoddizzinessconfig_;
  ::pb::BuffModFreezeConfig* buffmodfreezeconfig_;
  ::pb::BuffModCharmedConfig* buffmodcharmedconfig_;
  ::pb::BuffModChaosConfig* buffmodchaosconfig_;
  ::pb::BuffModRandomMoveConfig* buffmodrandommoveconfig_;
  ::pb::BuffModDamageCopyConfig* buffmoddamagecopyconfig_;
  ::pb::BuffModTauntConfig* buffmodtauntconfig_;
  ::pb::BuffModNoRageRecoverConfig* buffmodnoragerecoverconfig_;
  ::pb::BuffModDisableConfig* buffmoddisableconfig_;
  ::pb::BuffModHarmOnMoveConfig* buffmodharmonmoveconfig_;
  ::pb::BuffModFearConfig* buffmodfearconfig_;
  ::pb::BuffModNoSuckBloodConfig* buffmodnosuckbloodconfig_;
  ::pb::BuffModNoReviveConfig* buffmodnoreviveconfig_;
  ::pb::BuffModTransformationConfig* buffmodtransformationconfig_;
  ::pb::BuffModNothingConfig* buffmodnothingconfig_;
  ::pb::BuffModTransformScaleConfig* buffmodtransformscaleconfig_;
  ::pb::BuffModDieConfig* buffmoddieconfig_;
  ::pb::BuffModRepeatSkillConfig* buffmodrepeatskillconfig_;
  ::pb::BuffModSkillOnEndConfig* buffmodskillonendconfig_;
  ::pb::BuffModSpecifySkillTidConfig* buffmodspecifyskilltidconfig_;
  ::pb::BuffModResetBuffTimeConfig* buffmodresetbufftimeconfig_;
  ::pb::BuffModAddSkillConfig* buffmodaddskillconfig_;
  ::pb::BuffModPropertyFormulaConfig* buffmodpropertyformulaconfig_;
  ::pb::BuffModEffectInRangeConfig* buffmodeffectinrangeconfig_;
  ::pb::BuffModRecordDataConfig* buffmodrecorddataconfig_;
  ::pb::BuffModSkillOnEndConfig* buffmodskillonendbconfig_;
  ::pb::BuffModHideSomeAppearanceConfig* buffmodhidesomeappearanceconfig_;
  ::pb::BuffModInheritExistBuffStackConfig* buffmodinheritexistbuffstackconfig_;
  ::pb::BuffModScaleTextConfig* buffmodscaletextconfig_;
  ::pb::BuffModAddDefPointConfig* buffmodadddefpointconfig_;
  ::pb::BuffModRemoveDefPointConfig* buffmodremovedefpointconfig_;
  ::pb::BuffModEffectInRangeConditionConfig* buffmodeffectinrangeconditionconfig_;
  ::pb::BuffModChangeDirConfig* buffmodchangedirconfig_;
  ::pb::BuffModTDMoniterDefenderStateConfig* buffmodtdmoniterdefenderstateconfig_;
  ::pb::BuffModTDNoBeanConfig* buffmodtdnobeanconfig_;
  ::pb::BuffModTDRepeatSendBeanConfig* buffmodtdrepeatsendbeanconfig_;
  ::pb::BuffModTDRepeatCheckBeanConfig* buffmodtdrepeatcheckbeanconfig_;
  ::pb::BuffModBuffOnStackConfig* buffmodbuffonstackconfig_;
  ::pb::BuffModChangeSummonedAIConfig* buffmodchangesummonedaiconfig_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fBuffData_2eproto();
  friend void protobuf_AssignDesc_module_2fBuffData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBuffData_2eproto();

  void InitAsDefaultInstance();
  static BuffData* default_instance_;
};
// ===================================================================


// ===================================================================

// SpecialHitModel

// optional int32 HitType = 1;
inline bool SpecialHitModel::has_hittype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpecialHitModel::set_has_hittype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpecialHitModel::clear_has_hittype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpecialHitModel::clear_hittype() {
  hittype_ = 0;
  clear_has_hittype();
}
inline ::google::protobuf::int32 SpecialHitModel::hittype() const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.HitType)
  return hittype_;
}
inline void SpecialHitModel::set_hittype(::google::protobuf::int32 value) {
  set_has_hittype();
  hittype_ = value;
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.HitType)
}

// optional int32 BuffType = 2;
inline bool SpecialHitModel::has_bufftype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpecialHitModel::set_has_bufftype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpecialHitModel::clear_has_bufftype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpecialHitModel::clear_bufftype() {
  bufftype_ = 0;
  clear_has_bufftype();
}
inline ::google::protobuf::int32 SpecialHitModel::bufftype() const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.BuffType)
  return bufftype_;
}
inline void SpecialHitModel::set_bufftype(::google::protobuf::int32 value) {
  set_has_bufftype();
  bufftype_ = value;
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.BuffType)
}

// repeated int32 BuffList = 3;
inline int SpecialHitModel::bufflist_size() const {
  return bufflist_.size();
}
inline void SpecialHitModel::clear_bufflist() {
  bufflist_.Clear();
}
inline ::google::protobuf::int32 SpecialHitModel::bufflist(int index) const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.BuffList)
  return bufflist_.Get(index);
}
inline void SpecialHitModel::set_bufflist(int index, ::google::protobuf::int32 value) {
  bufflist_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.BuffList)
}
inline void SpecialHitModel::add_bufflist(::google::protobuf::int32 value) {
  bufflist_.Add(value);
  // @@protoc_insertion_point(field_add:pb.SpecialHitModel.BuffList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SpecialHitModel::bufflist() const {
  // @@protoc_insertion_point(field_list:pb.SpecialHitModel.BuffList)
  return bufflist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SpecialHitModel::mutable_bufflist() {
  // @@protoc_insertion_point(field_mutable_list:pb.SpecialHitModel.BuffList)
  return &bufflist_;
}

// optional bool AdjustScale = 4;
inline bool SpecialHitModel::has_adjustscale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpecialHitModel::set_has_adjustscale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpecialHitModel::clear_has_adjustscale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpecialHitModel::clear_adjustscale() {
  adjustscale_ = false;
  clear_has_adjustscale();
}
inline bool SpecialHitModel::adjustscale() const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.AdjustScale)
  return adjustscale_;
}
inline void SpecialHitModel::set_adjustscale(bool value) {
  set_has_adjustscale();
  adjustscale_ = value;
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.AdjustScale)
}

// repeated int32 BuffLastTime = 5;
inline int SpecialHitModel::bufflasttime_size() const {
  return bufflasttime_.size();
}
inline void SpecialHitModel::clear_bufflasttime() {
  bufflasttime_.Clear();
}
inline ::google::protobuf::int32 SpecialHitModel::bufflasttime(int index) const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.BuffLastTime)
  return bufflasttime_.Get(index);
}
inline void SpecialHitModel::set_bufflasttime(int index, ::google::protobuf::int32 value) {
  bufflasttime_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.BuffLastTime)
}
inline void SpecialHitModel::add_bufflasttime(::google::protobuf::int32 value) {
  bufflasttime_.Add(value);
  // @@protoc_insertion_point(field_add:pb.SpecialHitModel.BuffLastTime)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SpecialHitModel::bufflasttime() const {
  // @@protoc_insertion_point(field_list:pb.SpecialHitModel.BuffLastTime)
  return bufflasttime_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SpecialHitModel::mutable_bufflasttime() {
  // @@protoc_insertion_point(field_mutable_list:pb.SpecialHitModel.BuffLastTime)
  return &bufflasttime_;
}

// repeated int32 BuffEffect = 6;
inline int SpecialHitModel::buffeffect_size() const {
  return buffeffect_.size();
}
inline void SpecialHitModel::clear_buffeffect() {
  buffeffect_.Clear();
}
inline ::google::protobuf::int32 SpecialHitModel::buffeffect(int index) const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.BuffEffect)
  return buffeffect_.Get(index);
}
inline void SpecialHitModel::set_buffeffect(int index, ::google::protobuf::int32 value) {
  buffeffect_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.BuffEffect)
}
inline void SpecialHitModel::add_buffeffect(::google::protobuf::int32 value) {
  buffeffect_.Add(value);
  // @@protoc_insertion_point(field_add:pb.SpecialHitModel.BuffEffect)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SpecialHitModel::buffeffect() const {
  // @@protoc_insertion_point(field_list:pb.SpecialHitModel.BuffEffect)
  return buffeffect_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SpecialHitModel::mutable_buffeffect() {
  // @@protoc_insertion_point(field_mutable_list:pb.SpecialHitModel.BuffEffect)
  return &buffeffect_;
}

// repeated int32 BuffHitRate = 7;
inline int SpecialHitModel::buffhitrate_size() const {
  return buffhitrate_.size();
}
inline void SpecialHitModel::clear_buffhitrate() {
  buffhitrate_.Clear();
}
inline ::google::protobuf::int32 SpecialHitModel::buffhitrate(int index) const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.BuffHitRate)
  return buffhitrate_.Get(index);
}
inline void SpecialHitModel::set_buffhitrate(int index, ::google::protobuf::int32 value) {
  buffhitrate_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.BuffHitRate)
}
inline void SpecialHitModel::add_buffhitrate(::google::protobuf::int32 value) {
  buffhitrate_.Add(value);
  // @@protoc_insertion_point(field_add:pb.SpecialHitModel.BuffHitRate)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SpecialHitModel::buffhitrate() const {
  // @@protoc_insertion_point(field_list:pb.SpecialHitModel.BuffHitRate)
  return buffhitrate_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SpecialHitModel::mutable_buffhitrate() {
  // @@protoc_insertion_point(field_mutable_list:pb.SpecialHitModel.BuffHitRate)
  return &buffhitrate_;
}

// optional bool UpdateEffect = 8;
inline bool SpecialHitModel::has_updateeffect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SpecialHitModel::set_has_updateeffect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SpecialHitModel::clear_has_updateeffect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SpecialHitModel::clear_updateeffect() {
  updateeffect_ = false;
  clear_has_updateeffect();
}
inline bool SpecialHitModel::updateeffect() const {
  // @@protoc_insertion_point(field_get:pb.SpecialHitModel.UpdateEffect)
  return updateeffect_;
}
inline void SpecialHitModel::set_updateeffect(bool value) {
  set_has_updateeffect();
  updateeffect_ = value;
  // @@protoc_insertion_point(field_set:pb.SpecialHitModel.UpdateEffect)
}

// -------------------------------------------------------------------

// BuffModAbsorbDamageConfig

// optional bool Active = 1;
inline bool BuffModAbsorbDamageConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModAbsorbDamageConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModAbsorbDamageConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModAbsorbDamageConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.Active)
  return active_;
}
inline void BuffModAbsorbDamageConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModAbsorbDamageConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModAbsorbDamageConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModAbsorbDamageConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.DelayTime)
  return delaytime_;
}
inline void BuffModAbsorbDamageConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.DelayTime)
}

// optional int32 ValueParma = 3;
inline bool BuffModAbsorbDamageConfig::has_valueparma() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_valueparma() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModAbsorbDamageConfig::clear_has_valueparma() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModAbsorbDamageConfig::clear_valueparma() {
  valueparma_ = 0;
  clear_has_valueparma();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::valueparma() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.ValueParma)
  return valueparma_;
}
inline void BuffModAbsorbDamageConfig::set_valueparma(::google::protobuf::int32 value) {
  set_has_valueparma();
  valueparma_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.ValueParma)
}

// optional int32 ValueGrowth = 4;
inline bool BuffModAbsorbDamageConfig::has_valuegrowth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_valuegrowth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModAbsorbDamageConfig::clear_has_valuegrowth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModAbsorbDamageConfig::clear_valuegrowth() {
  valuegrowth_ = 0;
  clear_has_valuegrowth();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::valuegrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.ValueGrowth)
  return valuegrowth_;
}
inline void BuffModAbsorbDamageConfig::set_valuegrowth(::google::protobuf::int32 value) {
  set_has_valuegrowth();
  valuegrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.ValueGrowth)
}

// optional int32 IsCureSelf = 5;
inline bool BuffModAbsorbDamageConfig::has_iscureself() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_iscureself() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModAbsorbDamageConfig::clear_has_iscureself() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModAbsorbDamageConfig::clear_iscureself() {
  iscureself_ = 0;
  clear_has_iscureself();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::iscureself() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.IsCureSelf)
  return iscureself_;
}
inline void BuffModAbsorbDamageConfig::set_iscureself(::google::protobuf::int32 value) {
  set_has_iscureself();
  iscureself_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.IsCureSelf)
}

// optional int32 PercentParam = 6;
inline bool BuffModAbsorbDamageConfig::has_percentparam() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_percentparam() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffModAbsorbDamageConfig::clear_has_percentparam() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffModAbsorbDamageConfig::clear_percentparam() {
  percentparam_ = 0;
  clear_has_percentparam();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::percentparam() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.PercentParam)
  return percentparam_;
}
inline void BuffModAbsorbDamageConfig::set_percentparam(::google::protobuf::int32 value) {
  set_has_percentparam();
  percentparam_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.PercentParam)
}

// optional int32 PercentGrowth = 7;
inline bool BuffModAbsorbDamageConfig::has_percentgrowth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_percentgrowth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuffModAbsorbDamageConfig::clear_has_percentgrowth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuffModAbsorbDamageConfig::clear_percentgrowth() {
  percentgrowth_ = 0;
  clear_has_percentgrowth();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::percentgrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.PercentGrowth)
  return percentgrowth_;
}
inline void BuffModAbsorbDamageConfig::set_percentgrowth(::google::protobuf::int32 value) {
  set_has_percentgrowth();
  percentgrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.PercentGrowth)
}

// optional int32 AbsorbCalculateType = 8;
inline bool BuffModAbsorbDamageConfig::has_absorbcalculatetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_absorbcalculatetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuffModAbsorbDamageConfig::clear_has_absorbcalculatetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuffModAbsorbDamageConfig::clear_absorbcalculatetype() {
  absorbcalculatetype_ = 0;
  clear_has_absorbcalculatetype();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::absorbcalculatetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AbsorbCalculateType)
  return absorbcalculatetype_;
}
inline void BuffModAbsorbDamageConfig::set_absorbcalculatetype(::google::protobuf::int32 value) {
  set_has_absorbcalculatetype();
  absorbcalculatetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AbsorbCalculateType)
}

// optional int32 AttributeOriginal = 9;
inline bool BuffModAbsorbDamageConfig::has_attributeoriginal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_attributeoriginal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BuffModAbsorbDamageConfig::clear_has_attributeoriginal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BuffModAbsorbDamageConfig::clear_attributeoriginal() {
  attributeoriginal_ = 0;
  clear_has_attributeoriginal();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::attributeoriginal() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AttributeOriginal)
  return attributeoriginal_;
}
inline void BuffModAbsorbDamageConfig::set_attributeoriginal(::google::protobuf::int32 value) {
  set_has_attributeoriginal();
  attributeoriginal_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AttributeOriginal)
}

// optional int32 AttributeType = 10;
inline bool BuffModAbsorbDamageConfig::has_attributetype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_attributetype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BuffModAbsorbDamageConfig::clear_has_attributetype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BuffModAbsorbDamageConfig::clear_attributetype() {
  attributetype_ = 0;
  clear_has_attributetype();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::attributetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AttributeType)
  return attributetype_;
}
inline void BuffModAbsorbDamageConfig::set_attributetype(::google::protobuf::int32 value) {
  set_has_attributetype();
  attributetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AttributeType)
}

// optional int32 AttributePercenteParam = 11;
inline bool BuffModAbsorbDamageConfig::has_attributepercenteparam() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_attributepercenteparam() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BuffModAbsorbDamageConfig::clear_has_attributepercenteparam() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BuffModAbsorbDamageConfig::clear_attributepercenteparam() {
  attributepercenteparam_ = 0;
  clear_has_attributepercenteparam();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::attributepercenteparam() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AttributePercenteParam)
  return attributepercenteparam_;
}
inline void BuffModAbsorbDamageConfig::set_attributepercenteparam(::google::protobuf::int32 value) {
  set_has_attributepercenteparam();
  attributepercenteparam_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AttributePercenteParam)
}

// optional int32 AttributePercenteGrowth = 12;
inline bool BuffModAbsorbDamageConfig::has_attributepercentegrowth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_attributepercentegrowth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BuffModAbsorbDamageConfig::clear_has_attributepercentegrowth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BuffModAbsorbDamageConfig::clear_attributepercentegrowth() {
  attributepercentegrowth_ = 0;
  clear_has_attributepercentegrowth();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::attributepercentegrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AttributePercenteGrowth)
  return attributepercentegrowth_;
}
inline void BuffModAbsorbDamageConfig::set_attributepercentegrowth(::google::protobuf::int32 value) {
  set_has_attributepercentegrowth();
  attributepercentegrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AttributePercenteGrowth)
}

// optional int32 AbsorbType = 13;
inline bool BuffModAbsorbDamageConfig::has_absorbtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_absorbtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BuffModAbsorbDamageConfig::clear_has_absorbtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BuffModAbsorbDamageConfig::clear_absorbtype() {
  absorbtype_ = 0;
  clear_has_absorbtype();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::absorbtype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AbsorbType)
  return absorbtype_;
}
inline void BuffModAbsorbDamageConfig::set_absorbtype(::google::protobuf::int32 value) {
  set_has_absorbtype();
  absorbtype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AbsorbType)
}

// optional int32 AbsorbCount = 14;
inline bool BuffModAbsorbDamageConfig::has_absorbcount() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_absorbcount() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BuffModAbsorbDamageConfig::clear_has_absorbcount() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BuffModAbsorbDamageConfig::clear_absorbcount() {
  absorbcount_ = 0;
  clear_has_absorbcount();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::absorbcount() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.AbsorbCount)
  return absorbcount_;
}
inline void BuffModAbsorbDamageConfig::set_absorbcount(::google::protobuf::int32 value) {
  set_has_absorbcount();
  absorbcount_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.AbsorbCount)
}

// optional int32 Threshold = 15;
inline bool BuffModAbsorbDamageConfig::has_threshold() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BuffModAbsorbDamageConfig::set_has_threshold() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BuffModAbsorbDamageConfig::clear_has_threshold() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BuffModAbsorbDamageConfig::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline ::google::protobuf::int32 BuffModAbsorbDamageConfig::threshold() const {
  // @@protoc_insertion_point(field_get:pb.BuffModAbsorbDamageConfig.Threshold)
  return threshold_;
}
inline void BuffModAbsorbDamageConfig::set_threshold(::google::protobuf::int32 value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModAbsorbDamageConfig.Threshold)
}

// -------------------------------------------------------------------

// BuffModNonTargettableConfig

// optional bool Active = 1;
inline bool BuffModNonTargettableConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModNonTargettableConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModNonTargettableConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModNonTargettableConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModNonTargettableConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModNonTargettableConfig.Active)
  return active_;
}
inline void BuffModNonTargettableConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModNonTargettableConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModNonTargettableConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModNonTargettableConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModNonTargettableConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModNonTargettableConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModNonTargettableConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModNonTargettableConfig.DelayTime)
  return delaytime_;
}
inline void BuffModNonTargettableConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModNonTargettableConfig.DelayTime)
}

// repeated int32 WhiteList = 3;
inline int BuffModNonTargettableConfig::whitelist_size() const {
  return whitelist_.size();
}
inline void BuffModNonTargettableConfig::clear_whitelist() {
  whitelist_.Clear();
}
inline ::google::protobuf::int32 BuffModNonTargettableConfig::whitelist(int index) const {
  // @@protoc_insertion_point(field_get:pb.BuffModNonTargettableConfig.WhiteList)
  return whitelist_.Get(index);
}
inline void BuffModNonTargettableConfig::set_whitelist(int index, ::google::protobuf::int32 value) {
  whitelist_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.BuffModNonTargettableConfig.WhiteList)
}
inline void BuffModNonTargettableConfig::add_whitelist(::google::protobuf::int32 value) {
  whitelist_.Add(value);
  // @@protoc_insertion_point(field_add:pb.BuffModNonTargettableConfig.WhiteList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BuffModNonTargettableConfig::whitelist() const {
  // @@protoc_insertion_point(field_list:pb.BuffModNonTargettableConfig.WhiteList)
  return whitelist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BuffModNonTargettableConfig::mutable_whitelist() {
  // @@protoc_insertion_point(field_mutable_list:pb.BuffModNonTargettableConfig.WhiteList)
  return &whitelist_;
}

// -------------------------------------------------------------------

// BuffModNonHostileTargettableConfig

// optional bool Active = 1;
inline bool BuffModNonHostileTargettableConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModNonHostileTargettableConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModNonHostileTargettableConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModNonHostileTargettableConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModNonHostileTargettableConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModNonHostileTargettableConfig.Active)
  return active_;
}
inline void BuffModNonHostileTargettableConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModNonHostileTargettableConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModNonHostileTargettableConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModNonHostileTargettableConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModNonHostileTargettableConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModNonHostileTargettableConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModNonHostileTargettableConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModNonHostileTargettableConfig.DelayTime)
  return delaytime_;
}
inline void BuffModNonHostileTargettableConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModNonHostileTargettableConfig.DelayTime)
}

// -------------------------------------------------------------------

// BuffModReflectDamageConfig

// optional bool Active = 1;
inline bool BuffModReflectDamageConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModReflectDamageConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModReflectDamageConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModReflectDamageConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.Active)
  return active_;
}
inline void BuffModReflectDamageConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModReflectDamageConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModReflectDamageConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModReflectDamageConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.DelayTime)
  return delaytime_;
}
inline void BuffModReflectDamageConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.DelayTime)
}

// optional int32 ReboundType = 3;
inline bool BuffModReflectDamageConfig::has_reboundtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_reboundtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModReflectDamageConfig::clear_has_reboundtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModReflectDamageConfig::clear_reboundtype() {
  reboundtype_ = 0;
  clear_has_reboundtype();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::reboundtype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.ReboundType)
  return reboundtype_;
}
inline void BuffModReflectDamageConfig::set_reboundtype(::google::protobuf::int32 value) {
  set_has_reboundtype();
  reboundtype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.ReboundType)
}

// optional .pb.BuffDataModel ReboundData = 4;
inline bool BuffModReflectDamageConfig::has_rebounddata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_rebounddata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModReflectDamageConfig::clear_has_rebounddata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModReflectDamageConfig::clear_rebounddata() {
  if (rebounddata_ != NULL) rebounddata_->::pb::BuffDataModel::Clear();
  clear_has_rebounddata();
}
inline const ::pb::BuffDataModel& BuffModReflectDamageConfig::rebounddata() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.ReboundData)
  return rebounddata_ != NULL ? *rebounddata_ : *default_instance_->rebounddata_;
}
inline ::pb::BuffDataModel* BuffModReflectDamageConfig::mutable_rebounddata() {
  set_has_rebounddata();
  if (rebounddata_ == NULL) rebounddata_ = new ::pb::BuffDataModel;
  // @@protoc_insertion_point(field_mutable:pb.BuffModReflectDamageConfig.ReboundData)
  return rebounddata_;
}
inline ::pb::BuffDataModel* BuffModReflectDamageConfig::release_rebounddata() {
  clear_has_rebounddata();
  ::pb::BuffDataModel* temp = rebounddata_;
  rebounddata_ = NULL;
  return temp;
}
inline void BuffModReflectDamageConfig::set_allocated_rebounddata(::pb::BuffDataModel* rebounddata) {
  delete rebounddata_;
  rebounddata_ = rebounddata;
  if (rebounddata) {
    set_has_rebounddata();
  } else {
    clear_has_rebounddata();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffModReflectDamageConfig.ReboundData)
}

// optional int32 ReboundCalculateType = 5;
inline bool BuffModReflectDamageConfig::has_reboundcalculatetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_reboundcalculatetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModReflectDamageConfig::clear_has_reboundcalculatetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModReflectDamageConfig::clear_reboundcalculatetype() {
  reboundcalculatetype_ = 0;
  clear_has_reboundcalculatetype();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::reboundcalculatetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.ReboundCalculateType)
  return reboundcalculatetype_;
}
inline void BuffModReflectDamageConfig::set_reboundcalculatetype(::google::protobuf::int32 value) {
  set_has_reboundcalculatetype();
  reboundcalculatetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.ReboundCalculateType)
}

// optional int32 AttributeOriginal = 6;
inline bool BuffModReflectDamageConfig::has_attributeoriginal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_attributeoriginal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffModReflectDamageConfig::clear_has_attributeoriginal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffModReflectDamageConfig::clear_attributeoriginal() {
  attributeoriginal_ = 0;
  clear_has_attributeoriginal();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::attributeoriginal() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.AttributeOriginal)
  return attributeoriginal_;
}
inline void BuffModReflectDamageConfig::set_attributeoriginal(::google::protobuf::int32 value) {
  set_has_attributeoriginal();
  attributeoriginal_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.AttributeOriginal)
}

// optional int32 AttributeType = 7;
inline bool BuffModReflectDamageConfig::has_attributetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_attributetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuffModReflectDamageConfig::clear_has_attributetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuffModReflectDamageConfig::clear_attributetype() {
  attributetype_ = 0;
  clear_has_attributetype();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::attributetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.AttributeType)
  return attributetype_;
}
inline void BuffModReflectDamageConfig::set_attributetype(::google::protobuf::int32 value) {
  set_has_attributetype();
  attributetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.AttributeType)
}

// optional int32 AttributePercenteParam = 8;
inline bool BuffModReflectDamageConfig::has_attributepercenteparam() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_attributepercenteparam() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuffModReflectDamageConfig::clear_has_attributepercenteparam() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuffModReflectDamageConfig::clear_attributepercenteparam() {
  attributepercenteparam_ = 0;
  clear_has_attributepercenteparam();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::attributepercenteparam() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.AttributePercenteParam)
  return attributepercenteparam_;
}
inline void BuffModReflectDamageConfig::set_attributepercenteparam(::google::protobuf::int32 value) {
  set_has_attributepercenteparam();
  attributepercenteparam_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.AttributePercenteParam)
}

// optional int32 AttributePercenteGrowth = 9;
inline bool BuffModReflectDamageConfig::has_attributepercentegrowth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BuffModReflectDamageConfig::set_has_attributepercentegrowth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BuffModReflectDamageConfig::clear_has_attributepercentegrowth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BuffModReflectDamageConfig::clear_attributepercentegrowth() {
  attributepercentegrowth_ = 0;
  clear_has_attributepercentegrowth();
}
inline ::google::protobuf::int32 BuffModReflectDamageConfig::attributepercentegrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectDamageConfig.AttributePercenteGrowth)
  return attributepercentegrowth_;
}
inline void BuffModReflectDamageConfig::set_attributepercentegrowth(::google::protobuf::int32 value) {
  set_has_attributepercentegrowth();
  attributepercentegrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectDamageConfig.AttributePercenteGrowth)
}

// -------------------------------------------------------------------

// BuffModReflectSkillConfig

// optional bool Active = 1;
inline bool BuffModReflectSkillConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModReflectSkillConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModReflectSkillConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModReflectSkillConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModReflectSkillConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectSkillConfig.Active)
  return active_;
}
inline void BuffModReflectSkillConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectSkillConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModReflectSkillConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModReflectSkillConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModReflectSkillConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModReflectSkillConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModReflectSkillConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectSkillConfig.DelayTime)
  return delaytime_;
}
inline void BuffModReflectSkillConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectSkillConfig.DelayTime)
}

// optional int32 ReboundCount = 3;
inline bool BuffModReflectSkillConfig::has_reboundcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModReflectSkillConfig::set_has_reboundcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModReflectSkillConfig::clear_has_reboundcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModReflectSkillConfig::clear_reboundcount() {
  reboundcount_ = 0;
  clear_has_reboundcount();
}
inline ::google::protobuf::int32 BuffModReflectSkillConfig::reboundcount() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectSkillConfig.ReboundCount)
  return reboundcount_;
}
inline void BuffModReflectSkillConfig::set_reboundcount(::google::protobuf::int32 value) {
  set_has_reboundcount();
  reboundcount_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectSkillConfig.ReboundCount)
}

// optional int32 ReboundType = 4;
inline bool BuffModReflectSkillConfig::has_reboundtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModReflectSkillConfig::set_has_reboundtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModReflectSkillConfig::clear_has_reboundtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModReflectSkillConfig::clear_reboundtype() {
  reboundtype_ = 0;
  clear_has_reboundtype();
}
inline ::google::protobuf::int32 BuffModReflectSkillConfig::reboundtype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModReflectSkillConfig.ReboundType)
  return reboundtype_;
}
inline void BuffModReflectSkillConfig::set_reboundtype(::google::protobuf::int32 value) {
  set_has_reboundtype();
  reboundtype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModReflectSkillConfig.ReboundType)
}

// -------------------------------------------------------------------

// BuffModBuffImmunityConfig

// optional bool Active = 1;
inline bool BuffModBuffImmunityConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModBuffImmunityConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModBuffImmunityConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModBuffImmunityConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModBuffImmunityConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModBuffImmunityConfig.Active)
  return active_;
}
inline void BuffModBuffImmunityConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModBuffImmunityConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModBuffImmunityConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModBuffImmunityConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModBuffImmunityConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModBuffImmunityConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModBuffImmunityConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModBuffImmunityConfig.DelayTime)
  return delaytime_;
}
inline void BuffModBuffImmunityConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModBuffImmunityConfig.DelayTime)
}

// optional int32 PurgeType = 3;
inline bool BuffModBuffImmunityConfig::has_purgetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModBuffImmunityConfig::set_has_purgetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModBuffImmunityConfig::clear_has_purgetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModBuffImmunityConfig::clear_purgetype() {
  purgetype_ = 0;
  clear_has_purgetype();
}
inline ::google::protobuf::int32 BuffModBuffImmunityConfig::purgetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModBuffImmunityConfig.PurgeType)
  return purgetype_;
}
inline void BuffModBuffImmunityConfig::set_purgetype(::google::protobuf::int32 value) {
  set_has_purgetype();
  purgetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModBuffImmunityConfig.PurgeType)
}

// repeated int32 Data = 4;
inline int BuffModBuffImmunityConfig::data_size() const {
  return data_.size();
}
inline void BuffModBuffImmunityConfig::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 BuffModBuffImmunityConfig::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.BuffModBuffImmunityConfig.Data)
  return data_.Get(index);
}
inline void BuffModBuffImmunityConfig::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.BuffModBuffImmunityConfig.Data)
}
inline void BuffModBuffImmunityConfig::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:pb.BuffModBuffImmunityConfig.Data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BuffModBuffImmunityConfig::data() const {
  // @@protoc_insertion_point(field_list:pb.BuffModBuffImmunityConfig.Data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BuffModBuffImmunityConfig::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.BuffModBuffImmunityConfig.Data)
  return &data_;
}

// optional bool ShowHint = 5;
inline bool BuffModBuffImmunityConfig::has_showhint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModBuffImmunityConfig::set_has_showhint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModBuffImmunityConfig::clear_has_showhint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModBuffImmunityConfig::clear_showhint() {
  showhint_ = false;
  clear_has_showhint();
}
inline bool BuffModBuffImmunityConfig::showhint() const {
  // @@protoc_insertion_point(field_get:pb.BuffModBuffImmunityConfig.ShowHint)
  return showhint_;
}
inline void BuffModBuffImmunityConfig::set_showhint(bool value) {
  set_has_showhint();
  showhint_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModBuffImmunityConfig.ShowHint)
}

// -------------------------------------------------------------------

// BuffModSkillImmunityConfig

// optional bool Active = 1;
inline bool BuffModSkillImmunityConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModSkillImmunityConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModSkillImmunityConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModSkillImmunityConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModSkillImmunityConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModSkillImmunityConfig.Active)
  return active_;
}
inline void BuffModSkillImmunityConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModSkillImmunityConfig.Active)
}

// optional bool ShowHint = 2;
inline bool BuffModSkillImmunityConfig::has_showhint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModSkillImmunityConfig::set_has_showhint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModSkillImmunityConfig::clear_has_showhint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModSkillImmunityConfig::clear_showhint() {
  showhint_ = false;
  clear_has_showhint();
}
inline bool BuffModSkillImmunityConfig::showhint() const {
  // @@protoc_insertion_point(field_get:pb.BuffModSkillImmunityConfig.ShowHint)
  return showhint_;
}
inline void BuffModSkillImmunityConfig::set_showhint(bool value) {
  set_has_showhint();
  showhint_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModSkillImmunityConfig.ShowHint)
}

// optional int32 ImmuneType = 3;
inline bool BuffModSkillImmunityConfig::has_immunetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModSkillImmunityConfig::set_has_immunetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModSkillImmunityConfig::clear_has_immunetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModSkillImmunityConfig::clear_immunetype() {
  immunetype_ = 0;
  clear_has_immunetype();
}
inline ::google::protobuf::int32 BuffModSkillImmunityConfig::immunetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModSkillImmunityConfig.ImmuneType)
  return immunetype_;
}
inline void BuffModSkillImmunityConfig::set_immunetype(::google::protobuf::int32 value) {
  set_has_immunetype();
  immunetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModSkillImmunityConfig.ImmuneType)
}

// repeated int32 Data = 4;
inline int BuffModSkillImmunityConfig::data_size() const {
  return data_.size();
}
inline void BuffModSkillImmunityConfig::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 BuffModSkillImmunityConfig::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.BuffModSkillImmunityConfig.Data)
  return data_.Get(index);
}
inline void BuffModSkillImmunityConfig::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.BuffModSkillImmunityConfig.Data)
}
inline void BuffModSkillImmunityConfig::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:pb.BuffModSkillImmunityConfig.Data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BuffModSkillImmunityConfig::data() const {
  // @@protoc_insertion_point(field_list:pb.BuffModSkillImmunityConfig.Data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BuffModSkillImmunityConfig::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.BuffModSkillImmunityConfig.Data)
  return &data_;
}

// optional int32 DelayTime = 5;
inline bool BuffModSkillImmunityConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModSkillImmunityConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModSkillImmunityConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModSkillImmunityConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModSkillImmunityConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModSkillImmunityConfig.DelayTime)
  return delaytime_;
}
inline void BuffModSkillImmunityConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModSkillImmunityConfig.DelayTime)
}

// -------------------------------------------------------------------

// BuffModHitActionImmunityConfig

// optional bool Active = 1;
inline bool BuffModHitActionImmunityConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModHitActionImmunityConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModHitActionImmunityConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModHitActionImmunityConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModHitActionImmunityConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHitActionImmunityConfig.Active)
  return active_;
}
inline void BuffModHitActionImmunityConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHitActionImmunityConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModHitActionImmunityConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModHitActionImmunityConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModHitActionImmunityConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModHitActionImmunityConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModHitActionImmunityConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHitActionImmunityConfig.DelayTime)
  return delaytime_;
}
inline void BuffModHitActionImmunityConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHitActionImmunityConfig.DelayTime)
}

// -------------------------------------------------------------------

// BuffModDispelConfig

// optional bool Active = 1;
inline bool BuffModDispelConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModDispelConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModDispelConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModDispelConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModDispelConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.Active)
  return active_;
}
inline void BuffModDispelConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModDispelConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModDispelConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModDispelConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModDispelConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModDispelConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.DelayTime)
  return delaytime_;
}
inline void BuffModDispelConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.DelayTime)
}

// optional int32 CleanType = 3;
inline bool BuffModDispelConfig::has_cleantype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModDispelConfig::set_has_cleantype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModDispelConfig::clear_has_cleantype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModDispelConfig::clear_cleantype() {
  cleantype_ = 0;
  clear_has_cleantype();
}
inline ::google::protobuf::int32 BuffModDispelConfig::cleantype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.CleanType)
  return cleantype_;
}
inline void BuffModDispelConfig::set_cleantype(::google::protobuf::int32 value) {
  set_has_cleantype();
  cleantype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.CleanType)
}

// repeated int32 BuffList = 4;
inline int BuffModDispelConfig::bufflist_size() const {
  return bufflist_.size();
}
inline void BuffModDispelConfig::clear_bufflist() {
  bufflist_.Clear();
}
inline ::google::protobuf::int32 BuffModDispelConfig::bufflist(int index) const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.BuffList)
  return bufflist_.Get(index);
}
inline void BuffModDispelConfig::set_bufflist(int index, ::google::protobuf::int32 value) {
  bufflist_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.BuffList)
}
inline void BuffModDispelConfig::add_bufflist(::google::protobuf::int32 value) {
  bufflist_.Add(value);
  // @@protoc_insertion_point(field_add:pb.BuffModDispelConfig.BuffList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BuffModDispelConfig::bufflist() const {
  // @@protoc_insertion_point(field_list:pb.BuffModDispelConfig.BuffList)
  return bufflist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BuffModDispelConfig::mutable_bufflist() {
  // @@protoc_insertion_point(field_mutable_list:pb.BuffModDispelConfig.BuffList)
  return &bufflist_;
}

// optional bool IsPartof = 5;
inline bool BuffModDispelConfig::has_ispartof() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModDispelConfig::set_has_ispartof() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModDispelConfig::clear_has_ispartof() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModDispelConfig::clear_ispartof() {
  ispartof_ = false;
  clear_has_ispartof();
}
inline bool BuffModDispelConfig::ispartof() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.IsPartof)
  return ispartof_;
}
inline void BuffModDispelConfig::set_ispartof(bool value) {
  set_has_ispartof();
  ispartof_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.IsPartof)
}

// optional int32 Count = 6;
inline bool BuffModDispelConfig::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffModDispelConfig::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffModDispelConfig::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffModDispelConfig::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BuffModDispelConfig::count() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.Count)
  return count_;
}
inline void BuffModDispelConfig::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.Count)
}

// optional int32 CleanLevel = 7;
inline bool BuffModDispelConfig::has_cleanlevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuffModDispelConfig::set_has_cleanlevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuffModDispelConfig::clear_has_cleanlevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuffModDispelConfig::clear_cleanlevel() {
  cleanlevel_ = 0;
  clear_has_cleanlevel();
}
inline ::google::protobuf::int32 BuffModDispelConfig::cleanlevel() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.CleanLevel)
  return cleanlevel_;
}
inline void BuffModDispelConfig::set_cleanlevel(::google::protobuf::int32 value) {
  set_has_cleanlevel();
  cleanlevel_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.CleanLevel)
}

// optional bool IsOnNum = 8;
inline bool BuffModDispelConfig::has_isonnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuffModDispelConfig::set_has_isonnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuffModDispelConfig::clear_has_isonnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuffModDispelConfig::clear_isonnum() {
  isonnum_ = false;
  clear_has_isonnum();
}
inline bool BuffModDispelConfig::isonnum() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDispelConfig.IsOnNum)
  return isonnum_;
}
inline void BuffModDispelConfig::set_isonnum(bool value) {
  set_has_isonnum();
  isonnum_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDispelConfig.IsOnNum)
}

// -------------------------------------------------------------------

// BuffModStealHpConfig

// optional bool Active = 1;
inline bool BuffModStealHpConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModStealHpConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModStealHpConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModStealHpConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModStealHpConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModStealHpConfig.Active)
  return active_;
}
inline void BuffModStealHpConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModStealHpConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModStealHpConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModStealHpConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModStealHpConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModStealHpConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModStealHpConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModStealHpConfig.DelayTime)
  return delaytime_;
}
inline void BuffModStealHpConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModStealHpConfig.DelayTime)
}

// optional int32 StealLifeType = 3;
inline bool BuffModStealHpConfig::has_steallifetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModStealHpConfig::set_has_steallifetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModStealHpConfig::clear_has_steallifetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModStealHpConfig::clear_steallifetype() {
  steallifetype_ = 0;
  clear_has_steallifetype();
}
inline ::google::protobuf::int32 BuffModStealHpConfig::steallifetype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModStealHpConfig.StealLifeType)
  return steallifetype_;
}
inline void BuffModStealHpConfig::set_steallifetype(::google::protobuf::int32 value) {
  set_has_steallifetype();
  steallifetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModStealHpConfig.StealLifeType)
}

// optional .pb.BuffDataModel StealLifeData = 4;
inline bool BuffModStealHpConfig::has_steallifedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModStealHpConfig::set_has_steallifedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModStealHpConfig::clear_has_steallifedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModStealHpConfig::clear_steallifedata() {
  if (steallifedata_ != NULL) steallifedata_->::pb::BuffDataModel::Clear();
  clear_has_steallifedata();
}
inline const ::pb::BuffDataModel& BuffModStealHpConfig::steallifedata() const {
  // @@protoc_insertion_point(field_get:pb.BuffModStealHpConfig.StealLifeData)
  return steallifedata_ != NULL ? *steallifedata_ : *default_instance_->steallifedata_;
}
inline ::pb::BuffDataModel* BuffModStealHpConfig::mutable_steallifedata() {
  set_has_steallifedata();
  if (steallifedata_ == NULL) steallifedata_ = new ::pb::BuffDataModel;
  // @@protoc_insertion_point(field_mutable:pb.BuffModStealHpConfig.StealLifeData)
  return steallifedata_;
}
inline ::pb::BuffDataModel* BuffModStealHpConfig::release_steallifedata() {
  clear_has_steallifedata();
  ::pb::BuffDataModel* temp = steallifedata_;
  steallifedata_ = NULL;
  return temp;
}
inline void BuffModStealHpConfig::set_allocated_steallifedata(::pb::BuffDataModel* steallifedata) {
  delete steallifedata_;
  steallifedata_ = steallifedata;
  if (steallifedata) {
    set_has_steallifedata();
  } else {
    clear_has_steallifedata();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffModStealHpConfig.StealLifeData)
}

// optional int32 StealMoment = 5;
inline bool BuffModStealHpConfig::has_stealmoment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModStealHpConfig::set_has_stealmoment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModStealHpConfig::clear_has_stealmoment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModStealHpConfig::clear_stealmoment() {
  stealmoment_ = 0;
  clear_has_stealmoment();
}
inline ::google::protobuf::int32 BuffModStealHpConfig::stealmoment() const {
  // @@protoc_insertion_point(field_get:pb.BuffModStealHpConfig.StealMoment)
  return stealmoment_;
}
inline void BuffModStealHpConfig::set_stealmoment(::google::protobuf::int32 value) {
  set_has_stealmoment();
  stealmoment_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModStealHpConfig.StealMoment)
}

// repeated int32 BuffSubTypeFilter = 6;
inline int BuffModStealHpConfig::buffsubtypefilter_size() const {
  return buffsubtypefilter_.size();
}
inline void BuffModStealHpConfig::clear_buffsubtypefilter() {
  buffsubtypefilter_.Clear();
}
inline ::google::protobuf::int32 BuffModStealHpConfig::buffsubtypefilter(int index) const {
  // @@protoc_insertion_point(field_get:pb.BuffModStealHpConfig.BuffSubTypeFilter)
  return buffsubtypefilter_.Get(index);
}
inline void BuffModStealHpConfig::set_buffsubtypefilter(int index, ::google::protobuf::int32 value) {
  buffsubtypefilter_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.BuffModStealHpConfig.BuffSubTypeFilter)
}
inline void BuffModStealHpConfig::add_buffsubtypefilter(::google::protobuf::int32 value) {
  buffsubtypefilter_.Add(value);
  // @@protoc_insertion_point(field_add:pb.BuffModStealHpConfig.BuffSubTypeFilter)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BuffModStealHpConfig::buffsubtypefilter() const {
  // @@protoc_insertion_point(field_list:pb.BuffModStealHpConfig.BuffSubTypeFilter)
  return buffsubtypefilter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BuffModStealHpConfig::mutable_buffsubtypefilter() {
  // @@protoc_insertion_point(field_mutable_list:pb.BuffModStealHpConfig.BuffSubTypeFilter)
  return &buffsubtypefilter_;
}

// -------------------------------------------------------------------

// BuffModDamageShareConfig

// optional bool Active = 1;
inline bool BuffModDamageShareConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModDamageShareConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModDamageShareConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModDamageShareConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModDamageShareConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageShareConfig.Active)
  return active_;
}
inline void BuffModDamageShareConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageShareConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModDamageShareConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModDamageShareConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModDamageShareConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModDamageShareConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModDamageShareConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageShareConfig.DelayTime)
  return delaytime_;
}
inline void BuffModDamageShareConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageShareConfig.DelayTime)
}

// optional int32 PercentParam = 3;
inline bool BuffModDamageShareConfig::has_percentparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModDamageShareConfig::set_has_percentparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModDamageShareConfig::clear_has_percentparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModDamageShareConfig::clear_percentparam() {
  percentparam_ = 0;
  clear_has_percentparam();
}
inline ::google::protobuf::int32 BuffModDamageShareConfig::percentparam() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageShareConfig.PercentParam)
  return percentparam_;
}
inline void BuffModDamageShareConfig::set_percentparam(::google::protobuf::int32 value) {
  set_has_percentparam();
  percentparam_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageShareConfig.PercentParam)
}

// optional int32 PercentGrowth = 4;
inline bool BuffModDamageShareConfig::has_percentgrowth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModDamageShareConfig::set_has_percentgrowth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModDamageShareConfig::clear_has_percentgrowth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModDamageShareConfig::clear_percentgrowth() {
  percentgrowth_ = 0;
  clear_has_percentgrowth();
}
inline ::google::protobuf::int32 BuffModDamageShareConfig::percentgrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageShareConfig.PercentGrowth)
  return percentgrowth_;
}
inline void BuffModDamageShareConfig::set_percentgrowth(::google::protobuf::int32 value) {
  set_has_percentgrowth();
  percentgrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageShareConfig.PercentGrowth)
}

// -------------------------------------------------------------------

// BuffModDamageCopyConfig

// optional bool Active = 1;
inline bool BuffModDamageCopyConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModDamageCopyConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModDamageCopyConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModDamageCopyConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModDamageCopyConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageCopyConfig.Active)
  return active_;
}
inline void BuffModDamageCopyConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageCopyConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModDamageCopyConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModDamageCopyConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModDamageCopyConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModDamageCopyConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModDamageCopyConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageCopyConfig.DelayTime)
  return delaytime_;
}
inline void BuffModDamageCopyConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageCopyConfig.DelayTime)
}

// optional int32 PercentParam = 3;
inline bool BuffModDamageCopyConfig::has_percentparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModDamageCopyConfig::set_has_percentparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModDamageCopyConfig::clear_has_percentparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModDamageCopyConfig::clear_percentparam() {
  percentparam_ = 0;
  clear_has_percentparam();
}
inline ::google::protobuf::int32 BuffModDamageCopyConfig::percentparam() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageCopyConfig.PercentParam)
  return percentparam_;
}
inline void BuffModDamageCopyConfig::set_percentparam(::google::protobuf::int32 value) {
  set_has_percentparam();
  percentparam_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageCopyConfig.PercentParam)
}

// optional int32 PercentGrowth = 4;
inline bool BuffModDamageCopyConfig::has_percentgrowth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModDamageCopyConfig::set_has_percentgrowth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModDamageCopyConfig::clear_has_percentgrowth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModDamageCopyConfig::clear_percentgrowth() {
  percentgrowth_ = 0;
  clear_has_percentgrowth();
}
inline ::google::protobuf::int32 BuffModDamageCopyConfig::percentgrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageCopyConfig.PercentGrowth)
  return percentgrowth_;
}
inline void BuffModDamageCopyConfig::set_percentgrowth(::google::protobuf::int32 value) {
  set_has_percentgrowth();
  percentgrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageCopyConfig.PercentGrowth)
}

// optional bool IgnoreSelf = 5;
inline bool BuffModDamageCopyConfig::has_ignoreself() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModDamageCopyConfig::set_has_ignoreself() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModDamageCopyConfig::clear_has_ignoreself() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModDamageCopyConfig::clear_ignoreself() {
  ignoreself_ = false;
  clear_has_ignoreself();
}
inline bool BuffModDamageCopyConfig::ignoreself() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageCopyConfig.IgnoreSelf)
  return ignoreself_;
}
inline void BuffModDamageCopyConfig::set_ignoreself(bool value) {
  set_has_ignoreself();
  ignoreself_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageCopyConfig.IgnoreSelf)
}

// -------------------------------------------------------------------

// BuffModHealCopyConfig

// optional bool Active = 1;
inline bool BuffModHealCopyConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModHealCopyConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModHealCopyConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModHealCopyConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModHealCopyConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHealCopyConfig.Active)
  return active_;
}
inline void BuffModHealCopyConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHealCopyConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModHealCopyConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModHealCopyConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModHealCopyConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModHealCopyConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModHealCopyConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHealCopyConfig.DelayTime)
  return delaytime_;
}
inline void BuffModHealCopyConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHealCopyConfig.DelayTime)
}

// optional int32 PercentParam = 3;
inline bool BuffModHealCopyConfig::has_percentparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModHealCopyConfig::set_has_percentparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModHealCopyConfig::clear_has_percentparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModHealCopyConfig::clear_percentparam() {
  percentparam_ = 0;
  clear_has_percentparam();
}
inline ::google::protobuf::int32 BuffModHealCopyConfig::percentparam() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHealCopyConfig.PercentParam)
  return percentparam_;
}
inline void BuffModHealCopyConfig::set_percentparam(::google::protobuf::int32 value) {
  set_has_percentparam();
  percentparam_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHealCopyConfig.PercentParam)
}

// optional int32 PercentGrowth = 4;
inline bool BuffModHealCopyConfig::has_percentgrowth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModHealCopyConfig::set_has_percentgrowth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModHealCopyConfig::clear_has_percentgrowth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModHealCopyConfig::clear_percentgrowth() {
  percentgrowth_ = 0;
  clear_has_percentgrowth();
}
inline ::google::protobuf::int32 BuffModHealCopyConfig::percentgrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHealCopyConfig.PercentGrowth)
  return percentgrowth_;
}
inline void BuffModHealCopyConfig::set_percentgrowth(::google::protobuf::int32 value) {
  set_has_percentgrowth();
  percentgrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHealCopyConfig.PercentGrowth)
}

// -------------------------------------------------------------------

// BuffModHpConfig

// optional bool Active = 1;
inline bool BuffModHpConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModHpConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModHpConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModHpConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModHpConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.Active)
  return active_;
}
inline void BuffModHpConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModHpConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModHpConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModHpConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModHpConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModHpConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.DelayTime)
  return delaytime_;
}
inline void BuffModHpConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.DelayTime)
}

// optional int32 Count = 3;
inline bool BuffModHpConfig::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModHpConfig::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModHpConfig::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModHpConfig::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BuffModHpConfig::count() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.Count)
  return count_;
}
inline void BuffModHpConfig::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.Count)
}

// optional int32 Interval = 4;
inline bool BuffModHpConfig::has_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModHpConfig::set_has_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModHpConfig::clear_has_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModHpConfig::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline ::google::protobuf::int32 BuffModHpConfig::interval() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.Interval)
  return interval_;
}
inline void BuffModHpConfig::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.Interval)
}

// optional int32 Type = 5;
inline bool BuffModHpConfig::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModHpConfig::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModHpConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModHpConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BuffModHpConfig::type() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.Type)
  return type_;
}
inline void BuffModHpConfig::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.Type)
}

// optional .pb.BuffDatasModel Data = 7;
inline bool BuffModHpConfig::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffModHpConfig::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffModHpConfig::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffModHpConfig::clear_data() {
  if (data_ != NULL) data_->::pb::BuffDatasModel::Clear();
  clear_has_data();
}
inline const ::pb::BuffDatasModel& BuffModHpConfig::data() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.Data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pb::BuffDatasModel* BuffModHpConfig::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pb::BuffDatasModel;
  // @@protoc_insertion_point(field_mutable:pb.BuffModHpConfig.Data)
  return data_;
}
inline ::pb::BuffDatasModel* BuffModHpConfig::release_data() {
  clear_has_data();
  ::pb::BuffDatasModel* temp = data_;
  data_ = NULL;
  return temp;
}
inline void BuffModHpConfig::set_allocated_data(::pb::BuffDatasModel* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffModHpConfig.Data)
}

// optional int32 PercentGrowth = 8;
inline bool BuffModHpConfig::has_percentgrowth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuffModHpConfig::set_has_percentgrowth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuffModHpConfig::clear_has_percentgrowth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuffModHpConfig::clear_percentgrowth() {
  percentgrowth_ = 0;
  clear_has_percentgrowth();
}
inline ::google::protobuf::int32 BuffModHpConfig::percentgrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.PercentGrowth)
  return percentgrowth_;
}
inline void BuffModHpConfig::set_percentgrowth(::google::protobuf::int32 value) {
  set_has_percentgrowth();
  percentgrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.PercentGrowth)
}

// optional int32 ValueGrowth = 9;
inline bool BuffModHpConfig::has_valuegrowth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuffModHpConfig::set_has_valuegrowth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuffModHpConfig::clear_has_valuegrowth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuffModHpConfig::clear_valuegrowth() {
  valuegrowth_ = 0;
  clear_has_valuegrowth();
}
inline ::google::protobuf::int32 BuffModHpConfig::valuegrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHpConfig.ValueGrowth)
  return valuegrowth_;
}
inline void BuffModHpConfig::set_valuegrowth(::google::protobuf::int32 value) {
  set_has_valuegrowth();
  valuegrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHpConfig.ValueGrowth)
}

// -------------------------------------------------------------------

// BuffModRageConfig

// optional bool Active = 1;
inline bool BuffModRageConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModRageConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModRageConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModRageConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModRageConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.Active)
  return active_;
}
inline void BuffModRageConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModRageConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModRageConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModRageConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModRageConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModRageConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.DelayTime)
  return delaytime_;
}
inline void BuffModRageConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.DelayTime)
}

// optional int32 Count = 3;
inline bool BuffModRageConfig::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModRageConfig::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModRageConfig::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModRageConfig::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BuffModRageConfig::count() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.Count)
  return count_;
}
inline void BuffModRageConfig::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.Count)
}

// optional int32 Interval = 4;
inline bool BuffModRageConfig::has_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModRageConfig::set_has_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModRageConfig::clear_has_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModRageConfig::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline ::google::protobuf::int32 BuffModRageConfig::interval() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.Interval)
  return interval_;
}
inline void BuffModRageConfig::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.Interval)
}

// optional int32 Type = 5;
inline bool BuffModRageConfig::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModRageConfig::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModRageConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModRageConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BuffModRageConfig::type() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.Type)
  return type_;
}
inline void BuffModRageConfig::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.Type)
}

// optional .pb.BuffDatasModel Data = 6;
inline bool BuffModRageConfig::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffModRageConfig::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffModRageConfig::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffModRageConfig::clear_data() {
  if (data_ != NULL) data_->::pb::BuffDatasModel::Clear();
  clear_has_data();
}
inline const ::pb::BuffDatasModel& BuffModRageConfig::data() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.Data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pb::BuffDatasModel* BuffModRageConfig::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pb::BuffDatasModel;
  // @@protoc_insertion_point(field_mutable:pb.BuffModRageConfig.Data)
  return data_;
}
inline ::pb::BuffDatasModel* BuffModRageConfig::release_data() {
  clear_has_data();
  ::pb::BuffDatasModel* temp = data_;
  data_ = NULL;
  return temp;
}
inline void BuffModRageConfig::set_allocated_data(::pb::BuffDatasModel* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffModRageConfig.Data)
}

// optional int32 PercentGrowth = 7;
inline bool BuffModRageConfig::has_percentgrowth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuffModRageConfig::set_has_percentgrowth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuffModRageConfig::clear_has_percentgrowth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuffModRageConfig::clear_percentgrowth() {
  percentgrowth_ = 0;
  clear_has_percentgrowth();
}
inline ::google::protobuf::int32 BuffModRageConfig::percentgrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.PercentGrowth)
  return percentgrowth_;
}
inline void BuffModRageConfig::set_percentgrowth(::google::protobuf::int32 value) {
  set_has_percentgrowth();
  percentgrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.PercentGrowth)
}

// optional int32 ValueGrowth = 8;
inline bool BuffModRageConfig::has_valuegrowth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuffModRageConfig::set_has_valuegrowth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuffModRageConfig::clear_has_valuegrowth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuffModRageConfig::clear_valuegrowth() {
  valuegrowth_ = 0;
  clear_has_valuegrowth();
}
inline ::google::protobuf::int32 BuffModRageConfig::valuegrowth() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRageConfig.ValueGrowth)
  return valuegrowth_;
}
inline void BuffModRageConfig::set_valuegrowth(::google::protobuf::int32 value) {
  set_has_valuegrowth();
  valuegrowth_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRageConfig.ValueGrowth)
}

// -------------------------------------------------------------------

// BuffModRecordDataConfig

// optional bool Active = 1;
inline bool BuffModRecordDataConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModRecordDataConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModRecordDataConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModRecordDataConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModRecordDataConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRecordDataConfig.Active)
  return active_;
}
inline void BuffModRecordDataConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRecordDataConfig.Active)
}

// optional int32 DelayTime = 2;
inline bool BuffModRecordDataConfig::has_delaytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModRecordDataConfig::set_has_delaytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModRecordDataConfig::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModRecordDataConfig::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline ::google::protobuf::int32 BuffModRecordDataConfig::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRecordDataConfig.DelayTime)
  return delaytime_;
}
inline void BuffModRecordDataConfig::set_delaytime(::google::protobuf::int32 value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRecordDataConfig.DelayTime)
}

// optional int32 TypeMajor = 3;
inline bool BuffModRecordDataConfig::has_typemajor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffModRecordDataConfig::set_has_typemajor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffModRecordDataConfig::clear_has_typemajor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffModRecordDataConfig::clear_typemajor() {
  typemajor_ = 0;
  clear_has_typemajor();
}
inline ::google::protobuf::int32 BuffModRecordDataConfig::typemajor() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRecordDataConfig.TypeMajor)
  return typemajor_;
}
inline void BuffModRecordDataConfig::set_typemajor(::google::protobuf::int32 value) {
  set_has_typemajor();
  typemajor_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRecordDataConfig.TypeMajor)
}

// optional int32 TriggerBody = 4;
inline bool BuffModRecordDataConfig::has_triggerbody() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffModRecordDataConfig::set_has_triggerbody() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffModRecordDataConfig::clear_has_triggerbody() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffModRecordDataConfig::clear_triggerbody() {
  triggerbody_ = 0;
  clear_has_triggerbody();
}
inline ::google::protobuf::int32 BuffModRecordDataConfig::triggerbody() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRecordDataConfig.TriggerBody)
  return triggerbody_;
}
inline void BuffModRecordDataConfig::set_triggerbody(::google::protobuf::int32 value) {
  set_has_triggerbody();
  triggerbody_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRecordDataConfig.TriggerBody)
}

// optional int32 DataType = 5;
inline bool BuffModRecordDataConfig::has_datatype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffModRecordDataConfig::set_has_datatype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffModRecordDataConfig::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffModRecordDataConfig::clear_datatype() {
  datatype_ = 0;
  clear_has_datatype();
}
inline ::google::protobuf::int32 BuffModRecordDataConfig::datatype() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRecordDataConfig.DataType)
  return datatype_;
}
inline void BuffModRecordDataConfig::set_datatype(::google::protobuf::int32 value) {
  set_has_datatype();
  datatype_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRecordDataConfig.DataType)
}

// optional int32 TypeSub = 6;
inline bool BuffModRecordDataConfig::has_typesub() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffModRecordDataConfig::set_has_typesub() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffModRecordDataConfig::clear_has_typesub() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffModRecordDataConfig::clear_typesub() {
  typesub_ = 0;
  clear_has_typesub();
}
inline ::google::protobuf::int32 BuffModRecordDataConfig::typesub() const {
  // @@protoc_insertion_point(field_get:pb.BuffModRecordDataConfig.TypeSub)
  return typesub_;
}
inline void BuffModRecordDataConfig::set_typesub(::google::protobuf::int32 value) {
  set_has_typesub();
  typesub_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModRecordDataConfig.TypeSub)
}

// -------------------------------------------------------------------

// BuffModHarmOnMoveConfig

// optional bool Active = 1;
inline bool BuffModHarmOnMoveConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModHarmOnMoveConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModHarmOnMoveConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModHarmOnMoveConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModHarmOnMoveConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHarmOnMoveConfig.Active)
  return active_;
}
inline void BuffModHarmOnMoveConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHarmOnMoveConfig.Active)
}

// optional int32 SkillId = 2;
inline bool BuffModHarmOnMoveConfig::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModHarmOnMoveConfig::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModHarmOnMoveConfig::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModHarmOnMoveConfig::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 BuffModHarmOnMoveConfig::skillid() const {
  // @@protoc_insertion_point(field_get:pb.BuffModHarmOnMoveConfig.SkillId)
  return skillid_;
}
inline void BuffModHarmOnMoveConfig::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModHarmOnMoveConfig.SkillId)
}

// -------------------------------------------------------------------

// BuffModDamageImmunityConfig

// optional bool Active = 1;
inline bool BuffModDamageImmunityConfig::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffModDamageImmunityConfig::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffModDamageImmunityConfig::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffModDamageImmunityConfig::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool BuffModDamageImmunityConfig::active() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageImmunityConfig.Active)
  return active_;
}
inline void BuffModDamageImmunityConfig::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageImmunityConfig.Active)
}

// optional int32 Type = 2;
inline bool BuffModDamageImmunityConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffModDamageImmunityConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffModDamageImmunityConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffModDamageImmunityConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BuffModDamageImmunityConfig::type() const {
  // @@protoc_insertion_point(field_get:pb.BuffModDamageImmunityConfig.Type)
  return type_;
}
inline void BuffModDamageImmunityConfig::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffModDamageImmunityConfig.Type)
}

// -------------------------------------------------------------------

// BuffData

// optional int32 Id = 1;
inline bool BuffData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BuffData::id() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.Id)
  return id_;
}
inline void BuffData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.BuffData.Id)
}

// optional .pb.BuffBaseDataModel BaseDataModel = 2;
inline bool BuffData::has_basedatamodel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffData::set_has_basedatamodel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffData::clear_has_basedatamodel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffData::clear_basedatamodel() {
  if (basedatamodel_ != NULL) basedatamodel_->::pb::BuffBaseDataModel::Clear();
  clear_has_basedatamodel();
}
inline const ::pb::BuffBaseDataModel& BuffData::basedatamodel() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BaseDataModel)
  return basedatamodel_ != NULL ? *basedatamodel_ : *default_instance_->basedatamodel_;
}
inline ::pb::BuffBaseDataModel* BuffData::mutable_basedatamodel() {
  set_has_basedatamodel();
  if (basedatamodel_ == NULL) basedatamodel_ = new ::pb::BuffBaseDataModel;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BaseDataModel)
  return basedatamodel_;
}
inline ::pb::BuffBaseDataModel* BuffData::release_basedatamodel() {
  clear_has_basedatamodel();
  ::pb::BuffBaseDataModel* temp = basedatamodel_;
  basedatamodel_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_basedatamodel(::pb::BuffBaseDataModel* basedatamodel) {
  delete basedatamodel_;
  basedatamodel_ = basedatamodel;
  if (basedatamodel) {
    set_has_basedatamodel();
  } else {
    clear_has_basedatamodel();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BaseDataModel)
}

// optional .pb.SpecialHitModel SpecialHitModel = 3;
inline bool BuffData::has_specialhitmodel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffData::set_has_specialhitmodel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffData::clear_has_specialhitmodel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffData::clear_specialhitmodel() {
  if (specialhitmodel_ != NULL) specialhitmodel_->::pb::SpecialHitModel::Clear();
  clear_has_specialhitmodel();
}
inline const ::pb::SpecialHitModel& BuffData::specialhitmodel() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.SpecialHitModel)
  return specialhitmodel_ != NULL ? *specialhitmodel_ : *default_instance_->specialhitmodel_;
}
inline ::pb::SpecialHitModel* BuffData::mutable_specialhitmodel() {
  set_has_specialhitmodel();
  if (specialhitmodel_ == NULL) specialhitmodel_ = new ::pb::SpecialHitModel;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.SpecialHitModel)
  return specialhitmodel_;
}
inline ::pb::SpecialHitModel* BuffData::release_specialhitmodel() {
  clear_has_specialhitmodel();
  ::pb::SpecialHitModel* temp = specialhitmodel_;
  specialhitmodel_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_specialhitmodel(::pb::SpecialHitModel* specialhitmodel) {
  delete specialhitmodel_;
  specialhitmodel_ = specialhitmodel;
  if (specialhitmodel) {
    set_has_specialhitmodel();
  } else {
    clear_has_specialhitmodel();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.SpecialHitModel)
}

// optional .pb.BuffModHpConfig BuffModHpConfig = 27;
inline bool BuffData::has_buffmodhpconfig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffData::set_has_buffmodhpconfig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffData::clear_has_buffmodhpconfig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffData::clear_buffmodhpconfig() {
  if (buffmodhpconfig_ != NULL) buffmodhpconfig_->::pb::BuffModHpConfig::Clear();
  clear_has_buffmodhpconfig();
}
inline const ::pb::BuffModHpConfig& BuffData::buffmodhpconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModHpConfig)
  return buffmodhpconfig_ != NULL ? *buffmodhpconfig_ : *default_instance_->buffmodhpconfig_;
}
inline ::pb::BuffModHpConfig* BuffData::mutable_buffmodhpconfig() {
  set_has_buffmodhpconfig();
  if (buffmodhpconfig_ == NULL) buffmodhpconfig_ = new ::pb::BuffModHpConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModHpConfig)
  return buffmodhpconfig_;
}
inline ::pb::BuffModHpConfig* BuffData::release_buffmodhpconfig() {
  clear_has_buffmodhpconfig();
  ::pb::BuffModHpConfig* temp = buffmodhpconfig_;
  buffmodhpconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodhpconfig(::pb::BuffModHpConfig* buffmodhpconfig) {
  delete buffmodhpconfig_;
  buffmodhpconfig_ = buffmodhpconfig;
  if (buffmodhpconfig) {
    set_has_buffmodhpconfig();
  } else {
    clear_has_buffmodhpconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModHpConfig)
}

// optional .pb.BuffModReflectDamageConfig BuffModReflectDamageConfig = 17;
inline bool BuffData::has_buffmodreflectdamageconfig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffData::set_has_buffmodreflectdamageconfig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffData::clear_has_buffmodreflectdamageconfig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffData::clear_buffmodreflectdamageconfig() {
  if (buffmodreflectdamageconfig_ != NULL) buffmodreflectdamageconfig_->::pb::BuffModReflectDamageConfig::Clear();
  clear_has_buffmodreflectdamageconfig();
}
inline const ::pb::BuffModReflectDamageConfig& BuffData::buffmodreflectdamageconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModReflectDamageConfig)
  return buffmodreflectdamageconfig_ != NULL ? *buffmodreflectdamageconfig_ : *default_instance_->buffmodreflectdamageconfig_;
}
inline ::pb::BuffModReflectDamageConfig* BuffData::mutable_buffmodreflectdamageconfig() {
  set_has_buffmodreflectdamageconfig();
  if (buffmodreflectdamageconfig_ == NULL) buffmodreflectdamageconfig_ = new ::pb::BuffModReflectDamageConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModReflectDamageConfig)
  return buffmodreflectdamageconfig_;
}
inline ::pb::BuffModReflectDamageConfig* BuffData::release_buffmodreflectdamageconfig() {
  clear_has_buffmodreflectdamageconfig();
  ::pb::BuffModReflectDamageConfig* temp = buffmodreflectdamageconfig_;
  buffmodreflectdamageconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodreflectdamageconfig(::pb::BuffModReflectDamageConfig* buffmodreflectdamageconfig) {
  delete buffmodreflectdamageconfig_;
  buffmodreflectdamageconfig_ = buffmodreflectdamageconfig;
  if (buffmodreflectdamageconfig) {
    set_has_buffmodreflectdamageconfig();
  } else {
    clear_has_buffmodreflectdamageconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModReflectDamageConfig)
}

// optional .pb.BuffModReflectSkillConfig BuffModReflectSkillConfig = 18;
inline bool BuffData::has_buffmodreflectskillconfig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuffData::set_has_buffmodreflectskillconfig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuffData::clear_has_buffmodreflectskillconfig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuffData::clear_buffmodreflectskillconfig() {
  if (buffmodreflectskillconfig_ != NULL) buffmodreflectskillconfig_->::pb::BuffModReflectSkillConfig::Clear();
  clear_has_buffmodreflectskillconfig();
}
inline const ::pb::BuffModReflectSkillConfig& BuffData::buffmodreflectskillconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModReflectSkillConfig)
  return buffmodreflectskillconfig_ != NULL ? *buffmodreflectskillconfig_ : *default_instance_->buffmodreflectskillconfig_;
}
inline ::pb::BuffModReflectSkillConfig* BuffData::mutable_buffmodreflectskillconfig() {
  set_has_buffmodreflectskillconfig();
  if (buffmodreflectskillconfig_ == NULL) buffmodreflectskillconfig_ = new ::pb::BuffModReflectSkillConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModReflectSkillConfig)
  return buffmodreflectskillconfig_;
}
inline ::pb::BuffModReflectSkillConfig* BuffData::release_buffmodreflectskillconfig() {
  clear_has_buffmodreflectskillconfig();
  ::pb::BuffModReflectSkillConfig* temp = buffmodreflectskillconfig_;
  buffmodreflectskillconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodreflectskillconfig(::pb::BuffModReflectSkillConfig* buffmodreflectskillconfig) {
  delete buffmodreflectskillconfig_;
  buffmodreflectskillconfig_ = buffmodreflectskillconfig;
  if (buffmodreflectskillconfig) {
    set_has_buffmodreflectskillconfig();
  } else {
    clear_has_buffmodreflectskillconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModReflectSkillConfig)
}

// optional .pb.BuffModBuffImmunityConfig BuffModBuffImmunityConfig = 19;
inline bool BuffData::has_buffmodbuffimmunityconfig() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuffData::set_has_buffmodbuffimmunityconfig() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuffData::clear_has_buffmodbuffimmunityconfig() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuffData::clear_buffmodbuffimmunityconfig() {
  if (buffmodbuffimmunityconfig_ != NULL) buffmodbuffimmunityconfig_->::pb::BuffModBuffImmunityConfig::Clear();
  clear_has_buffmodbuffimmunityconfig();
}
inline const ::pb::BuffModBuffImmunityConfig& BuffData::buffmodbuffimmunityconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModBuffImmunityConfig)
  return buffmodbuffimmunityconfig_ != NULL ? *buffmodbuffimmunityconfig_ : *default_instance_->buffmodbuffimmunityconfig_;
}
inline ::pb::BuffModBuffImmunityConfig* BuffData::mutable_buffmodbuffimmunityconfig() {
  set_has_buffmodbuffimmunityconfig();
  if (buffmodbuffimmunityconfig_ == NULL) buffmodbuffimmunityconfig_ = new ::pb::BuffModBuffImmunityConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModBuffImmunityConfig)
  return buffmodbuffimmunityconfig_;
}
inline ::pb::BuffModBuffImmunityConfig* BuffData::release_buffmodbuffimmunityconfig() {
  clear_has_buffmodbuffimmunityconfig();
  ::pb::BuffModBuffImmunityConfig* temp = buffmodbuffimmunityconfig_;
  buffmodbuffimmunityconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodbuffimmunityconfig(::pb::BuffModBuffImmunityConfig* buffmodbuffimmunityconfig) {
  delete buffmodbuffimmunityconfig_;
  buffmodbuffimmunityconfig_ = buffmodbuffimmunityconfig;
  if (buffmodbuffimmunityconfig) {
    set_has_buffmodbuffimmunityconfig();
  } else {
    clear_has_buffmodbuffimmunityconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModBuffImmunityConfig)
}

// optional .pb.BuffModPropertyConfig BuffModPropertyConfig = 36;
inline bool BuffData::has_buffmodpropertyconfig() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuffData::set_has_buffmodpropertyconfig() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuffData::clear_has_buffmodpropertyconfig() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuffData::clear_buffmodpropertyconfig() {
  if (buffmodpropertyconfig_ != NULL) buffmodpropertyconfig_->::pb::BuffModPropertyConfig::Clear();
  clear_has_buffmodpropertyconfig();
}
inline const ::pb::BuffModPropertyConfig& BuffData::buffmodpropertyconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModPropertyConfig)
  return buffmodpropertyconfig_ != NULL ? *buffmodpropertyconfig_ : *default_instance_->buffmodpropertyconfig_;
}
inline ::pb::BuffModPropertyConfig* BuffData::mutable_buffmodpropertyconfig() {
  set_has_buffmodpropertyconfig();
  if (buffmodpropertyconfig_ == NULL) buffmodpropertyconfig_ = new ::pb::BuffModPropertyConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModPropertyConfig)
  return buffmodpropertyconfig_;
}
inline ::pb::BuffModPropertyConfig* BuffData::release_buffmodpropertyconfig() {
  clear_has_buffmodpropertyconfig();
  ::pb::BuffModPropertyConfig* temp = buffmodpropertyconfig_;
  buffmodpropertyconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodpropertyconfig(::pb::BuffModPropertyConfig* buffmodpropertyconfig) {
  delete buffmodpropertyconfig_;
  buffmodpropertyconfig_ = buffmodpropertyconfig;
  if (buffmodpropertyconfig) {
    set_has_buffmodpropertyconfig();
  } else {
    clear_has_buffmodpropertyconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModPropertyConfig)
}

// optional .pb.BuffModAttackSpeedConfig BuffModAttackSpeedConfig = 6;
inline bool BuffData::has_buffmodattackspeedconfig() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BuffData::set_has_buffmodattackspeedconfig() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BuffData::clear_has_buffmodattackspeedconfig() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BuffData::clear_buffmodattackspeedconfig() {
  if (buffmodattackspeedconfig_ != NULL) buffmodattackspeedconfig_->::pb::BuffModAttackSpeedConfig::Clear();
  clear_has_buffmodattackspeedconfig();
}
inline const ::pb::BuffModAttackSpeedConfig& BuffData::buffmodattackspeedconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModAttackSpeedConfig)
  return buffmodattackspeedconfig_ != NULL ? *buffmodattackspeedconfig_ : *default_instance_->buffmodattackspeedconfig_;
}
inline ::pb::BuffModAttackSpeedConfig* BuffData::mutable_buffmodattackspeedconfig() {
  set_has_buffmodattackspeedconfig();
  if (buffmodattackspeedconfig_ == NULL) buffmodattackspeedconfig_ = new ::pb::BuffModAttackSpeedConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModAttackSpeedConfig)
  return buffmodattackspeedconfig_;
}
inline ::pb::BuffModAttackSpeedConfig* BuffData::release_buffmodattackspeedconfig() {
  clear_has_buffmodattackspeedconfig();
  ::pb::BuffModAttackSpeedConfig* temp = buffmodattackspeedconfig_;
  buffmodattackspeedconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodattackspeedconfig(::pb::BuffModAttackSpeedConfig* buffmodattackspeedconfig) {
  delete buffmodattackspeedconfig_;
  buffmodattackspeedconfig_ = buffmodattackspeedconfig;
  if (buffmodattackspeedconfig) {
    set_has_buffmodattackspeedconfig();
  } else {
    clear_has_buffmodattackspeedconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModAttackSpeedConfig)
}

// optional .pb.BuffModRageConfig BuffModRageConfig = 28;
inline bool BuffData::has_buffmodrageconfig() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BuffData::set_has_buffmodrageconfig() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BuffData::clear_has_buffmodrageconfig() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BuffData::clear_buffmodrageconfig() {
  if (buffmodrageconfig_ != NULL) buffmodrageconfig_->::pb::BuffModRageConfig::Clear();
  clear_has_buffmodrageconfig();
}
inline const ::pb::BuffModRageConfig& BuffData::buffmodrageconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRageConfig)
  return buffmodrageconfig_ != NULL ? *buffmodrageconfig_ : *default_instance_->buffmodrageconfig_;
}
inline ::pb::BuffModRageConfig* BuffData::mutable_buffmodrageconfig() {
  set_has_buffmodrageconfig();
  if (buffmodrageconfig_ == NULL) buffmodrageconfig_ = new ::pb::BuffModRageConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRageConfig)
  return buffmodrageconfig_;
}
inline ::pb::BuffModRageConfig* BuffData::release_buffmodrageconfig() {
  clear_has_buffmodrageconfig();
  ::pb::BuffModRageConfig* temp = buffmodrageconfig_;
  buffmodrageconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodrageconfig(::pb::BuffModRageConfig* buffmodrageconfig) {
  delete buffmodrageconfig_;
  buffmodrageconfig_ = buffmodrageconfig;
  if (buffmodrageconfig) {
    set_has_buffmodrageconfig();
  } else {
    clear_has_buffmodrageconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRageConfig)
}

// optional .pb.BuffModAbsorbDamageConfig BuffModAbsorbDamageConfig = 14;
inline bool BuffData::has_buffmodabsorbdamageconfig() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BuffData::set_has_buffmodabsorbdamageconfig() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BuffData::clear_has_buffmodabsorbdamageconfig() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BuffData::clear_buffmodabsorbdamageconfig() {
  if (buffmodabsorbdamageconfig_ != NULL) buffmodabsorbdamageconfig_->::pb::BuffModAbsorbDamageConfig::Clear();
  clear_has_buffmodabsorbdamageconfig();
}
inline const ::pb::BuffModAbsorbDamageConfig& BuffData::buffmodabsorbdamageconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModAbsorbDamageConfig)
  return buffmodabsorbdamageconfig_ != NULL ? *buffmodabsorbdamageconfig_ : *default_instance_->buffmodabsorbdamageconfig_;
}
inline ::pb::BuffModAbsorbDamageConfig* BuffData::mutable_buffmodabsorbdamageconfig() {
  set_has_buffmodabsorbdamageconfig();
  if (buffmodabsorbdamageconfig_ == NULL) buffmodabsorbdamageconfig_ = new ::pb::BuffModAbsorbDamageConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModAbsorbDamageConfig)
  return buffmodabsorbdamageconfig_;
}
inline ::pb::BuffModAbsorbDamageConfig* BuffData::release_buffmodabsorbdamageconfig() {
  clear_has_buffmodabsorbdamageconfig();
  ::pb::BuffModAbsorbDamageConfig* temp = buffmodabsorbdamageconfig_;
  buffmodabsorbdamageconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodabsorbdamageconfig(::pb::BuffModAbsorbDamageConfig* buffmodabsorbdamageconfig) {
  delete buffmodabsorbdamageconfig_;
  buffmodabsorbdamageconfig_ = buffmodabsorbdamageconfig;
  if (buffmodabsorbdamageconfig) {
    set_has_buffmodabsorbdamageconfig();
  } else {
    clear_has_buffmodabsorbdamageconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModAbsorbDamageConfig)
}

// optional .pb.BuffModNonHostileTargettableConfig BuffModNonHostileTargettableConfig = 37;
inline bool BuffData::has_buffmodnonhostiletargettableconfig() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BuffData::set_has_buffmodnonhostiletargettableconfig() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BuffData::clear_has_buffmodnonhostiletargettableconfig() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BuffData::clear_buffmodnonhostiletargettableconfig() {
  if (buffmodnonhostiletargettableconfig_ != NULL) buffmodnonhostiletargettableconfig_->::pb::BuffModNonHostileTargettableConfig::Clear();
  clear_has_buffmodnonhostiletargettableconfig();
}
inline const ::pb::BuffModNonHostileTargettableConfig& BuffData::buffmodnonhostiletargettableconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNonHostileTargettableConfig)
  return buffmodnonhostiletargettableconfig_ != NULL ? *buffmodnonhostiletargettableconfig_ : *default_instance_->buffmodnonhostiletargettableconfig_;
}
inline ::pb::BuffModNonHostileTargettableConfig* BuffData::mutable_buffmodnonhostiletargettableconfig() {
  set_has_buffmodnonhostiletargettableconfig();
  if (buffmodnonhostiletargettableconfig_ == NULL) buffmodnonhostiletargettableconfig_ = new ::pb::BuffModNonHostileTargettableConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNonHostileTargettableConfig)
  return buffmodnonhostiletargettableconfig_;
}
inline ::pb::BuffModNonHostileTargettableConfig* BuffData::release_buffmodnonhostiletargettableconfig() {
  clear_has_buffmodnonhostiletargettableconfig();
  ::pb::BuffModNonHostileTargettableConfig* temp = buffmodnonhostiletargettableconfig_;
  buffmodnonhostiletargettableconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnonhostiletargettableconfig(::pb::BuffModNonHostileTargettableConfig* buffmodnonhostiletargettableconfig) {
  delete buffmodnonhostiletargettableconfig_;
  buffmodnonhostiletargettableconfig_ = buffmodnonhostiletargettableconfig;
  if (buffmodnonhostiletargettableconfig) {
    set_has_buffmodnonhostiletargettableconfig();
  } else {
    clear_has_buffmodnonhostiletargettableconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNonHostileTargettableConfig)
}

// optional .pb.BuffModNonTargettableConfig BuffModNonTargettableConfig = 16;
inline bool BuffData::has_buffmodnontargettableconfig() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BuffData::set_has_buffmodnontargettableconfig() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BuffData::clear_has_buffmodnontargettableconfig() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BuffData::clear_buffmodnontargettableconfig() {
  if (buffmodnontargettableconfig_ != NULL) buffmodnontargettableconfig_->::pb::BuffModNonTargettableConfig::Clear();
  clear_has_buffmodnontargettableconfig();
}
inline const ::pb::BuffModNonTargettableConfig& BuffData::buffmodnontargettableconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNonTargettableConfig)
  return buffmodnontargettableconfig_ != NULL ? *buffmodnontargettableconfig_ : *default_instance_->buffmodnontargettableconfig_;
}
inline ::pb::BuffModNonTargettableConfig* BuffData::mutable_buffmodnontargettableconfig() {
  set_has_buffmodnontargettableconfig();
  if (buffmodnontargettableconfig_ == NULL) buffmodnontargettableconfig_ = new ::pb::BuffModNonTargettableConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNonTargettableConfig)
  return buffmodnontargettableconfig_;
}
inline ::pb::BuffModNonTargettableConfig* BuffData::release_buffmodnontargettableconfig() {
  clear_has_buffmodnontargettableconfig();
  ::pb::BuffModNonTargettableConfig* temp = buffmodnontargettableconfig_;
  buffmodnontargettableconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnontargettableconfig(::pb::BuffModNonTargettableConfig* buffmodnontargettableconfig) {
  delete buffmodnontargettableconfig_;
  buffmodnontargettableconfig_ = buffmodnontargettableconfig;
  if (buffmodnontargettableconfig) {
    set_has_buffmodnontargettableconfig();
  } else {
    clear_has_buffmodnontargettableconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNonTargettableConfig)
}

// optional .pb.BuffModDamageShareConfig BuffModDamageShareConfig = 24;
inline bool BuffData::has_buffmoddamageshareconfig() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BuffData::set_has_buffmoddamageshareconfig() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BuffData::clear_has_buffmoddamageshareconfig() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BuffData::clear_buffmoddamageshareconfig() {
  if (buffmoddamageshareconfig_ != NULL) buffmoddamageshareconfig_->::pb::BuffModDamageShareConfig::Clear();
  clear_has_buffmoddamageshareconfig();
}
inline const ::pb::BuffModDamageShareConfig& BuffData::buffmoddamageshareconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDamageShareConfig)
  return buffmoddamageshareconfig_ != NULL ? *buffmoddamageshareconfig_ : *default_instance_->buffmoddamageshareconfig_;
}
inline ::pb::BuffModDamageShareConfig* BuffData::mutable_buffmoddamageshareconfig() {
  set_has_buffmoddamageshareconfig();
  if (buffmoddamageshareconfig_ == NULL) buffmoddamageshareconfig_ = new ::pb::BuffModDamageShareConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDamageShareConfig)
  return buffmoddamageshareconfig_;
}
inline ::pb::BuffModDamageShareConfig* BuffData::release_buffmoddamageshareconfig() {
  clear_has_buffmoddamageshareconfig();
  ::pb::BuffModDamageShareConfig* temp = buffmoddamageshareconfig_;
  buffmoddamageshareconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddamageshareconfig(::pb::BuffModDamageShareConfig* buffmoddamageshareconfig) {
  delete buffmoddamageshareconfig_;
  buffmoddamageshareconfig_ = buffmoddamageshareconfig;
  if (buffmoddamageshareconfig) {
    set_has_buffmoddamageshareconfig();
  } else {
    clear_has_buffmoddamageshareconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDamageShareConfig)
}

// optional .pb.BuffModHealCopyConfig BuffModHealCopyConfig = 26;
inline bool BuffData::has_buffmodhealcopyconfig() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BuffData::set_has_buffmodhealcopyconfig() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BuffData::clear_has_buffmodhealcopyconfig() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BuffData::clear_buffmodhealcopyconfig() {
  if (buffmodhealcopyconfig_ != NULL) buffmodhealcopyconfig_->::pb::BuffModHealCopyConfig::Clear();
  clear_has_buffmodhealcopyconfig();
}
inline const ::pb::BuffModHealCopyConfig& BuffData::buffmodhealcopyconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModHealCopyConfig)
  return buffmodhealcopyconfig_ != NULL ? *buffmodhealcopyconfig_ : *default_instance_->buffmodhealcopyconfig_;
}
inline ::pb::BuffModHealCopyConfig* BuffData::mutable_buffmodhealcopyconfig() {
  set_has_buffmodhealcopyconfig();
  if (buffmodhealcopyconfig_ == NULL) buffmodhealcopyconfig_ = new ::pb::BuffModHealCopyConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModHealCopyConfig)
  return buffmodhealcopyconfig_;
}
inline ::pb::BuffModHealCopyConfig* BuffData::release_buffmodhealcopyconfig() {
  clear_has_buffmodhealcopyconfig();
  ::pb::BuffModHealCopyConfig* temp = buffmodhealcopyconfig_;
  buffmodhealcopyconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodhealcopyconfig(::pb::BuffModHealCopyConfig* buffmodhealcopyconfig) {
  delete buffmodhealcopyconfig_;
  buffmodhealcopyconfig_ = buffmodhealcopyconfig;
  if (buffmodhealcopyconfig) {
    set_has_buffmodhealcopyconfig();
  } else {
    clear_has_buffmodhealcopyconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModHealCopyConfig)
}

// optional .pb.BuffModStealHpConfig BuffModStealHpConfig = 21;
inline bool BuffData::has_buffmodstealhpconfig() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BuffData::set_has_buffmodstealhpconfig() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BuffData::clear_has_buffmodstealhpconfig() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BuffData::clear_buffmodstealhpconfig() {
  if (buffmodstealhpconfig_ != NULL) buffmodstealhpconfig_->::pb::BuffModStealHpConfig::Clear();
  clear_has_buffmodstealhpconfig();
}
inline const ::pb::BuffModStealHpConfig& BuffData::buffmodstealhpconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModStealHpConfig)
  return buffmodstealhpconfig_ != NULL ? *buffmodstealhpconfig_ : *default_instance_->buffmodstealhpconfig_;
}
inline ::pb::BuffModStealHpConfig* BuffData::mutable_buffmodstealhpconfig() {
  set_has_buffmodstealhpconfig();
  if (buffmodstealhpconfig_ == NULL) buffmodstealhpconfig_ = new ::pb::BuffModStealHpConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModStealHpConfig)
  return buffmodstealhpconfig_;
}
inline ::pb::BuffModStealHpConfig* BuffData::release_buffmodstealhpconfig() {
  clear_has_buffmodstealhpconfig();
  ::pb::BuffModStealHpConfig* temp = buffmodstealhpconfig_;
  buffmodstealhpconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodstealhpconfig(::pb::BuffModStealHpConfig* buffmodstealhpconfig) {
  delete buffmodstealhpconfig_;
  buffmodstealhpconfig_ = buffmodstealhpconfig;
  if (buffmodstealhpconfig) {
    set_has_buffmodstealhpconfig();
  } else {
    clear_has_buffmodstealhpconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModStealHpConfig)
}

// optional .pb.BuffModSkillImmunityConfig BuffModSkillImmunityConfig = 34;
inline bool BuffData::has_buffmodskillimmunityconfig() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BuffData::set_has_buffmodskillimmunityconfig() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BuffData::clear_has_buffmodskillimmunityconfig() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BuffData::clear_buffmodskillimmunityconfig() {
  if (buffmodskillimmunityconfig_ != NULL) buffmodskillimmunityconfig_->::pb::BuffModSkillImmunityConfig::Clear();
  clear_has_buffmodskillimmunityconfig();
}
inline const ::pb::BuffModSkillImmunityConfig& BuffData::buffmodskillimmunityconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModSkillImmunityConfig)
  return buffmodskillimmunityconfig_ != NULL ? *buffmodskillimmunityconfig_ : *default_instance_->buffmodskillimmunityconfig_;
}
inline ::pb::BuffModSkillImmunityConfig* BuffData::mutable_buffmodskillimmunityconfig() {
  set_has_buffmodskillimmunityconfig();
  if (buffmodskillimmunityconfig_ == NULL) buffmodskillimmunityconfig_ = new ::pb::BuffModSkillImmunityConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModSkillImmunityConfig)
  return buffmodskillimmunityconfig_;
}
inline ::pb::BuffModSkillImmunityConfig* BuffData::release_buffmodskillimmunityconfig() {
  clear_has_buffmodskillimmunityconfig();
  ::pb::BuffModSkillImmunityConfig* temp = buffmodskillimmunityconfig_;
  buffmodskillimmunityconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodskillimmunityconfig(::pb::BuffModSkillImmunityConfig* buffmodskillimmunityconfig) {
  delete buffmodskillimmunityconfig_;
  buffmodskillimmunityconfig_ = buffmodskillimmunityconfig;
  if (buffmodskillimmunityconfig) {
    set_has_buffmodskillimmunityconfig();
  } else {
    clear_has_buffmodskillimmunityconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModSkillImmunityConfig)
}

// optional .pb.BuffModToughnessConfig BuffModToughnessConfig = 35;
inline bool BuffData::has_buffmodtoughnessconfig() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BuffData::set_has_buffmodtoughnessconfig() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BuffData::clear_has_buffmodtoughnessconfig() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BuffData::clear_buffmodtoughnessconfig() {
  if (buffmodtoughnessconfig_ != NULL) buffmodtoughnessconfig_->::pb::BuffModToughnessConfig::Clear();
  clear_has_buffmodtoughnessconfig();
}
inline const ::pb::BuffModToughnessConfig& BuffData::buffmodtoughnessconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModToughnessConfig)
  return buffmodtoughnessconfig_ != NULL ? *buffmodtoughnessconfig_ : *default_instance_->buffmodtoughnessconfig_;
}
inline ::pb::BuffModToughnessConfig* BuffData::mutable_buffmodtoughnessconfig() {
  set_has_buffmodtoughnessconfig();
  if (buffmodtoughnessconfig_ == NULL) buffmodtoughnessconfig_ = new ::pb::BuffModToughnessConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModToughnessConfig)
  return buffmodtoughnessconfig_;
}
inline ::pb::BuffModToughnessConfig* BuffData::release_buffmodtoughnessconfig() {
  clear_has_buffmodtoughnessconfig();
  ::pb::BuffModToughnessConfig* temp = buffmodtoughnessconfig_;
  buffmodtoughnessconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtoughnessconfig(::pb::BuffModToughnessConfig* buffmodtoughnessconfig) {
  delete buffmodtoughnessconfig_;
  buffmodtoughnessconfig_ = buffmodtoughnessconfig;
  if (buffmodtoughnessconfig) {
    set_has_buffmodtoughnessconfig();
  } else {
    clear_has_buffmodtoughnessconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModToughnessConfig)
}

// optional .pb.BuffModDispelConfig BuffModDispelConfig = 33;
inline bool BuffData::has_buffmoddispelconfig() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BuffData::set_has_buffmoddispelconfig() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BuffData::clear_has_buffmoddispelconfig() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BuffData::clear_buffmoddispelconfig() {
  if (buffmoddispelconfig_ != NULL) buffmoddispelconfig_->::pb::BuffModDispelConfig::Clear();
  clear_has_buffmoddispelconfig();
}
inline const ::pb::BuffModDispelConfig& BuffData::buffmoddispelconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDispelConfig)
  return buffmoddispelconfig_ != NULL ? *buffmoddispelconfig_ : *default_instance_->buffmoddispelconfig_;
}
inline ::pb::BuffModDispelConfig* BuffData::mutable_buffmoddispelconfig() {
  set_has_buffmoddispelconfig();
  if (buffmoddispelconfig_ == NULL) buffmoddispelconfig_ = new ::pb::BuffModDispelConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDispelConfig)
  return buffmoddispelconfig_;
}
inline ::pb::BuffModDispelConfig* BuffData::release_buffmoddispelconfig() {
  clear_has_buffmoddispelconfig();
  ::pb::BuffModDispelConfig* temp = buffmoddispelconfig_;
  buffmoddispelconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddispelconfig(::pb::BuffModDispelConfig* buffmoddispelconfig) {
  delete buffmoddispelconfig_;
  buffmoddispelconfig_ = buffmoddispelconfig;
  if (buffmoddispelconfig) {
    set_has_buffmoddispelconfig();
  } else {
    clear_has_buffmoddispelconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDispelConfig)
}

// optional .pb.BuffModDamageImmunityConfig BuffModDamageImmunityConfig = 41;
inline bool BuffData::has_buffmoddamageimmunityconfig() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BuffData::set_has_buffmoddamageimmunityconfig() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BuffData::clear_has_buffmoddamageimmunityconfig() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BuffData::clear_buffmoddamageimmunityconfig() {
  if (buffmoddamageimmunityconfig_ != NULL) buffmoddamageimmunityconfig_->::pb::BuffModDamageImmunityConfig::Clear();
  clear_has_buffmoddamageimmunityconfig();
}
inline const ::pb::BuffModDamageImmunityConfig& BuffData::buffmoddamageimmunityconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDamageImmunityConfig)
  return buffmoddamageimmunityconfig_ != NULL ? *buffmoddamageimmunityconfig_ : *default_instance_->buffmoddamageimmunityconfig_;
}
inline ::pb::BuffModDamageImmunityConfig* BuffData::mutable_buffmoddamageimmunityconfig() {
  set_has_buffmoddamageimmunityconfig();
  if (buffmoddamageimmunityconfig_ == NULL) buffmoddamageimmunityconfig_ = new ::pb::BuffModDamageImmunityConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDamageImmunityConfig)
  return buffmoddamageimmunityconfig_;
}
inline ::pb::BuffModDamageImmunityConfig* BuffData::release_buffmoddamageimmunityconfig() {
  clear_has_buffmoddamageimmunityconfig();
  ::pb::BuffModDamageImmunityConfig* temp = buffmoddamageimmunityconfig_;
  buffmoddamageimmunityconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddamageimmunityconfig(::pb::BuffModDamageImmunityConfig* buffmoddamageimmunityconfig) {
  delete buffmoddamageimmunityconfig_;
  buffmoddamageimmunityconfig_ = buffmoddamageimmunityconfig;
  if (buffmoddamageimmunityconfig) {
    set_has_buffmoddamageimmunityconfig();
  } else {
    clear_has_buffmoddamageimmunityconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDamageImmunityConfig)
}

// optional .pb.BuffModHitActionImmunityConfig BuffModHitActionImmunityConfig = 40;
inline bool BuffData::has_buffmodhitactionimmunityconfig() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BuffData::set_has_buffmodhitactionimmunityconfig() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BuffData::clear_has_buffmodhitactionimmunityconfig() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BuffData::clear_buffmodhitactionimmunityconfig() {
  if (buffmodhitactionimmunityconfig_ != NULL) buffmodhitactionimmunityconfig_->::pb::BuffModHitActionImmunityConfig::Clear();
  clear_has_buffmodhitactionimmunityconfig();
}
inline const ::pb::BuffModHitActionImmunityConfig& BuffData::buffmodhitactionimmunityconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModHitActionImmunityConfig)
  return buffmodhitactionimmunityconfig_ != NULL ? *buffmodhitactionimmunityconfig_ : *default_instance_->buffmodhitactionimmunityconfig_;
}
inline ::pb::BuffModHitActionImmunityConfig* BuffData::mutable_buffmodhitactionimmunityconfig() {
  set_has_buffmodhitactionimmunityconfig();
  if (buffmodhitactionimmunityconfig_ == NULL) buffmodhitactionimmunityconfig_ = new ::pb::BuffModHitActionImmunityConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModHitActionImmunityConfig)
  return buffmodhitactionimmunityconfig_;
}
inline ::pb::BuffModHitActionImmunityConfig* BuffData::release_buffmodhitactionimmunityconfig() {
  clear_has_buffmodhitactionimmunityconfig();
  ::pb::BuffModHitActionImmunityConfig* temp = buffmodhitactionimmunityconfig_;
  buffmodhitactionimmunityconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodhitactionimmunityconfig(::pb::BuffModHitActionImmunityConfig* buffmodhitactionimmunityconfig) {
  delete buffmodhitactionimmunityconfig_;
  buffmodhitactionimmunityconfig_ = buffmodhitactionimmunityconfig;
  if (buffmodhitactionimmunityconfig) {
    set_has_buffmodhitactionimmunityconfig();
  } else {
    clear_has_buffmodhitactionimmunityconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModHitActionImmunityConfig)
}

// optional .pb.BuffModArmAttrAddConfig BuffModArmAttrAddConfig = 42;
inline bool BuffData::has_buffmodarmattraddconfig() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BuffData::set_has_buffmodarmattraddconfig() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BuffData::clear_has_buffmodarmattraddconfig() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BuffData::clear_buffmodarmattraddconfig() {
  if (buffmodarmattraddconfig_ != NULL) buffmodarmattraddconfig_->::pb::BuffModArmAttrAddConfig::Clear();
  clear_has_buffmodarmattraddconfig();
}
inline const ::pb::BuffModArmAttrAddConfig& BuffData::buffmodarmattraddconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModArmAttrAddConfig)
  return buffmodarmattraddconfig_ != NULL ? *buffmodarmattraddconfig_ : *default_instance_->buffmodarmattraddconfig_;
}
inline ::pb::BuffModArmAttrAddConfig* BuffData::mutable_buffmodarmattraddconfig() {
  set_has_buffmodarmattraddconfig();
  if (buffmodarmattraddconfig_ == NULL) buffmodarmattraddconfig_ = new ::pb::BuffModArmAttrAddConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModArmAttrAddConfig)
  return buffmodarmattraddconfig_;
}
inline ::pb::BuffModArmAttrAddConfig* BuffData::release_buffmodarmattraddconfig() {
  clear_has_buffmodarmattraddconfig();
  ::pb::BuffModArmAttrAddConfig* temp = buffmodarmattraddconfig_;
  buffmodarmattraddconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodarmattraddconfig(::pb::BuffModArmAttrAddConfig* buffmodarmattraddconfig) {
  delete buffmodarmattraddconfig_;
  buffmodarmattraddconfig_ = buffmodarmattraddconfig;
  if (buffmodarmattraddconfig) {
    set_has_buffmodarmattraddconfig();
  } else {
    clear_has_buffmodarmattraddconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModArmAttrAddConfig)
}

// optional .pb.BuffModSkillOnLowLifeConfig BuffModSkillOnLowLifeConfig = 43;
inline bool BuffData::has_buffmodskillonlowlifeconfig() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BuffData::set_has_buffmodskillonlowlifeconfig() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BuffData::clear_has_buffmodskillonlowlifeconfig() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BuffData::clear_buffmodskillonlowlifeconfig() {
  if (buffmodskillonlowlifeconfig_ != NULL) buffmodskillonlowlifeconfig_->::pb::BuffModSkillOnLowLifeConfig::Clear();
  clear_has_buffmodskillonlowlifeconfig();
}
inline const ::pb::BuffModSkillOnLowLifeConfig& BuffData::buffmodskillonlowlifeconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModSkillOnLowLifeConfig)
  return buffmodskillonlowlifeconfig_ != NULL ? *buffmodskillonlowlifeconfig_ : *default_instance_->buffmodskillonlowlifeconfig_;
}
inline ::pb::BuffModSkillOnLowLifeConfig* BuffData::mutable_buffmodskillonlowlifeconfig() {
  set_has_buffmodskillonlowlifeconfig();
  if (buffmodskillonlowlifeconfig_ == NULL) buffmodskillonlowlifeconfig_ = new ::pb::BuffModSkillOnLowLifeConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModSkillOnLowLifeConfig)
  return buffmodskillonlowlifeconfig_;
}
inline ::pb::BuffModSkillOnLowLifeConfig* BuffData::release_buffmodskillonlowlifeconfig() {
  clear_has_buffmodskillonlowlifeconfig();
  ::pb::BuffModSkillOnLowLifeConfig* temp = buffmodskillonlowlifeconfig_;
  buffmodskillonlowlifeconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodskillonlowlifeconfig(::pb::BuffModSkillOnLowLifeConfig* buffmodskillonlowlifeconfig) {
  delete buffmodskillonlowlifeconfig_;
  buffmodskillonlowlifeconfig_ = buffmodskillonlowlifeconfig;
  if (buffmodskillonlowlifeconfig) {
    set_has_buffmodskillonlowlifeconfig();
  } else {
    clear_has_buffmodskillonlowlifeconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModSkillOnLowLifeConfig)
}

// optional .pb.BuffModMoveControlImmunityConfig BuffModMoveControlImmunityConfig = 50;
inline bool BuffData::has_buffmodmovecontrolimmunityconfig() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BuffData::set_has_buffmodmovecontrolimmunityconfig() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BuffData::clear_has_buffmodmovecontrolimmunityconfig() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BuffData::clear_buffmodmovecontrolimmunityconfig() {
  if (buffmodmovecontrolimmunityconfig_ != NULL) buffmodmovecontrolimmunityconfig_->::pb::BuffModMoveControlImmunityConfig::Clear();
  clear_has_buffmodmovecontrolimmunityconfig();
}
inline const ::pb::BuffModMoveControlImmunityConfig& BuffData::buffmodmovecontrolimmunityconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModMoveControlImmunityConfig)
  return buffmodmovecontrolimmunityconfig_ != NULL ? *buffmodmovecontrolimmunityconfig_ : *default_instance_->buffmodmovecontrolimmunityconfig_;
}
inline ::pb::BuffModMoveControlImmunityConfig* BuffData::mutable_buffmodmovecontrolimmunityconfig() {
  set_has_buffmodmovecontrolimmunityconfig();
  if (buffmodmovecontrolimmunityconfig_ == NULL) buffmodmovecontrolimmunityconfig_ = new ::pb::BuffModMoveControlImmunityConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModMoveControlImmunityConfig)
  return buffmodmovecontrolimmunityconfig_;
}
inline ::pb::BuffModMoveControlImmunityConfig* BuffData::release_buffmodmovecontrolimmunityconfig() {
  clear_has_buffmodmovecontrolimmunityconfig();
  ::pb::BuffModMoveControlImmunityConfig* temp = buffmodmovecontrolimmunityconfig_;
  buffmodmovecontrolimmunityconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodmovecontrolimmunityconfig(::pb::BuffModMoveControlImmunityConfig* buffmodmovecontrolimmunityconfig) {
  delete buffmodmovecontrolimmunityconfig_;
  buffmodmovecontrolimmunityconfig_ = buffmodmovecontrolimmunityconfig;
  if (buffmodmovecontrolimmunityconfig) {
    set_has_buffmodmovecontrolimmunityconfig();
  } else {
    clear_has_buffmodmovecontrolimmunityconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModMoveControlImmunityConfig)
}

// optional .pb.BuffModConditionChangeConfig BuffModConditionChangeConfig = 52;
inline bool BuffData::has_buffmodconditionchangeconfig() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BuffData::set_has_buffmodconditionchangeconfig() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BuffData::clear_has_buffmodconditionchangeconfig() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BuffData::clear_buffmodconditionchangeconfig() {
  if (buffmodconditionchangeconfig_ != NULL) buffmodconditionchangeconfig_->::pb::BuffModConditionChangeConfig::Clear();
  clear_has_buffmodconditionchangeconfig();
}
inline const ::pb::BuffModConditionChangeConfig& BuffData::buffmodconditionchangeconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModConditionChangeConfig)
  return buffmodconditionchangeconfig_ != NULL ? *buffmodconditionchangeconfig_ : *default_instance_->buffmodconditionchangeconfig_;
}
inline ::pb::BuffModConditionChangeConfig* BuffData::mutable_buffmodconditionchangeconfig() {
  set_has_buffmodconditionchangeconfig();
  if (buffmodconditionchangeconfig_ == NULL) buffmodconditionchangeconfig_ = new ::pb::BuffModConditionChangeConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModConditionChangeConfig)
  return buffmodconditionchangeconfig_;
}
inline ::pb::BuffModConditionChangeConfig* BuffData::release_buffmodconditionchangeconfig() {
  clear_has_buffmodconditionchangeconfig();
  ::pb::BuffModConditionChangeConfig* temp = buffmodconditionchangeconfig_;
  buffmodconditionchangeconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodconditionchangeconfig(::pb::BuffModConditionChangeConfig* buffmodconditionchangeconfig) {
  delete buffmodconditionchangeconfig_;
  buffmodconditionchangeconfig_ = buffmodconditionchangeconfig;
  if (buffmodconditionchangeconfig) {
    set_has_buffmodconditionchangeconfig();
  } else {
    clear_has_buffmodconditionchangeconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModConditionChangeConfig)
}

// optional .pb.BuffModPropertyDecConfig BuffModPropertyDecConfig = 55;
inline bool BuffData::has_buffmodpropertydecconfig() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BuffData::set_has_buffmodpropertydecconfig() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BuffData::clear_has_buffmodpropertydecconfig() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BuffData::clear_buffmodpropertydecconfig() {
  if (buffmodpropertydecconfig_ != NULL) buffmodpropertydecconfig_->::pb::BuffModPropertyDecConfig::Clear();
  clear_has_buffmodpropertydecconfig();
}
inline const ::pb::BuffModPropertyDecConfig& BuffData::buffmodpropertydecconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModPropertyDecConfig)
  return buffmodpropertydecconfig_ != NULL ? *buffmodpropertydecconfig_ : *default_instance_->buffmodpropertydecconfig_;
}
inline ::pb::BuffModPropertyDecConfig* BuffData::mutable_buffmodpropertydecconfig() {
  set_has_buffmodpropertydecconfig();
  if (buffmodpropertydecconfig_ == NULL) buffmodpropertydecconfig_ = new ::pb::BuffModPropertyDecConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModPropertyDecConfig)
  return buffmodpropertydecconfig_;
}
inline ::pb::BuffModPropertyDecConfig* BuffData::release_buffmodpropertydecconfig() {
  clear_has_buffmodpropertydecconfig();
  ::pb::BuffModPropertyDecConfig* temp = buffmodpropertydecconfig_;
  buffmodpropertydecconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodpropertydecconfig(::pb::BuffModPropertyDecConfig* buffmodpropertydecconfig) {
  delete buffmodpropertydecconfig_;
  buffmodpropertydecconfig_ = buffmodpropertydecconfig;
  if (buffmodpropertydecconfig) {
    set_has_buffmodpropertydecconfig();
  } else {
    clear_has_buffmodpropertydecconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModPropertyDecConfig)
}

// optional .pb.BuffModChangeDmgByBuffSubConfig BuffModChangeDmgByBuffSubConfig = 56;
inline bool BuffData::has_buffmodchangedmgbybuffsubconfig() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BuffData::set_has_buffmodchangedmgbybuffsubconfig() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BuffData::clear_has_buffmodchangedmgbybuffsubconfig() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BuffData::clear_buffmodchangedmgbybuffsubconfig() {
  if (buffmodchangedmgbybuffsubconfig_ != NULL) buffmodchangedmgbybuffsubconfig_->::pb::BuffModChangeDmgByBuffSubConfig::Clear();
  clear_has_buffmodchangedmgbybuffsubconfig();
}
inline const ::pb::BuffModChangeDmgByBuffSubConfig& BuffData::buffmodchangedmgbybuffsubconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModChangeDmgByBuffSubConfig)
  return buffmodchangedmgbybuffsubconfig_ != NULL ? *buffmodchangedmgbybuffsubconfig_ : *default_instance_->buffmodchangedmgbybuffsubconfig_;
}
inline ::pb::BuffModChangeDmgByBuffSubConfig* BuffData::mutable_buffmodchangedmgbybuffsubconfig() {
  set_has_buffmodchangedmgbybuffsubconfig();
  if (buffmodchangedmgbybuffsubconfig_ == NULL) buffmodchangedmgbybuffsubconfig_ = new ::pb::BuffModChangeDmgByBuffSubConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModChangeDmgByBuffSubConfig)
  return buffmodchangedmgbybuffsubconfig_;
}
inline ::pb::BuffModChangeDmgByBuffSubConfig* BuffData::release_buffmodchangedmgbybuffsubconfig() {
  clear_has_buffmodchangedmgbybuffsubconfig();
  ::pb::BuffModChangeDmgByBuffSubConfig* temp = buffmodchangedmgbybuffsubconfig_;
  buffmodchangedmgbybuffsubconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodchangedmgbybuffsubconfig(::pb::BuffModChangeDmgByBuffSubConfig* buffmodchangedmgbybuffsubconfig) {
  delete buffmodchangedmgbybuffsubconfig_;
  buffmodchangedmgbybuffsubconfig_ = buffmodchangedmgbybuffsubconfig;
  if (buffmodchangedmgbybuffsubconfig) {
    set_has_buffmodchangedmgbybuffsubconfig();
  } else {
    clear_has_buffmodchangedmgbybuffsubconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModChangeDmgByBuffSubConfig)
}

// optional .pb.BuffModShrinkControlDurationConfig BuffModShrinkControlDurationConfig = 62;
inline bool BuffData::has_buffmodshrinkcontroldurationconfig() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BuffData::set_has_buffmodshrinkcontroldurationconfig() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BuffData::clear_has_buffmodshrinkcontroldurationconfig() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BuffData::clear_buffmodshrinkcontroldurationconfig() {
  if (buffmodshrinkcontroldurationconfig_ != NULL) buffmodshrinkcontroldurationconfig_->::pb::BuffModShrinkControlDurationConfig::Clear();
  clear_has_buffmodshrinkcontroldurationconfig();
}
inline const ::pb::BuffModShrinkControlDurationConfig& BuffData::buffmodshrinkcontroldurationconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModShrinkControlDurationConfig)
  return buffmodshrinkcontroldurationconfig_ != NULL ? *buffmodshrinkcontroldurationconfig_ : *default_instance_->buffmodshrinkcontroldurationconfig_;
}
inline ::pb::BuffModShrinkControlDurationConfig* BuffData::mutable_buffmodshrinkcontroldurationconfig() {
  set_has_buffmodshrinkcontroldurationconfig();
  if (buffmodshrinkcontroldurationconfig_ == NULL) buffmodshrinkcontroldurationconfig_ = new ::pb::BuffModShrinkControlDurationConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModShrinkControlDurationConfig)
  return buffmodshrinkcontroldurationconfig_;
}
inline ::pb::BuffModShrinkControlDurationConfig* BuffData::release_buffmodshrinkcontroldurationconfig() {
  clear_has_buffmodshrinkcontroldurationconfig();
  ::pb::BuffModShrinkControlDurationConfig* temp = buffmodshrinkcontroldurationconfig_;
  buffmodshrinkcontroldurationconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodshrinkcontroldurationconfig(::pb::BuffModShrinkControlDurationConfig* buffmodshrinkcontroldurationconfig) {
  delete buffmodshrinkcontroldurationconfig_;
  buffmodshrinkcontroldurationconfig_ = buffmodshrinkcontroldurationconfig;
  if (buffmodshrinkcontroldurationconfig) {
    set_has_buffmodshrinkcontroldurationconfig();
  } else {
    clear_has_buffmodshrinkcontroldurationconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModShrinkControlDurationConfig)
}

// optional .pb.BuffModUnlimitedShieldConfig BuffModUnlimitedShieldConfig = 64;
inline bool BuffData::has_buffmodunlimitedshieldconfig() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BuffData::set_has_buffmodunlimitedshieldconfig() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BuffData::clear_has_buffmodunlimitedshieldconfig() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BuffData::clear_buffmodunlimitedshieldconfig() {
  if (buffmodunlimitedshieldconfig_ != NULL) buffmodunlimitedshieldconfig_->::pb::BuffModUnlimitedShieldConfig::Clear();
  clear_has_buffmodunlimitedshieldconfig();
}
inline const ::pb::BuffModUnlimitedShieldConfig& BuffData::buffmodunlimitedshieldconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModUnlimitedShieldConfig)
  return buffmodunlimitedshieldconfig_ != NULL ? *buffmodunlimitedshieldconfig_ : *default_instance_->buffmodunlimitedshieldconfig_;
}
inline ::pb::BuffModUnlimitedShieldConfig* BuffData::mutable_buffmodunlimitedshieldconfig() {
  set_has_buffmodunlimitedshieldconfig();
  if (buffmodunlimitedshieldconfig_ == NULL) buffmodunlimitedshieldconfig_ = new ::pb::BuffModUnlimitedShieldConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModUnlimitedShieldConfig)
  return buffmodunlimitedshieldconfig_;
}
inline ::pb::BuffModUnlimitedShieldConfig* BuffData::release_buffmodunlimitedshieldconfig() {
  clear_has_buffmodunlimitedshieldconfig();
  ::pb::BuffModUnlimitedShieldConfig* temp = buffmodunlimitedshieldconfig_;
  buffmodunlimitedshieldconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodunlimitedshieldconfig(::pb::BuffModUnlimitedShieldConfig* buffmodunlimitedshieldconfig) {
  delete buffmodunlimitedshieldconfig_;
  buffmodunlimitedshieldconfig_ = buffmodunlimitedshieldconfig;
  if (buffmodunlimitedshieldconfig) {
    set_has_buffmodunlimitedshieldconfig();
  } else {
    clear_has_buffmodunlimitedshieldconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModUnlimitedShieldConfig)
}

// optional .pb.BuffModReflectBuffConfig BuffModReflectBuffConfig = 65;
inline bool BuffData::has_buffmodreflectbuffconfig() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BuffData::set_has_buffmodreflectbuffconfig() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BuffData::clear_has_buffmodreflectbuffconfig() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BuffData::clear_buffmodreflectbuffconfig() {
  if (buffmodreflectbuffconfig_ != NULL) buffmodreflectbuffconfig_->::pb::BuffModReflectBuffConfig::Clear();
  clear_has_buffmodreflectbuffconfig();
}
inline const ::pb::BuffModReflectBuffConfig& BuffData::buffmodreflectbuffconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModReflectBuffConfig)
  return buffmodreflectbuffconfig_ != NULL ? *buffmodreflectbuffconfig_ : *default_instance_->buffmodreflectbuffconfig_;
}
inline ::pb::BuffModReflectBuffConfig* BuffData::mutable_buffmodreflectbuffconfig() {
  set_has_buffmodreflectbuffconfig();
  if (buffmodreflectbuffconfig_ == NULL) buffmodreflectbuffconfig_ = new ::pb::BuffModReflectBuffConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModReflectBuffConfig)
  return buffmodreflectbuffconfig_;
}
inline ::pb::BuffModReflectBuffConfig* BuffData::release_buffmodreflectbuffconfig() {
  clear_has_buffmodreflectbuffconfig();
  ::pb::BuffModReflectBuffConfig* temp = buffmodreflectbuffconfig_;
  buffmodreflectbuffconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodreflectbuffconfig(::pb::BuffModReflectBuffConfig* buffmodreflectbuffconfig) {
  delete buffmodreflectbuffconfig_;
  buffmodreflectbuffconfig_ = buffmodreflectbuffconfig;
  if (buffmodreflectbuffconfig) {
    set_has_buffmodreflectbuffconfig();
  } else {
    clear_has_buffmodreflectbuffconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModReflectBuffConfig)
}

// optional .pb.BuffModFatalDmgShiftConfig BuffModFatalDmgShiftConfig = 66;
inline bool BuffData::has_buffmodfataldmgshiftconfig() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BuffData::set_has_buffmodfataldmgshiftconfig() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BuffData::clear_has_buffmodfataldmgshiftconfig() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BuffData::clear_buffmodfataldmgshiftconfig() {
  if (buffmodfataldmgshiftconfig_ != NULL) buffmodfataldmgshiftconfig_->::pb::BuffModFatalDmgShiftConfig::Clear();
  clear_has_buffmodfataldmgshiftconfig();
}
inline const ::pb::BuffModFatalDmgShiftConfig& BuffData::buffmodfataldmgshiftconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModFatalDmgShiftConfig)
  return buffmodfataldmgshiftconfig_ != NULL ? *buffmodfataldmgshiftconfig_ : *default_instance_->buffmodfataldmgshiftconfig_;
}
inline ::pb::BuffModFatalDmgShiftConfig* BuffData::mutable_buffmodfataldmgshiftconfig() {
  set_has_buffmodfataldmgshiftconfig();
  if (buffmodfataldmgshiftconfig_ == NULL) buffmodfataldmgshiftconfig_ = new ::pb::BuffModFatalDmgShiftConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModFatalDmgShiftConfig)
  return buffmodfataldmgshiftconfig_;
}
inline ::pb::BuffModFatalDmgShiftConfig* BuffData::release_buffmodfataldmgshiftconfig() {
  clear_has_buffmodfataldmgshiftconfig();
  ::pb::BuffModFatalDmgShiftConfig* temp = buffmodfataldmgshiftconfig_;
  buffmodfataldmgshiftconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodfataldmgshiftconfig(::pb::BuffModFatalDmgShiftConfig* buffmodfataldmgshiftconfig) {
  delete buffmodfataldmgshiftconfig_;
  buffmodfataldmgshiftconfig_ = buffmodfataldmgshiftconfig;
  if (buffmodfataldmgshiftconfig) {
    set_has_buffmodfataldmgshiftconfig();
  } else {
    clear_has_buffmodfataldmgshiftconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModFatalDmgShiftConfig)
}

// optional .pb.BuffModRageImmunityConfig BuffModRageImmunityConfig = 68;
inline bool BuffData::has_buffmodrageimmunityconfig() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BuffData::set_has_buffmodrageimmunityconfig() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BuffData::clear_has_buffmodrageimmunityconfig() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BuffData::clear_buffmodrageimmunityconfig() {
  if (buffmodrageimmunityconfig_ != NULL) buffmodrageimmunityconfig_->::pb::BuffModRageImmunityConfig::Clear();
  clear_has_buffmodrageimmunityconfig();
}
inline const ::pb::BuffModRageImmunityConfig& BuffData::buffmodrageimmunityconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRageImmunityConfig)
  return buffmodrageimmunityconfig_ != NULL ? *buffmodrageimmunityconfig_ : *default_instance_->buffmodrageimmunityconfig_;
}
inline ::pb::BuffModRageImmunityConfig* BuffData::mutable_buffmodrageimmunityconfig() {
  set_has_buffmodrageimmunityconfig();
  if (buffmodrageimmunityconfig_ == NULL) buffmodrageimmunityconfig_ = new ::pb::BuffModRageImmunityConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRageImmunityConfig)
  return buffmodrageimmunityconfig_;
}
inline ::pb::BuffModRageImmunityConfig* BuffData::release_buffmodrageimmunityconfig() {
  clear_has_buffmodrageimmunityconfig();
  ::pb::BuffModRageImmunityConfig* temp = buffmodrageimmunityconfig_;
  buffmodrageimmunityconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodrageimmunityconfig(::pb::BuffModRageImmunityConfig* buffmodrageimmunityconfig) {
  delete buffmodrageimmunityconfig_;
  buffmodrageimmunityconfig_ = buffmodrageimmunityconfig;
  if (buffmodrageimmunityconfig) {
    set_has_buffmodrageimmunityconfig();
  } else {
    clear_has_buffmodrageimmunityconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRageImmunityConfig)
}

// optional .pb.BuffModIgnoreShieldConfig BuffModIgnoreShieldConfig = 74;
inline bool BuffData::has_buffmodignoreshieldconfig() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BuffData::set_has_buffmodignoreshieldconfig() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BuffData::clear_has_buffmodignoreshieldconfig() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BuffData::clear_buffmodignoreshieldconfig() {
  if (buffmodignoreshieldconfig_ != NULL) buffmodignoreshieldconfig_->::pb::BuffModIgnoreShieldConfig::Clear();
  clear_has_buffmodignoreshieldconfig();
}
inline const ::pb::BuffModIgnoreShieldConfig& BuffData::buffmodignoreshieldconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModIgnoreShieldConfig)
  return buffmodignoreshieldconfig_ != NULL ? *buffmodignoreshieldconfig_ : *default_instance_->buffmodignoreshieldconfig_;
}
inline ::pb::BuffModIgnoreShieldConfig* BuffData::mutable_buffmodignoreshieldconfig() {
  set_has_buffmodignoreshieldconfig();
  if (buffmodignoreshieldconfig_ == NULL) buffmodignoreshieldconfig_ = new ::pb::BuffModIgnoreShieldConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModIgnoreShieldConfig)
  return buffmodignoreshieldconfig_;
}
inline ::pb::BuffModIgnoreShieldConfig* BuffData::release_buffmodignoreshieldconfig() {
  clear_has_buffmodignoreshieldconfig();
  ::pb::BuffModIgnoreShieldConfig* temp = buffmodignoreshieldconfig_;
  buffmodignoreshieldconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodignoreshieldconfig(::pb::BuffModIgnoreShieldConfig* buffmodignoreshieldconfig) {
  delete buffmodignoreshieldconfig_;
  buffmodignoreshieldconfig_ = buffmodignoreshieldconfig;
  if (buffmodignoreshieldconfig) {
    set_has_buffmodignoreshieldconfig();
  } else {
    clear_has_buffmodignoreshieldconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModIgnoreShieldConfig)
}

// optional .pb.BuffModRevertStateOnEndConfig BuffModRevertStateOnEndConfig = 77;
inline bool BuffData::has_buffmodrevertstateonendconfig() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BuffData::set_has_buffmodrevertstateonendconfig() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BuffData::clear_has_buffmodrevertstateonendconfig() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BuffData::clear_buffmodrevertstateonendconfig() {
  if (buffmodrevertstateonendconfig_ != NULL) buffmodrevertstateonendconfig_->::pb::BuffModRevertStateOnEndConfig::Clear();
  clear_has_buffmodrevertstateonendconfig();
}
inline const ::pb::BuffModRevertStateOnEndConfig& BuffData::buffmodrevertstateonendconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRevertStateOnEndConfig)
  return buffmodrevertstateonendconfig_ != NULL ? *buffmodrevertstateonendconfig_ : *default_instance_->buffmodrevertstateonendconfig_;
}
inline ::pb::BuffModRevertStateOnEndConfig* BuffData::mutable_buffmodrevertstateonendconfig() {
  set_has_buffmodrevertstateonendconfig();
  if (buffmodrevertstateonendconfig_ == NULL) buffmodrevertstateonendconfig_ = new ::pb::BuffModRevertStateOnEndConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRevertStateOnEndConfig)
  return buffmodrevertstateonendconfig_;
}
inline ::pb::BuffModRevertStateOnEndConfig* BuffData::release_buffmodrevertstateonendconfig() {
  clear_has_buffmodrevertstateonendconfig();
  ::pb::BuffModRevertStateOnEndConfig* temp = buffmodrevertstateonendconfig_;
  buffmodrevertstateonendconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodrevertstateonendconfig(::pb::BuffModRevertStateOnEndConfig* buffmodrevertstateonendconfig) {
  delete buffmodrevertstateonendconfig_;
  buffmodrevertstateonendconfig_ = buffmodrevertstateonendconfig;
  if (buffmodrevertstateonendconfig) {
    set_has_buffmodrevertstateonendconfig();
  } else {
    clear_has_buffmodrevertstateonendconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRevertStateOnEndConfig)
}

// optional .pb.BuffModChangeCastRangeConfig BuffModChangeCastRangeConfig = 78;
inline bool BuffData::has_buffmodchangecastrangeconfig() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BuffData::set_has_buffmodchangecastrangeconfig() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BuffData::clear_has_buffmodchangecastrangeconfig() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BuffData::clear_buffmodchangecastrangeconfig() {
  if (buffmodchangecastrangeconfig_ != NULL) buffmodchangecastrangeconfig_->::pb::BuffModChangeCastRangeConfig::Clear();
  clear_has_buffmodchangecastrangeconfig();
}
inline const ::pb::BuffModChangeCastRangeConfig& BuffData::buffmodchangecastrangeconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModChangeCastRangeConfig)
  return buffmodchangecastrangeconfig_ != NULL ? *buffmodchangecastrangeconfig_ : *default_instance_->buffmodchangecastrangeconfig_;
}
inline ::pb::BuffModChangeCastRangeConfig* BuffData::mutable_buffmodchangecastrangeconfig() {
  set_has_buffmodchangecastrangeconfig();
  if (buffmodchangecastrangeconfig_ == NULL) buffmodchangecastrangeconfig_ = new ::pb::BuffModChangeCastRangeConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModChangeCastRangeConfig)
  return buffmodchangecastrangeconfig_;
}
inline ::pb::BuffModChangeCastRangeConfig* BuffData::release_buffmodchangecastrangeconfig() {
  clear_has_buffmodchangecastrangeconfig();
  ::pb::BuffModChangeCastRangeConfig* temp = buffmodchangecastrangeconfig_;
  buffmodchangecastrangeconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodchangecastrangeconfig(::pb::BuffModChangeCastRangeConfig* buffmodchangecastrangeconfig) {
  delete buffmodchangecastrangeconfig_;
  buffmodchangecastrangeconfig_ = buffmodchangecastrangeconfig;
  if (buffmodchangecastrangeconfig) {
    set_has_buffmodchangecastrangeconfig();
  } else {
    clear_has_buffmodchangecastrangeconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModChangeCastRangeConfig)
}

// optional .pb.BuffModSetMaxLoseHPConfig BuffModSetMaxLoseHPConfig = 81;
inline bool BuffData::has_buffmodsetmaxlosehpconfig() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BuffData::set_has_buffmodsetmaxlosehpconfig() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BuffData::clear_has_buffmodsetmaxlosehpconfig() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BuffData::clear_buffmodsetmaxlosehpconfig() {
  if (buffmodsetmaxlosehpconfig_ != NULL) buffmodsetmaxlosehpconfig_->::pb::BuffModSetMaxLoseHPConfig::Clear();
  clear_has_buffmodsetmaxlosehpconfig();
}
inline const ::pb::BuffModSetMaxLoseHPConfig& BuffData::buffmodsetmaxlosehpconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModSetMaxLoseHPConfig)
  return buffmodsetmaxlosehpconfig_ != NULL ? *buffmodsetmaxlosehpconfig_ : *default_instance_->buffmodsetmaxlosehpconfig_;
}
inline ::pb::BuffModSetMaxLoseHPConfig* BuffData::mutable_buffmodsetmaxlosehpconfig() {
  set_has_buffmodsetmaxlosehpconfig();
  if (buffmodsetmaxlosehpconfig_ == NULL) buffmodsetmaxlosehpconfig_ = new ::pb::BuffModSetMaxLoseHPConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModSetMaxLoseHPConfig)
  return buffmodsetmaxlosehpconfig_;
}
inline ::pb::BuffModSetMaxLoseHPConfig* BuffData::release_buffmodsetmaxlosehpconfig() {
  clear_has_buffmodsetmaxlosehpconfig();
  ::pb::BuffModSetMaxLoseHPConfig* temp = buffmodsetmaxlosehpconfig_;
  buffmodsetmaxlosehpconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodsetmaxlosehpconfig(::pb::BuffModSetMaxLoseHPConfig* buffmodsetmaxlosehpconfig) {
  delete buffmodsetmaxlosehpconfig_;
  buffmodsetmaxlosehpconfig_ = buffmodsetmaxlosehpconfig;
  if (buffmodsetmaxlosehpconfig) {
    set_has_buffmodsetmaxlosehpconfig();
  } else {
    clear_has_buffmodsetmaxlosehpconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModSetMaxLoseHPConfig)
}

// optional .pb.BuffModAdjustReflectedDamageConfig BuffModAdjustReflectedDamageConfig = 82;
inline bool BuffData::has_buffmodadjustreflecteddamageconfig() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BuffData::set_has_buffmodadjustreflecteddamageconfig() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BuffData::clear_has_buffmodadjustreflecteddamageconfig() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BuffData::clear_buffmodadjustreflecteddamageconfig() {
  if (buffmodadjustreflecteddamageconfig_ != NULL) buffmodadjustreflecteddamageconfig_->::pb::BuffModAdjustReflectedDamageConfig::Clear();
  clear_has_buffmodadjustreflecteddamageconfig();
}
inline const ::pb::BuffModAdjustReflectedDamageConfig& BuffData::buffmodadjustreflecteddamageconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModAdjustReflectedDamageConfig)
  return buffmodadjustreflecteddamageconfig_ != NULL ? *buffmodadjustreflecteddamageconfig_ : *default_instance_->buffmodadjustreflecteddamageconfig_;
}
inline ::pb::BuffModAdjustReflectedDamageConfig* BuffData::mutable_buffmodadjustreflecteddamageconfig() {
  set_has_buffmodadjustreflecteddamageconfig();
  if (buffmodadjustreflecteddamageconfig_ == NULL) buffmodadjustreflecteddamageconfig_ = new ::pb::BuffModAdjustReflectedDamageConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModAdjustReflectedDamageConfig)
  return buffmodadjustreflecteddamageconfig_;
}
inline ::pb::BuffModAdjustReflectedDamageConfig* BuffData::release_buffmodadjustreflecteddamageconfig() {
  clear_has_buffmodadjustreflecteddamageconfig();
  ::pb::BuffModAdjustReflectedDamageConfig* temp = buffmodadjustreflecteddamageconfig_;
  buffmodadjustreflecteddamageconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodadjustreflecteddamageconfig(::pb::BuffModAdjustReflectedDamageConfig* buffmodadjustreflecteddamageconfig) {
  delete buffmodadjustreflecteddamageconfig_;
  buffmodadjustreflecteddamageconfig_ = buffmodadjustreflecteddamageconfig;
  if (buffmodadjustreflecteddamageconfig) {
    set_has_buffmodadjustreflecteddamageconfig();
  } else {
    clear_has_buffmodadjustreflecteddamageconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModAdjustReflectedDamageConfig)
}

// optional .pb.BuffModActiveUIEffectConfig BuffModActiveUIEffectConfig = 83;
inline bool BuffData::has_buffmodactiveuieffectconfig() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void BuffData::set_has_buffmodactiveuieffectconfig() {
  _has_bits_[1] |= 0x00000020u;
}
inline void BuffData::clear_has_buffmodactiveuieffectconfig() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void BuffData::clear_buffmodactiveuieffectconfig() {
  if (buffmodactiveuieffectconfig_ != NULL) buffmodactiveuieffectconfig_->::pb::BuffModActiveUIEffectConfig::Clear();
  clear_has_buffmodactiveuieffectconfig();
}
inline const ::pb::BuffModActiveUIEffectConfig& BuffData::buffmodactiveuieffectconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModActiveUIEffectConfig)
  return buffmodactiveuieffectconfig_ != NULL ? *buffmodactiveuieffectconfig_ : *default_instance_->buffmodactiveuieffectconfig_;
}
inline ::pb::BuffModActiveUIEffectConfig* BuffData::mutable_buffmodactiveuieffectconfig() {
  set_has_buffmodactiveuieffectconfig();
  if (buffmodactiveuieffectconfig_ == NULL) buffmodactiveuieffectconfig_ = new ::pb::BuffModActiveUIEffectConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModActiveUIEffectConfig)
  return buffmodactiveuieffectconfig_;
}
inline ::pb::BuffModActiveUIEffectConfig* BuffData::release_buffmodactiveuieffectconfig() {
  clear_has_buffmodactiveuieffectconfig();
  ::pb::BuffModActiveUIEffectConfig* temp = buffmodactiveuieffectconfig_;
  buffmodactiveuieffectconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodactiveuieffectconfig(::pb::BuffModActiveUIEffectConfig* buffmodactiveuieffectconfig) {
  delete buffmodactiveuieffectconfig_;
  buffmodactiveuieffectconfig_ = buffmodactiveuieffectconfig;
  if (buffmodactiveuieffectconfig) {
    set_has_buffmodactiveuieffectconfig();
  } else {
    clear_has_buffmodactiveuieffectconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModActiveUIEffectConfig)
}

// optional .pb.BuffModAdjustBuffHitRateConfig BuffModAdjustBuffHitRateConfig = 84;
inline bool BuffData::has_buffmodadjustbuffhitrateconfig() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BuffData::set_has_buffmodadjustbuffhitrateconfig() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BuffData::clear_has_buffmodadjustbuffhitrateconfig() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BuffData::clear_buffmodadjustbuffhitrateconfig() {
  if (buffmodadjustbuffhitrateconfig_ != NULL) buffmodadjustbuffhitrateconfig_->::pb::BuffModAdjustBuffHitRateConfig::Clear();
  clear_has_buffmodadjustbuffhitrateconfig();
}
inline const ::pb::BuffModAdjustBuffHitRateConfig& BuffData::buffmodadjustbuffhitrateconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModAdjustBuffHitRateConfig)
  return buffmodadjustbuffhitrateconfig_ != NULL ? *buffmodadjustbuffhitrateconfig_ : *default_instance_->buffmodadjustbuffhitrateconfig_;
}
inline ::pb::BuffModAdjustBuffHitRateConfig* BuffData::mutable_buffmodadjustbuffhitrateconfig() {
  set_has_buffmodadjustbuffhitrateconfig();
  if (buffmodadjustbuffhitrateconfig_ == NULL) buffmodadjustbuffhitrateconfig_ = new ::pb::BuffModAdjustBuffHitRateConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModAdjustBuffHitRateConfig)
  return buffmodadjustbuffhitrateconfig_;
}
inline ::pb::BuffModAdjustBuffHitRateConfig* BuffData::release_buffmodadjustbuffhitrateconfig() {
  clear_has_buffmodadjustbuffhitrateconfig();
  ::pb::BuffModAdjustBuffHitRateConfig* temp = buffmodadjustbuffhitrateconfig_;
  buffmodadjustbuffhitrateconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodadjustbuffhitrateconfig(::pb::BuffModAdjustBuffHitRateConfig* buffmodadjustbuffhitrateconfig) {
  delete buffmodadjustbuffhitrateconfig_;
  buffmodadjustbuffhitrateconfig_ = buffmodadjustbuffhitrateconfig;
  if (buffmodadjustbuffhitrateconfig) {
    set_has_buffmodadjustbuffhitrateconfig();
  } else {
    clear_has_buffmodadjustbuffhitrateconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModAdjustBuffHitRateConfig)
}

// optional .pb.BuffModLimitByMaxHpRateConfig BuffModLimitByMaxHpRateConfig = 85;
inline bool BuffData::has_buffmodlimitbymaxhprateconfig() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void BuffData::set_has_buffmodlimitbymaxhprateconfig() {
  _has_bits_[1] |= 0x00000080u;
}
inline void BuffData::clear_has_buffmodlimitbymaxhprateconfig() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void BuffData::clear_buffmodlimitbymaxhprateconfig() {
  if (buffmodlimitbymaxhprateconfig_ != NULL) buffmodlimitbymaxhprateconfig_->::pb::BuffModLimitByMaxHpRateConfig::Clear();
  clear_has_buffmodlimitbymaxhprateconfig();
}
inline const ::pb::BuffModLimitByMaxHpRateConfig& BuffData::buffmodlimitbymaxhprateconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModLimitByMaxHpRateConfig)
  return buffmodlimitbymaxhprateconfig_ != NULL ? *buffmodlimitbymaxhprateconfig_ : *default_instance_->buffmodlimitbymaxhprateconfig_;
}
inline ::pb::BuffModLimitByMaxHpRateConfig* BuffData::mutable_buffmodlimitbymaxhprateconfig() {
  set_has_buffmodlimitbymaxhprateconfig();
  if (buffmodlimitbymaxhprateconfig_ == NULL) buffmodlimitbymaxhprateconfig_ = new ::pb::BuffModLimitByMaxHpRateConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModLimitByMaxHpRateConfig)
  return buffmodlimitbymaxhprateconfig_;
}
inline ::pb::BuffModLimitByMaxHpRateConfig* BuffData::release_buffmodlimitbymaxhprateconfig() {
  clear_has_buffmodlimitbymaxhprateconfig();
  ::pb::BuffModLimitByMaxHpRateConfig* temp = buffmodlimitbymaxhprateconfig_;
  buffmodlimitbymaxhprateconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodlimitbymaxhprateconfig(::pb::BuffModLimitByMaxHpRateConfig* buffmodlimitbymaxhprateconfig) {
  delete buffmodlimitbymaxhprateconfig_;
  buffmodlimitbymaxhprateconfig_ = buffmodlimitbymaxhprateconfig;
  if (buffmodlimitbymaxhprateconfig) {
    set_has_buffmodlimitbymaxhprateconfig();
  } else {
    clear_has_buffmodlimitbymaxhprateconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModLimitByMaxHpRateConfig)
}

// optional .pb.BuffModBattleArcherModifyConfig BuffModBattleArcherModifyConfig = 86;
inline bool BuffData::has_buffmodbattlearchermodifyconfig() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void BuffData::set_has_buffmodbattlearchermodifyconfig() {
  _has_bits_[1] |= 0x00000100u;
}
inline void BuffData::clear_has_buffmodbattlearchermodifyconfig() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void BuffData::clear_buffmodbattlearchermodifyconfig() {
  if (buffmodbattlearchermodifyconfig_ != NULL) buffmodbattlearchermodifyconfig_->::pb::BuffModBattleArcherModifyConfig::Clear();
  clear_has_buffmodbattlearchermodifyconfig();
}
inline const ::pb::BuffModBattleArcherModifyConfig& BuffData::buffmodbattlearchermodifyconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModBattleArcherModifyConfig)
  return buffmodbattlearchermodifyconfig_ != NULL ? *buffmodbattlearchermodifyconfig_ : *default_instance_->buffmodbattlearchermodifyconfig_;
}
inline ::pb::BuffModBattleArcherModifyConfig* BuffData::mutable_buffmodbattlearchermodifyconfig() {
  set_has_buffmodbattlearchermodifyconfig();
  if (buffmodbattlearchermodifyconfig_ == NULL) buffmodbattlearchermodifyconfig_ = new ::pb::BuffModBattleArcherModifyConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModBattleArcherModifyConfig)
  return buffmodbattlearchermodifyconfig_;
}
inline ::pb::BuffModBattleArcherModifyConfig* BuffData::release_buffmodbattlearchermodifyconfig() {
  clear_has_buffmodbattlearchermodifyconfig();
  ::pb::BuffModBattleArcherModifyConfig* temp = buffmodbattlearchermodifyconfig_;
  buffmodbattlearchermodifyconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodbattlearchermodifyconfig(::pb::BuffModBattleArcherModifyConfig* buffmodbattlearchermodifyconfig) {
  delete buffmodbattlearchermodifyconfig_;
  buffmodbattlearchermodifyconfig_ = buffmodbattlearchermodifyconfig;
  if (buffmodbattlearchermodifyconfig) {
    set_has_buffmodbattlearchermodifyconfig();
  } else {
    clear_has_buffmodbattlearchermodifyconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModBattleArcherModifyConfig)
}

// optional .pb.BuffModNoMoveConfig BuffModNoMoveConfig = 7;
inline bool BuffData::has_buffmodnomoveconfig() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void BuffData::set_has_buffmodnomoveconfig() {
  _has_bits_[1] |= 0x00000200u;
}
inline void BuffData::clear_has_buffmodnomoveconfig() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void BuffData::clear_buffmodnomoveconfig() {
  if (buffmodnomoveconfig_ != NULL) buffmodnomoveconfig_->::pb::BuffModNoMoveConfig::Clear();
  clear_has_buffmodnomoveconfig();
}
inline const ::pb::BuffModNoMoveConfig& BuffData::buffmodnomoveconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNoMoveConfig)
  return buffmodnomoveconfig_ != NULL ? *buffmodnomoveconfig_ : *default_instance_->buffmodnomoveconfig_;
}
inline ::pb::BuffModNoMoveConfig* BuffData::mutable_buffmodnomoveconfig() {
  set_has_buffmodnomoveconfig();
  if (buffmodnomoveconfig_ == NULL) buffmodnomoveconfig_ = new ::pb::BuffModNoMoveConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNoMoveConfig)
  return buffmodnomoveconfig_;
}
inline ::pb::BuffModNoMoveConfig* BuffData::release_buffmodnomoveconfig() {
  clear_has_buffmodnomoveconfig();
  ::pb::BuffModNoMoveConfig* temp = buffmodnomoveconfig_;
  buffmodnomoveconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnomoveconfig(::pb::BuffModNoMoveConfig* buffmodnomoveconfig) {
  delete buffmodnomoveconfig_;
  buffmodnomoveconfig_ = buffmodnomoveconfig;
  if (buffmodnomoveconfig) {
    set_has_buffmodnomoveconfig();
  } else {
    clear_has_buffmodnomoveconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNoMoveConfig)
}

// optional .pb.BuffModNoNormalSkillConfig BuffModNoNormalSkillConfig = 8;
inline bool BuffData::has_buffmodnonormalskillconfig() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void BuffData::set_has_buffmodnonormalskillconfig() {
  _has_bits_[1] |= 0x00000400u;
}
inline void BuffData::clear_has_buffmodnonormalskillconfig() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void BuffData::clear_buffmodnonormalskillconfig() {
  if (buffmodnonormalskillconfig_ != NULL) buffmodnonormalskillconfig_->::pb::BuffModNoNormalSkillConfig::Clear();
  clear_has_buffmodnonormalskillconfig();
}
inline const ::pb::BuffModNoNormalSkillConfig& BuffData::buffmodnonormalskillconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNoNormalSkillConfig)
  return buffmodnonormalskillconfig_ != NULL ? *buffmodnonormalskillconfig_ : *default_instance_->buffmodnonormalskillconfig_;
}
inline ::pb::BuffModNoNormalSkillConfig* BuffData::mutable_buffmodnonormalskillconfig() {
  set_has_buffmodnonormalskillconfig();
  if (buffmodnonormalskillconfig_ == NULL) buffmodnonormalskillconfig_ = new ::pb::BuffModNoNormalSkillConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNoNormalSkillConfig)
  return buffmodnonormalskillconfig_;
}
inline ::pb::BuffModNoNormalSkillConfig* BuffData::release_buffmodnonormalskillconfig() {
  clear_has_buffmodnonormalskillconfig();
  ::pb::BuffModNoNormalSkillConfig* temp = buffmodnonormalskillconfig_;
  buffmodnonormalskillconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnonormalskillconfig(::pb::BuffModNoNormalSkillConfig* buffmodnonormalskillconfig) {
  delete buffmodnonormalskillconfig_;
  buffmodnonormalskillconfig_ = buffmodnonormalskillconfig;
  if (buffmodnonormalskillconfig) {
    set_has_buffmodnonormalskillconfig();
  } else {
    clear_has_buffmodnonormalskillconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNoNormalSkillConfig)
}

// optional .pb.BuffModNoSkillConfig BuffModNoSkillConfig = 9;
inline bool BuffData::has_buffmodnoskillconfig() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void BuffData::set_has_buffmodnoskillconfig() {
  _has_bits_[1] |= 0x00000800u;
}
inline void BuffData::clear_has_buffmodnoskillconfig() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void BuffData::clear_buffmodnoskillconfig() {
  if (buffmodnoskillconfig_ != NULL) buffmodnoskillconfig_->::pb::BuffModNoSkillConfig::Clear();
  clear_has_buffmodnoskillconfig();
}
inline const ::pb::BuffModNoSkillConfig& BuffData::buffmodnoskillconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNoSkillConfig)
  return buffmodnoskillconfig_ != NULL ? *buffmodnoskillconfig_ : *default_instance_->buffmodnoskillconfig_;
}
inline ::pb::BuffModNoSkillConfig* BuffData::mutable_buffmodnoskillconfig() {
  set_has_buffmodnoskillconfig();
  if (buffmodnoskillconfig_ == NULL) buffmodnoskillconfig_ = new ::pb::BuffModNoSkillConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNoSkillConfig)
  return buffmodnoskillconfig_;
}
inline ::pb::BuffModNoSkillConfig* BuffData::release_buffmodnoskillconfig() {
  clear_has_buffmodnoskillconfig();
  ::pb::BuffModNoSkillConfig* temp = buffmodnoskillconfig_;
  buffmodnoskillconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnoskillconfig(::pb::BuffModNoSkillConfig* buffmodnoskillconfig) {
  delete buffmodnoskillconfig_;
  buffmodnoskillconfig_ = buffmodnoskillconfig;
  if (buffmodnoskillconfig) {
    set_has_buffmodnoskillconfig();
  } else {
    clear_has_buffmodnoskillconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNoSkillConfig)
}

// optional .pb.BuffModDizzinessConfig BuffModDizzinessConfig = 10;
inline bool BuffData::has_buffmoddizzinessconfig() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void BuffData::set_has_buffmoddizzinessconfig() {
  _has_bits_[1] |= 0x00001000u;
}
inline void BuffData::clear_has_buffmoddizzinessconfig() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void BuffData::clear_buffmoddizzinessconfig() {
  if (buffmoddizzinessconfig_ != NULL) buffmoddizzinessconfig_->::pb::BuffModDizzinessConfig::Clear();
  clear_has_buffmoddizzinessconfig();
}
inline const ::pb::BuffModDizzinessConfig& BuffData::buffmoddizzinessconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDizzinessConfig)
  return buffmoddizzinessconfig_ != NULL ? *buffmoddizzinessconfig_ : *default_instance_->buffmoddizzinessconfig_;
}
inline ::pb::BuffModDizzinessConfig* BuffData::mutable_buffmoddizzinessconfig() {
  set_has_buffmoddizzinessconfig();
  if (buffmoddizzinessconfig_ == NULL) buffmoddizzinessconfig_ = new ::pb::BuffModDizzinessConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDizzinessConfig)
  return buffmoddizzinessconfig_;
}
inline ::pb::BuffModDizzinessConfig* BuffData::release_buffmoddizzinessconfig() {
  clear_has_buffmoddizzinessconfig();
  ::pb::BuffModDizzinessConfig* temp = buffmoddizzinessconfig_;
  buffmoddizzinessconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddizzinessconfig(::pb::BuffModDizzinessConfig* buffmoddizzinessconfig) {
  delete buffmoddizzinessconfig_;
  buffmoddizzinessconfig_ = buffmoddizzinessconfig;
  if (buffmoddizzinessconfig) {
    set_has_buffmoddizzinessconfig();
  } else {
    clear_has_buffmoddizzinessconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDizzinessConfig)
}

// optional .pb.BuffModFreezeConfig BuffModFreezeConfig = 11;
inline bool BuffData::has_buffmodfreezeconfig() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void BuffData::set_has_buffmodfreezeconfig() {
  _has_bits_[1] |= 0x00002000u;
}
inline void BuffData::clear_has_buffmodfreezeconfig() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void BuffData::clear_buffmodfreezeconfig() {
  if (buffmodfreezeconfig_ != NULL) buffmodfreezeconfig_->::pb::BuffModFreezeConfig::Clear();
  clear_has_buffmodfreezeconfig();
}
inline const ::pb::BuffModFreezeConfig& BuffData::buffmodfreezeconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModFreezeConfig)
  return buffmodfreezeconfig_ != NULL ? *buffmodfreezeconfig_ : *default_instance_->buffmodfreezeconfig_;
}
inline ::pb::BuffModFreezeConfig* BuffData::mutable_buffmodfreezeconfig() {
  set_has_buffmodfreezeconfig();
  if (buffmodfreezeconfig_ == NULL) buffmodfreezeconfig_ = new ::pb::BuffModFreezeConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModFreezeConfig)
  return buffmodfreezeconfig_;
}
inline ::pb::BuffModFreezeConfig* BuffData::release_buffmodfreezeconfig() {
  clear_has_buffmodfreezeconfig();
  ::pb::BuffModFreezeConfig* temp = buffmodfreezeconfig_;
  buffmodfreezeconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodfreezeconfig(::pb::BuffModFreezeConfig* buffmodfreezeconfig) {
  delete buffmodfreezeconfig_;
  buffmodfreezeconfig_ = buffmodfreezeconfig;
  if (buffmodfreezeconfig) {
    set_has_buffmodfreezeconfig();
  } else {
    clear_has_buffmodfreezeconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModFreezeConfig)
}

// optional .pb.BuffModCharmedConfig BuffModCharmedConfig = 31;
inline bool BuffData::has_buffmodcharmedconfig() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void BuffData::set_has_buffmodcharmedconfig() {
  _has_bits_[1] |= 0x00004000u;
}
inline void BuffData::clear_has_buffmodcharmedconfig() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void BuffData::clear_buffmodcharmedconfig() {
  if (buffmodcharmedconfig_ != NULL) buffmodcharmedconfig_->::pb::BuffModCharmedConfig::Clear();
  clear_has_buffmodcharmedconfig();
}
inline const ::pb::BuffModCharmedConfig& BuffData::buffmodcharmedconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModCharmedConfig)
  return buffmodcharmedconfig_ != NULL ? *buffmodcharmedconfig_ : *default_instance_->buffmodcharmedconfig_;
}
inline ::pb::BuffModCharmedConfig* BuffData::mutable_buffmodcharmedconfig() {
  set_has_buffmodcharmedconfig();
  if (buffmodcharmedconfig_ == NULL) buffmodcharmedconfig_ = new ::pb::BuffModCharmedConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModCharmedConfig)
  return buffmodcharmedconfig_;
}
inline ::pb::BuffModCharmedConfig* BuffData::release_buffmodcharmedconfig() {
  clear_has_buffmodcharmedconfig();
  ::pb::BuffModCharmedConfig* temp = buffmodcharmedconfig_;
  buffmodcharmedconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodcharmedconfig(::pb::BuffModCharmedConfig* buffmodcharmedconfig) {
  delete buffmodcharmedconfig_;
  buffmodcharmedconfig_ = buffmodcharmedconfig;
  if (buffmodcharmedconfig) {
    set_has_buffmodcharmedconfig();
  } else {
    clear_has_buffmodcharmedconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModCharmedConfig)
}

// optional .pb.BuffModChaosConfig BuffModChaosConfig = 32;
inline bool BuffData::has_buffmodchaosconfig() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void BuffData::set_has_buffmodchaosconfig() {
  _has_bits_[1] |= 0x00008000u;
}
inline void BuffData::clear_has_buffmodchaosconfig() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void BuffData::clear_buffmodchaosconfig() {
  if (buffmodchaosconfig_ != NULL) buffmodchaosconfig_->::pb::BuffModChaosConfig::Clear();
  clear_has_buffmodchaosconfig();
}
inline const ::pb::BuffModChaosConfig& BuffData::buffmodchaosconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModChaosConfig)
  return buffmodchaosconfig_ != NULL ? *buffmodchaosconfig_ : *default_instance_->buffmodchaosconfig_;
}
inline ::pb::BuffModChaosConfig* BuffData::mutable_buffmodchaosconfig() {
  set_has_buffmodchaosconfig();
  if (buffmodchaosconfig_ == NULL) buffmodchaosconfig_ = new ::pb::BuffModChaosConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModChaosConfig)
  return buffmodchaosconfig_;
}
inline ::pb::BuffModChaosConfig* BuffData::release_buffmodchaosconfig() {
  clear_has_buffmodchaosconfig();
  ::pb::BuffModChaosConfig* temp = buffmodchaosconfig_;
  buffmodchaosconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodchaosconfig(::pb::BuffModChaosConfig* buffmodchaosconfig) {
  delete buffmodchaosconfig_;
  buffmodchaosconfig_ = buffmodchaosconfig;
  if (buffmodchaosconfig) {
    set_has_buffmodchaosconfig();
  } else {
    clear_has_buffmodchaosconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModChaosConfig)
}

// optional .pb.BuffModRandomMoveConfig BuffModRandomMoveConfig = 12;
inline bool BuffData::has_buffmodrandommoveconfig() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void BuffData::set_has_buffmodrandommoveconfig() {
  _has_bits_[1] |= 0x00010000u;
}
inline void BuffData::clear_has_buffmodrandommoveconfig() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void BuffData::clear_buffmodrandommoveconfig() {
  if (buffmodrandommoveconfig_ != NULL) buffmodrandommoveconfig_->::pb::BuffModRandomMoveConfig::Clear();
  clear_has_buffmodrandommoveconfig();
}
inline const ::pb::BuffModRandomMoveConfig& BuffData::buffmodrandommoveconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRandomMoveConfig)
  return buffmodrandommoveconfig_ != NULL ? *buffmodrandommoveconfig_ : *default_instance_->buffmodrandommoveconfig_;
}
inline ::pb::BuffModRandomMoveConfig* BuffData::mutable_buffmodrandommoveconfig() {
  set_has_buffmodrandommoveconfig();
  if (buffmodrandommoveconfig_ == NULL) buffmodrandommoveconfig_ = new ::pb::BuffModRandomMoveConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRandomMoveConfig)
  return buffmodrandommoveconfig_;
}
inline ::pb::BuffModRandomMoveConfig* BuffData::release_buffmodrandommoveconfig() {
  clear_has_buffmodrandommoveconfig();
  ::pb::BuffModRandomMoveConfig* temp = buffmodrandommoveconfig_;
  buffmodrandommoveconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodrandommoveconfig(::pb::BuffModRandomMoveConfig* buffmodrandommoveconfig) {
  delete buffmodrandommoveconfig_;
  buffmodrandommoveconfig_ = buffmodrandommoveconfig;
  if (buffmodrandommoveconfig) {
    set_has_buffmodrandommoveconfig();
  } else {
    clear_has_buffmodrandommoveconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRandomMoveConfig)
}

// optional .pb.BuffModDamageCopyConfig BuffModDamageCopyConfig = 25;
inline bool BuffData::has_buffmoddamagecopyconfig() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void BuffData::set_has_buffmoddamagecopyconfig() {
  _has_bits_[1] |= 0x00020000u;
}
inline void BuffData::clear_has_buffmoddamagecopyconfig() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void BuffData::clear_buffmoddamagecopyconfig() {
  if (buffmoddamagecopyconfig_ != NULL) buffmoddamagecopyconfig_->::pb::BuffModDamageCopyConfig::Clear();
  clear_has_buffmoddamagecopyconfig();
}
inline const ::pb::BuffModDamageCopyConfig& BuffData::buffmoddamagecopyconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDamageCopyConfig)
  return buffmoddamagecopyconfig_ != NULL ? *buffmoddamagecopyconfig_ : *default_instance_->buffmoddamagecopyconfig_;
}
inline ::pb::BuffModDamageCopyConfig* BuffData::mutable_buffmoddamagecopyconfig() {
  set_has_buffmoddamagecopyconfig();
  if (buffmoddamagecopyconfig_ == NULL) buffmoddamagecopyconfig_ = new ::pb::BuffModDamageCopyConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDamageCopyConfig)
  return buffmoddamagecopyconfig_;
}
inline ::pb::BuffModDamageCopyConfig* BuffData::release_buffmoddamagecopyconfig() {
  clear_has_buffmoddamagecopyconfig();
  ::pb::BuffModDamageCopyConfig* temp = buffmoddamagecopyconfig_;
  buffmoddamagecopyconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddamagecopyconfig(::pb::BuffModDamageCopyConfig* buffmoddamagecopyconfig) {
  delete buffmoddamagecopyconfig_;
  buffmoddamagecopyconfig_ = buffmoddamagecopyconfig;
  if (buffmoddamagecopyconfig) {
    set_has_buffmoddamagecopyconfig();
  } else {
    clear_has_buffmoddamagecopyconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDamageCopyConfig)
}

// optional .pb.BuffModTauntConfig BuffModTauntConfig = 30;
inline bool BuffData::has_buffmodtauntconfig() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void BuffData::set_has_buffmodtauntconfig() {
  _has_bits_[1] |= 0x00040000u;
}
inline void BuffData::clear_has_buffmodtauntconfig() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void BuffData::clear_buffmodtauntconfig() {
  if (buffmodtauntconfig_ != NULL) buffmodtauntconfig_->::pb::BuffModTauntConfig::Clear();
  clear_has_buffmodtauntconfig();
}
inline const ::pb::BuffModTauntConfig& BuffData::buffmodtauntconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTauntConfig)
  return buffmodtauntconfig_ != NULL ? *buffmodtauntconfig_ : *default_instance_->buffmodtauntconfig_;
}
inline ::pb::BuffModTauntConfig* BuffData::mutable_buffmodtauntconfig() {
  set_has_buffmodtauntconfig();
  if (buffmodtauntconfig_ == NULL) buffmodtauntconfig_ = new ::pb::BuffModTauntConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTauntConfig)
  return buffmodtauntconfig_;
}
inline ::pb::BuffModTauntConfig* BuffData::release_buffmodtauntconfig() {
  clear_has_buffmodtauntconfig();
  ::pb::BuffModTauntConfig* temp = buffmodtauntconfig_;
  buffmodtauntconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtauntconfig(::pb::BuffModTauntConfig* buffmodtauntconfig) {
  delete buffmodtauntconfig_;
  buffmodtauntconfig_ = buffmodtauntconfig;
  if (buffmodtauntconfig) {
    set_has_buffmodtauntconfig();
  } else {
    clear_has_buffmodtauntconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTauntConfig)
}

// optional .pb.BuffModNoRageRecoverConfig BuffModNoRageRecoverConfig = 53;
inline bool BuffData::has_buffmodnoragerecoverconfig() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void BuffData::set_has_buffmodnoragerecoverconfig() {
  _has_bits_[1] |= 0x00080000u;
}
inline void BuffData::clear_has_buffmodnoragerecoverconfig() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void BuffData::clear_buffmodnoragerecoverconfig() {
  if (buffmodnoragerecoverconfig_ != NULL) buffmodnoragerecoverconfig_->::pb::BuffModNoRageRecoverConfig::Clear();
  clear_has_buffmodnoragerecoverconfig();
}
inline const ::pb::BuffModNoRageRecoverConfig& BuffData::buffmodnoragerecoverconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNoRageRecoverConfig)
  return buffmodnoragerecoverconfig_ != NULL ? *buffmodnoragerecoverconfig_ : *default_instance_->buffmodnoragerecoverconfig_;
}
inline ::pb::BuffModNoRageRecoverConfig* BuffData::mutable_buffmodnoragerecoverconfig() {
  set_has_buffmodnoragerecoverconfig();
  if (buffmodnoragerecoverconfig_ == NULL) buffmodnoragerecoverconfig_ = new ::pb::BuffModNoRageRecoverConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNoRageRecoverConfig)
  return buffmodnoragerecoverconfig_;
}
inline ::pb::BuffModNoRageRecoverConfig* BuffData::release_buffmodnoragerecoverconfig() {
  clear_has_buffmodnoragerecoverconfig();
  ::pb::BuffModNoRageRecoverConfig* temp = buffmodnoragerecoverconfig_;
  buffmodnoragerecoverconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnoragerecoverconfig(::pb::BuffModNoRageRecoverConfig* buffmodnoragerecoverconfig) {
  delete buffmodnoragerecoverconfig_;
  buffmodnoragerecoverconfig_ = buffmodnoragerecoverconfig;
  if (buffmodnoragerecoverconfig) {
    set_has_buffmodnoragerecoverconfig();
  } else {
    clear_has_buffmodnoragerecoverconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNoRageRecoverConfig)
}

// optional .pb.BuffModDisableConfig BuffModDisableConfig = 57;
inline bool BuffData::has_buffmoddisableconfig() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void BuffData::set_has_buffmoddisableconfig() {
  _has_bits_[1] |= 0x00100000u;
}
inline void BuffData::clear_has_buffmoddisableconfig() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void BuffData::clear_buffmoddisableconfig() {
  if (buffmoddisableconfig_ != NULL) buffmoddisableconfig_->::pb::BuffModDisableConfig::Clear();
  clear_has_buffmoddisableconfig();
}
inline const ::pb::BuffModDisableConfig& BuffData::buffmoddisableconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDisableConfig)
  return buffmoddisableconfig_ != NULL ? *buffmoddisableconfig_ : *default_instance_->buffmoddisableconfig_;
}
inline ::pb::BuffModDisableConfig* BuffData::mutable_buffmoddisableconfig() {
  set_has_buffmoddisableconfig();
  if (buffmoddisableconfig_ == NULL) buffmoddisableconfig_ = new ::pb::BuffModDisableConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDisableConfig)
  return buffmoddisableconfig_;
}
inline ::pb::BuffModDisableConfig* BuffData::release_buffmoddisableconfig() {
  clear_has_buffmoddisableconfig();
  ::pb::BuffModDisableConfig* temp = buffmoddisableconfig_;
  buffmoddisableconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddisableconfig(::pb::BuffModDisableConfig* buffmoddisableconfig) {
  delete buffmoddisableconfig_;
  buffmoddisableconfig_ = buffmoddisableconfig;
  if (buffmoddisableconfig) {
    set_has_buffmoddisableconfig();
  } else {
    clear_has_buffmoddisableconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDisableConfig)
}

// optional .pb.BuffModHarmOnMoveConfig BuffModHarmOnMoveConfig = 63;
inline bool BuffData::has_buffmodharmonmoveconfig() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void BuffData::set_has_buffmodharmonmoveconfig() {
  _has_bits_[1] |= 0x00200000u;
}
inline void BuffData::clear_has_buffmodharmonmoveconfig() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void BuffData::clear_buffmodharmonmoveconfig() {
  if (buffmodharmonmoveconfig_ != NULL) buffmodharmonmoveconfig_->::pb::BuffModHarmOnMoveConfig::Clear();
  clear_has_buffmodharmonmoveconfig();
}
inline const ::pb::BuffModHarmOnMoveConfig& BuffData::buffmodharmonmoveconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModHarmOnMoveConfig)
  return buffmodharmonmoveconfig_ != NULL ? *buffmodharmonmoveconfig_ : *default_instance_->buffmodharmonmoveconfig_;
}
inline ::pb::BuffModHarmOnMoveConfig* BuffData::mutable_buffmodharmonmoveconfig() {
  set_has_buffmodharmonmoveconfig();
  if (buffmodharmonmoveconfig_ == NULL) buffmodharmonmoveconfig_ = new ::pb::BuffModHarmOnMoveConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModHarmOnMoveConfig)
  return buffmodharmonmoveconfig_;
}
inline ::pb::BuffModHarmOnMoveConfig* BuffData::release_buffmodharmonmoveconfig() {
  clear_has_buffmodharmonmoveconfig();
  ::pb::BuffModHarmOnMoveConfig* temp = buffmodharmonmoveconfig_;
  buffmodharmonmoveconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodharmonmoveconfig(::pb::BuffModHarmOnMoveConfig* buffmodharmonmoveconfig) {
  delete buffmodharmonmoveconfig_;
  buffmodharmonmoveconfig_ = buffmodharmonmoveconfig;
  if (buffmodharmonmoveconfig) {
    set_has_buffmodharmonmoveconfig();
  } else {
    clear_has_buffmodharmonmoveconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModHarmOnMoveConfig)
}

// optional .pb.BuffModFearConfig BuffModFearConfig = 67;
inline bool BuffData::has_buffmodfearconfig() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void BuffData::set_has_buffmodfearconfig() {
  _has_bits_[1] |= 0x00400000u;
}
inline void BuffData::clear_has_buffmodfearconfig() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void BuffData::clear_buffmodfearconfig() {
  if (buffmodfearconfig_ != NULL) buffmodfearconfig_->::pb::BuffModFearConfig::Clear();
  clear_has_buffmodfearconfig();
}
inline const ::pb::BuffModFearConfig& BuffData::buffmodfearconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModFearConfig)
  return buffmodfearconfig_ != NULL ? *buffmodfearconfig_ : *default_instance_->buffmodfearconfig_;
}
inline ::pb::BuffModFearConfig* BuffData::mutable_buffmodfearconfig() {
  set_has_buffmodfearconfig();
  if (buffmodfearconfig_ == NULL) buffmodfearconfig_ = new ::pb::BuffModFearConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModFearConfig)
  return buffmodfearconfig_;
}
inline ::pb::BuffModFearConfig* BuffData::release_buffmodfearconfig() {
  clear_has_buffmodfearconfig();
  ::pb::BuffModFearConfig* temp = buffmodfearconfig_;
  buffmodfearconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodfearconfig(::pb::BuffModFearConfig* buffmodfearconfig) {
  delete buffmodfearconfig_;
  buffmodfearconfig_ = buffmodfearconfig;
  if (buffmodfearconfig) {
    set_has_buffmodfearconfig();
  } else {
    clear_has_buffmodfearconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModFearConfig)
}

// optional .pb.BuffModNoSuckBloodConfig BuffModNoSuckBloodConfig = 75;
inline bool BuffData::has_buffmodnosuckbloodconfig() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void BuffData::set_has_buffmodnosuckbloodconfig() {
  _has_bits_[1] |= 0x00800000u;
}
inline void BuffData::clear_has_buffmodnosuckbloodconfig() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void BuffData::clear_buffmodnosuckbloodconfig() {
  if (buffmodnosuckbloodconfig_ != NULL) buffmodnosuckbloodconfig_->::pb::BuffModNoSuckBloodConfig::Clear();
  clear_has_buffmodnosuckbloodconfig();
}
inline const ::pb::BuffModNoSuckBloodConfig& BuffData::buffmodnosuckbloodconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNoSuckBloodConfig)
  return buffmodnosuckbloodconfig_ != NULL ? *buffmodnosuckbloodconfig_ : *default_instance_->buffmodnosuckbloodconfig_;
}
inline ::pb::BuffModNoSuckBloodConfig* BuffData::mutable_buffmodnosuckbloodconfig() {
  set_has_buffmodnosuckbloodconfig();
  if (buffmodnosuckbloodconfig_ == NULL) buffmodnosuckbloodconfig_ = new ::pb::BuffModNoSuckBloodConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNoSuckBloodConfig)
  return buffmodnosuckbloodconfig_;
}
inline ::pb::BuffModNoSuckBloodConfig* BuffData::release_buffmodnosuckbloodconfig() {
  clear_has_buffmodnosuckbloodconfig();
  ::pb::BuffModNoSuckBloodConfig* temp = buffmodnosuckbloodconfig_;
  buffmodnosuckbloodconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnosuckbloodconfig(::pb::BuffModNoSuckBloodConfig* buffmodnosuckbloodconfig) {
  delete buffmodnosuckbloodconfig_;
  buffmodnosuckbloodconfig_ = buffmodnosuckbloodconfig;
  if (buffmodnosuckbloodconfig) {
    set_has_buffmodnosuckbloodconfig();
  } else {
    clear_has_buffmodnosuckbloodconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNoSuckBloodConfig)
}

// optional .pb.BuffModNoReviveConfig BuffModNoReviveConfig = 79;
inline bool BuffData::has_buffmodnoreviveconfig() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void BuffData::set_has_buffmodnoreviveconfig() {
  _has_bits_[1] |= 0x01000000u;
}
inline void BuffData::clear_has_buffmodnoreviveconfig() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void BuffData::clear_buffmodnoreviveconfig() {
  if (buffmodnoreviveconfig_ != NULL) buffmodnoreviveconfig_->::pb::BuffModNoReviveConfig::Clear();
  clear_has_buffmodnoreviveconfig();
}
inline const ::pb::BuffModNoReviveConfig& BuffData::buffmodnoreviveconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNoReviveConfig)
  return buffmodnoreviveconfig_ != NULL ? *buffmodnoreviveconfig_ : *default_instance_->buffmodnoreviveconfig_;
}
inline ::pb::BuffModNoReviveConfig* BuffData::mutable_buffmodnoreviveconfig() {
  set_has_buffmodnoreviveconfig();
  if (buffmodnoreviveconfig_ == NULL) buffmodnoreviveconfig_ = new ::pb::BuffModNoReviveConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNoReviveConfig)
  return buffmodnoreviveconfig_;
}
inline ::pb::BuffModNoReviveConfig* BuffData::release_buffmodnoreviveconfig() {
  clear_has_buffmodnoreviveconfig();
  ::pb::BuffModNoReviveConfig* temp = buffmodnoreviveconfig_;
  buffmodnoreviveconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnoreviveconfig(::pb::BuffModNoReviveConfig* buffmodnoreviveconfig) {
  delete buffmodnoreviveconfig_;
  buffmodnoreviveconfig_ = buffmodnoreviveconfig;
  if (buffmodnoreviveconfig) {
    set_has_buffmodnoreviveconfig();
  } else {
    clear_has_buffmodnoreviveconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNoReviveConfig)
}

// optional .pb.BuffModTransformationConfig BuffModTransformationConfig = 20;
inline bool BuffData::has_buffmodtransformationconfig() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void BuffData::set_has_buffmodtransformationconfig() {
  _has_bits_[1] |= 0x02000000u;
}
inline void BuffData::clear_has_buffmodtransformationconfig() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void BuffData::clear_buffmodtransformationconfig() {
  if (buffmodtransformationconfig_ != NULL) buffmodtransformationconfig_->::pb::BuffModTransformationConfig::Clear();
  clear_has_buffmodtransformationconfig();
}
inline const ::pb::BuffModTransformationConfig& BuffData::buffmodtransformationconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTransformationConfig)
  return buffmodtransformationconfig_ != NULL ? *buffmodtransformationconfig_ : *default_instance_->buffmodtransformationconfig_;
}
inline ::pb::BuffModTransformationConfig* BuffData::mutable_buffmodtransformationconfig() {
  set_has_buffmodtransformationconfig();
  if (buffmodtransformationconfig_ == NULL) buffmodtransformationconfig_ = new ::pb::BuffModTransformationConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTransformationConfig)
  return buffmodtransformationconfig_;
}
inline ::pb::BuffModTransformationConfig* BuffData::release_buffmodtransformationconfig() {
  clear_has_buffmodtransformationconfig();
  ::pb::BuffModTransformationConfig* temp = buffmodtransformationconfig_;
  buffmodtransformationconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtransformationconfig(::pb::BuffModTransformationConfig* buffmodtransformationconfig) {
  delete buffmodtransformationconfig_;
  buffmodtransformationconfig_ = buffmodtransformationconfig;
  if (buffmodtransformationconfig) {
    set_has_buffmodtransformationconfig();
  } else {
    clear_has_buffmodtransformationconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTransformationConfig)
}

// optional .pb.BuffModNothingConfig BuffModNothingConfig = 4;
inline bool BuffData::has_buffmodnothingconfig() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void BuffData::set_has_buffmodnothingconfig() {
  _has_bits_[1] |= 0x04000000u;
}
inline void BuffData::clear_has_buffmodnothingconfig() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void BuffData::clear_buffmodnothingconfig() {
  if (buffmodnothingconfig_ != NULL) buffmodnothingconfig_->::pb::BuffModNothingConfig::Clear();
  clear_has_buffmodnothingconfig();
}
inline const ::pb::BuffModNothingConfig& BuffData::buffmodnothingconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModNothingConfig)
  return buffmodnothingconfig_ != NULL ? *buffmodnothingconfig_ : *default_instance_->buffmodnothingconfig_;
}
inline ::pb::BuffModNothingConfig* BuffData::mutable_buffmodnothingconfig() {
  set_has_buffmodnothingconfig();
  if (buffmodnothingconfig_ == NULL) buffmodnothingconfig_ = new ::pb::BuffModNothingConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModNothingConfig)
  return buffmodnothingconfig_;
}
inline ::pb::BuffModNothingConfig* BuffData::release_buffmodnothingconfig() {
  clear_has_buffmodnothingconfig();
  ::pb::BuffModNothingConfig* temp = buffmodnothingconfig_;
  buffmodnothingconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodnothingconfig(::pb::BuffModNothingConfig* buffmodnothingconfig) {
  delete buffmodnothingconfig_;
  buffmodnothingconfig_ = buffmodnothingconfig;
  if (buffmodnothingconfig) {
    set_has_buffmodnothingconfig();
  } else {
    clear_has_buffmodnothingconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModNothingConfig)
}

// optional .pb.BuffModTransformScaleConfig BuffModTransformScaleConfig = 13;
inline bool BuffData::has_buffmodtransformscaleconfig() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void BuffData::set_has_buffmodtransformscaleconfig() {
  _has_bits_[1] |= 0x08000000u;
}
inline void BuffData::clear_has_buffmodtransformscaleconfig() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void BuffData::clear_buffmodtransformscaleconfig() {
  if (buffmodtransformscaleconfig_ != NULL) buffmodtransformscaleconfig_->::pb::BuffModTransformScaleConfig::Clear();
  clear_has_buffmodtransformscaleconfig();
}
inline const ::pb::BuffModTransformScaleConfig& BuffData::buffmodtransformscaleconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTransformScaleConfig)
  return buffmodtransformscaleconfig_ != NULL ? *buffmodtransformscaleconfig_ : *default_instance_->buffmodtransformscaleconfig_;
}
inline ::pb::BuffModTransformScaleConfig* BuffData::mutable_buffmodtransformscaleconfig() {
  set_has_buffmodtransformscaleconfig();
  if (buffmodtransformscaleconfig_ == NULL) buffmodtransformscaleconfig_ = new ::pb::BuffModTransformScaleConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTransformScaleConfig)
  return buffmodtransformscaleconfig_;
}
inline ::pb::BuffModTransformScaleConfig* BuffData::release_buffmodtransformscaleconfig() {
  clear_has_buffmodtransformscaleconfig();
  ::pb::BuffModTransformScaleConfig* temp = buffmodtransformscaleconfig_;
  buffmodtransformscaleconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtransformscaleconfig(::pb::BuffModTransformScaleConfig* buffmodtransformscaleconfig) {
  delete buffmodtransformscaleconfig_;
  buffmodtransformscaleconfig_ = buffmodtransformscaleconfig;
  if (buffmodtransformscaleconfig) {
    set_has_buffmodtransformscaleconfig();
  } else {
    clear_has_buffmodtransformscaleconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTransformScaleConfig)
}

// optional .pb.BuffModDieConfig BuffModDieConfig = 15;
inline bool BuffData::has_buffmoddieconfig() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void BuffData::set_has_buffmoddieconfig() {
  _has_bits_[1] |= 0x10000000u;
}
inline void BuffData::clear_has_buffmoddieconfig() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void BuffData::clear_buffmoddieconfig() {
  if (buffmoddieconfig_ != NULL) buffmoddieconfig_->::pb::BuffModDieConfig::Clear();
  clear_has_buffmoddieconfig();
}
inline const ::pb::BuffModDieConfig& BuffData::buffmoddieconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModDieConfig)
  return buffmoddieconfig_ != NULL ? *buffmoddieconfig_ : *default_instance_->buffmoddieconfig_;
}
inline ::pb::BuffModDieConfig* BuffData::mutable_buffmoddieconfig() {
  set_has_buffmoddieconfig();
  if (buffmoddieconfig_ == NULL) buffmoddieconfig_ = new ::pb::BuffModDieConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModDieConfig)
  return buffmoddieconfig_;
}
inline ::pb::BuffModDieConfig* BuffData::release_buffmoddieconfig() {
  clear_has_buffmoddieconfig();
  ::pb::BuffModDieConfig* temp = buffmoddieconfig_;
  buffmoddieconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmoddieconfig(::pb::BuffModDieConfig* buffmoddieconfig) {
  delete buffmoddieconfig_;
  buffmoddieconfig_ = buffmoddieconfig;
  if (buffmoddieconfig) {
    set_has_buffmoddieconfig();
  } else {
    clear_has_buffmoddieconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModDieConfig)
}

// optional .pb.BuffModRepeatSkillConfig BuffModRepeatSkillConfig = 23;
inline bool BuffData::has_buffmodrepeatskillconfig() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void BuffData::set_has_buffmodrepeatskillconfig() {
  _has_bits_[1] |= 0x20000000u;
}
inline void BuffData::clear_has_buffmodrepeatskillconfig() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void BuffData::clear_buffmodrepeatskillconfig() {
  if (buffmodrepeatskillconfig_ != NULL) buffmodrepeatskillconfig_->::pb::BuffModRepeatSkillConfig::Clear();
  clear_has_buffmodrepeatskillconfig();
}
inline const ::pb::BuffModRepeatSkillConfig& BuffData::buffmodrepeatskillconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRepeatSkillConfig)
  return buffmodrepeatskillconfig_ != NULL ? *buffmodrepeatskillconfig_ : *default_instance_->buffmodrepeatskillconfig_;
}
inline ::pb::BuffModRepeatSkillConfig* BuffData::mutable_buffmodrepeatskillconfig() {
  set_has_buffmodrepeatskillconfig();
  if (buffmodrepeatskillconfig_ == NULL) buffmodrepeatskillconfig_ = new ::pb::BuffModRepeatSkillConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRepeatSkillConfig)
  return buffmodrepeatskillconfig_;
}
inline ::pb::BuffModRepeatSkillConfig* BuffData::release_buffmodrepeatskillconfig() {
  clear_has_buffmodrepeatskillconfig();
  ::pb::BuffModRepeatSkillConfig* temp = buffmodrepeatskillconfig_;
  buffmodrepeatskillconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodrepeatskillconfig(::pb::BuffModRepeatSkillConfig* buffmodrepeatskillconfig) {
  delete buffmodrepeatskillconfig_;
  buffmodrepeatskillconfig_ = buffmodrepeatskillconfig;
  if (buffmodrepeatskillconfig) {
    set_has_buffmodrepeatskillconfig();
  } else {
    clear_has_buffmodrepeatskillconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRepeatSkillConfig)
}

// optional .pb.BuffModSkillOnEndConfig BuffModSkillOnEndConfig = 29;
inline bool BuffData::has_buffmodskillonendconfig() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void BuffData::set_has_buffmodskillonendconfig() {
  _has_bits_[1] |= 0x40000000u;
}
inline void BuffData::clear_has_buffmodskillonendconfig() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void BuffData::clear_buffmodskillonendconfig() {
  if (buffmodskillonendconfig_ != NULL) buffmodskillonendconfig_->::pb::BuffModSkillOnEndConfig::Clear();
  clear_has_buffmodskillonendconfig();
}
inline const ::pb::BuffModSkillOnEndConfig& BuffData::buffmodskillonendconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModSkillOnEndConfig)
  return buffmodskillonendconfig_ != NULL ? *buffmodskillonendconfig_ : *default_instance_->buffmodskillonendconfig_;
}
inline ::pb::BuffModSkillOnEndConfig* BuffData::mutable_buffmodskillonendconfig() {
  set_has_buffmodskillonendconfig();
  if (buffmodskillonendconfig_ == NULL) buffmodskillonendconfig_ = new ::pb::BuffModSkillOnEndConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModSkillOnEndConfig)
  return buffmodskillonendconfig_;
}
inline ::pb::BuffModSkillOnEndConfig* BuffData::release_buffmodskillonendconfig() {
  clear_has_buffmodskillonendconfig();
  ::pb::BuffModSkillOnEndConfig* temp = buffmodskillonendconfig_;
  buffmodskillonendconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodskillonendconfig(::pb::BuffModSkillOnEndConfig* buffmodskillonendconfig) {
  delete buffmodskillonendconfig_;
  buffmodskillonendconfig_ = buffmodskillonendconfig;
  if (buffmodskillonendconfig) {
    set_has_buffmodskillonendconfig();
  } else {
    clear_has_buffmodskillonendconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModSkillOnEndConfig)
}

// optional .pb.BuffModSpecifySkillTidConfig BuffModSpecifySkillTidConfig = 39;
inline bool BuffData::has_buffmodspecifyskilltidconfig() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void BuffData::set_has_buffmodspecifyskilltidconfig() {
  _has_bits_[1] |= 0x80000000u;
}
inline void BuffData::clear_has_buffmodspecifyskilltidconfig() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void BuffData::clear_buffmodspecifyskilltidconfig() {
  if (buffmodspecifyskilltidconfig_ != NULL) buffmodspecifyskilltidconfig_->::pb::BuffModSpecifySkillTidConfig::Clear();
  clear_has_buffmodspecifyskilltidconfig();
}
inline const ::pb::BuffModSpecifySkillTidConfig& BuffData::buffmodspecifyskilltidconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModSpecifySkillTidConfig)
  return buffmodspecifyskilltidconfig_ != NULL ? *buffmodspecifyskilltidconfig_ : *default_instance_->buffmodspecifyskilltidconfig_;
}
inline ::pb::BuffModSpecifySkillTidConfig* BuffData::mutable_buffmodspecifyskilltidconfig() {
  set_has_buffmodspecifyskilltidconfig();
  if (buffmodspecifyskilltidconfig_ == NULL) buffmodspecifyskilltidconfig_ = new ::pb::BuffModSpecifySkillTidConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModSpecifySkillTidConfig)
  return buffmodspecifyskilltidconfig_;
}
inline ::pb::BuffModSpecifySkillTidConfig* BuffData::release_buffmodspecifyskilltidconfig() {
  clear_has_buffmodspecifyskilltidconfig();
  ::pb::BuffModSpecifySkillTidConfig* temp = buffmodspecifyskilltidconfig_;
  buffmodspecifyskilltidconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodspecifyskilltidconfig(::pb::BuffModSpecifySkillTidConfig* buffmodspecifyskilltidconfig) {
  delete buffmodspecifyskilltidconfig_;
  buffmodspecifyskilltidconfig_ = buffmodspecifyskilltidconfig;
  if (buffmodspecifyskilltidconfig) {
    set_has_buffmodspecifyskilltidconfig();
  } else {
    clear_has_buffmodspecifyskilltidconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModSpecifySkillTidConfig)
}

// optional .pb.BuffModResetBuffTimeConfig BuffModResetBuffTimeConfig = 44;
inline bool BuffData::has_buffmodresetbufftimeconfig() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void BuffData::set_has_buffmodresetbufftimeconfig() {
  _has_bits_[2] |= 0x00000001u;
}
inline void BuffData::clear_has_buffmodresetbufftimeconfig() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void BuffData::clear_buffmodresetbufftimeconfig() {
  if (buffmodresetbufftimeconfig_ != NULL) buffmodresetbufftimeconfig_->::pb::BuffModResetBuffTimeConfig::Clear();
  clear_has_buffmodresetbufftimeconfig();
}
inline const ::pb::BuffModResetBuffTimeConfig& BuffData::buffmodresetbufftimeconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModResetBuffTimeConfig)
  return buffmodresetbufftimeconfig_ != NULL ? *buffmodresetbufftimeconfig_ : *default_instance_->buffmodresetbufftimeconfig_;
}
inline ::pb::BuffModResetBuffTimeConfig* BuffData::mutable_buffmodresetbufftimeconfig() {
  set_has_buffmodresetbufftimeconfig();
  if (buffmodresetbufftimeconfig_ == NULL) buffmodresetbufftimeconfig_ = new ::pb::BuffModResetBuffTimeConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModResetBuffTimeConfig)
  return buffmodresetbufftimeconfig_;
}
inline ::pb::BuffModResetBuffTimeConfig* BuffData::release_buffmodresetbufftimeconfig() {
  clear_has_buffmodresetbufftimeconfig();
  ::pb::BuffModResetBuffTimeConfig* temp = buffmodresetbufftimeconfig_;
  buffmodresetbufftimeconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodresetbufftimeconfig(::pb::BuffModResetBuffTimeConfig* buffmodresetbufftimeconfig) {
  delete buffmodresetbufftimeconfig_;
  buffmodresetbufftimeconfig_ = buffmodresetbufftimeconfig;
  if (buffmodresetbufftimeconfig) {
    set_has_buffmodresetbufftimeconfig();
  } else {
    clear_has_buffmodresetbufftimeconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModResetBuffTimeConfig)
}

// optional .pb.BuffModAddSkillConfig BuffModAddSkillConfig = 45;
inline bool BuffData::has_buffmodaddskillconfig() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void BuffData::set_has_buffmodaddskillconfig() {
  _has_bits_[2] |= 0x00000002u;
}
inline void BuffData::clear_has_buffmodaddskillconfig() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void BuffData::clear_buffmodaddskillconfig() {
  if (buffmodaddskillconfig_ != NULL) buffmodaddskillconfig_->::pb::BuffModAddSkillConfig::Clear();
  clear_has_buffmodaddskillconfig();
}
inline const ::pb::BuffModAddSkillConfig& BuffData::buffmodaddskillconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModAddSkillConfig)
  return buffmodaddskillconfig_ != NULL ? *buffmodaddskillconfig_ : *default_instance_->buffmodaddskillconfig_;
}
inline ::pb::BuffModAddSkillConfig* BuffData::mutable_buffmodaddskillconfig() {
  set_has_buffmodaddskillconfig();
  if (buffmodaddskillconfig_ == NULL) buffmodaddskillconfig_ = new ::pb::BuffModAddSkillConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModAddSkillConfig)
  return buffmodaddskillconfig_;
}
inline ::pb::BuffModAddSkillConfig* BuffData::release_buffmodaddskillconfig() {
  clear_has_buffmodaddskillconfig();
  ::pb::BuffModAddSkillConfig* temp = buffmodaddskillconfig_;
  buffmodaddskillconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodaddskillconfig(::pb::BuffModAddSkillConfig* buffmodaddskillconfig) {
  delete buffmodaddskillconfig_;
  buffmodaddskillconfig_ = buffmodaddskillconfig;
  if (buffmodaddskillconfig) {
    set_has_buffmodaddskillconfig();
  } else {
    clear_has_buffmodaddskillconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModAddSkillConfig)
}

// optional .pb.BuffModPropertyFormulaConfig BuffModPropertyFormulaConfig = 46;
inline bool BuffData::has_buffmodpropertyformulaconfig() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void BuffData::set_has_buffmodpropertyformulaconfig() {
  _has_bits_[2] |= 0x00000004u;
}
inline void BuffData::clear_has_buffmodpropertyformulaconfig() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void BuffData::clear_buffmodpropertyformulaconfig() {
  if (buffmodpropertyformulaconfig_ != NULL) buffmodpropertyformulaconfig_->::pb::BuffModPropertyFormulaConfig::Clear();
  clear_has_buffmodpropertyformulaconfig();
}
inline const ::pb::BuffModPropertyFormulaConfig& BuffData::buffmodpropertyformulaconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModPropertyFormulaConfig)
  return buffmodpropertyformulaconfig_ != NULL ? *buffmodpropertyformulaconfig_ : *default_instance_->buffmodpropertyformulaconfig_;
}
inline ::pb::BuffModPropertyFormulaConfig* BuffData::mutable_buffmodpropertyformulaconfig() {
  set_has_buffmodpropertyformulaconfig();
  if (buffmodpropertyformulaconfig_ == NULL) buffmodpropertyformulaconfig_ = new ::pb::BuffModPropertyFormulaConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModPropertyFormulaConfig)
  return buffmodpropertyformulaconfig_;
}
inline ::pb::BuffModPropertyFormulaConfig* BuffData::release_buffmodpropertyformulaconfig() {
  clear_has_buffmodpropertyformulaconfig();
  ::pb::BuffModPropertyFormulaConfig* temp = buffmodpropertyformulaconfig_;
  buffmodpropertyformulaconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodpropertyformulaconfig(::pb::BuffModPropertyFormulaConfig* buffmodpropertyformulaconfig) {
  delete buffmodpropertyformulaconfig_;
  buffmodpropertyformulaconfig_ = buffmodpropertyformulaconfig;
  if (buffmodpropertyformulaconfig) {
    set_has_buffmodpropertyformulaconfig();
  } else {
    clear_has_buffmodpropertyformulaconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModPropertyFormulaConfig)
}

// optional .pb.BuffModEffectInRangeConfig BuffModEffectInRangeConfig = 47;
inline bool BuffData::has_buffmodeffectinrangeconfig() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void BuffData::set_has_buffmodeffectinrangeconfig() {
  _has_bits_[2] |= 0x00000008u;
}
inline void BuffData::clear_has_buffmodeffectinrangeconfig() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void BuffData::clear_buffmodeffectinrangeconfig() {
  if (buffmodeffectinrangeconfig_ != NULL) buffmodeffectinrangeconfig_->::pb::BuffModEffectInRangeConfig::Clear();
  clear_has_buffmodeffectinrangeconfig();
}
inline const ::pb::BuffModEffectInRangeConfig& BuffData::buffmodeffectinrangeconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModEffectInRangeConfig)
  return buffmodeffectinrangeconfig_ != NULL ? *buffmodeffectinrangeconfig_ : *default_instance_->buffmodeffectinrangeconfig_;
}
inline ::pb::BuffModEffectInRangeConfig* BuffData::mutable_buffmodeffectinrangeconfig() {
  set_has_buffmodeffectinrangeconfig();
  if (buffmodeffectinrangeconfig_ == NULL) buffmodeffectinrangeconfig_ = new ::pb::BuffModEffectInRangeConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModEffectInRangeConfig)
  return buffmodeffectinrangeconfig_;
}
inline ::pb::BuffModEffectInRangeConfig* BuffData::release_buffmodeffectinrangeconfig() {
  clear_has_buffmodeffectinrangeconfig();
  ::pb::BuffModEffectInRangeConfig* temp = buffmodeffectinrangeconfig_;
  buffmodeffectinrangeconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodeffectinrangeconfig(::pb::BuffModEffectInRangeConfig* buffmodeffectinrangeconfig) {
  delete buffmodeffectinrangeconfig_;
  buffmodeffectinrangeconfig_ = buffmodeffectinrangeconfig;
  if (buffmodeffectinrangeconfig) {
    set_has_buffmodeffectinrangeconfig();
  } else {
    clear_has_buffmodeffectinrangeconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModEffectInRangeConfig)
}

// optional .pb.BuffModRecordDataConfig BuffModRecordDataConfig = 48;
inline bool BuffData::has_buffmodrecorddataconfig() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void BuffData::set_has_buffmodrecorddataconfig() {
  _has_bits_[2] |= 0x00000010u;
}
inline void BuffData::clear_has_buffmodrecorddataconfig() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void BuffData::clear_buffmodrecorddataconfig() {
  if (buffmodrecorddataconfig_ != NULL) buffmodrecorddataconfig_->::pb::BuffModRecordDataConfig::Clear();
  clear_has_buffmodrecorddataconfig();
}
inline const ::pb::BuffModRecordDataConfig& BuffData::buffmodrecorddataconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRecordDataConfig)
  return buffmodrecorddataconfig_ != NULL ? *buffmodrecorddataconfig_ : *default_instance_->buffmodrecorddataconfig_;
}
inline ::pb::BuffModRecordDataConfig* BuffData::mutable_buffmodrecorddataconfig() {
  set_has_buffmodrecorddataconfig();
  if (buffmodrecorddataconfig_ == NULL) buffmodrecorddataconfig_ = new ::pb::BuffModRecordDataConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRecordDataConfig)
  return buffmodrecorddataconfig_;
}
inline ::pb::BuffModRecordDataConfig* BuffData::release_buffmodrecorddataconfig() {
  clear_has_buffmodrecorddataconfig();
  ::pb::BuffModRecordDataConfig* temp = buffmodrecorddataconfig_;
  buffmodrecorddataconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodrecorddataconfig(::pb::BuffModRecordDataConfig* buffmodrecorddataconfig) {
  delete buffmodrecorddataconfig_;
  buffmodrecorddataconfig_ = buffmodrecorddataconfig;
  if (buffmodrecorddataconfig) {
    set_has_buffmodrecorddataconfig();
  } else {
    clear_has_buffmodrecorddataconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRecordDataConfig)
}

// optional .pb.BuffModSkillOnEndConfig BuffModSkillOnEndBConfig = 49;
inline bool BuffData::has_buffmodskillonendbconfig() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void BuffData::set_has_buffmodskillonendbconfig() {
  _has_bits_[2] |= 0x00000020u;
}
inline void BuffData::clear_has_buffmodskillonendbconfig() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void BuffData::clear_buffmodskillonendbconfig() {
  if (buffmodskillonendbconfig_ != NULL) buffmodskillonendbconfig_->::pb::BuffModSkillOnEndConfig::Clear();
  clear_has_buffmodskillonendbconfig();
}
inline const ::pb::BuffModSkillOnEndConfig& BuffData::buffmodskillonendbconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModSkillOnEndBConfig)
  return buffmodskillonendbconfig_ != NULL ? *buffmodskillonendbconfig_ : *default_instance_->buffmodskillonendbconfig_;
}
inline ::pb::BuffModSkillOnEndConfig* BuffData::mutable_buffmodskillonendbconfig() {
  set_has_buffmodskillonendbconfig();
  if (buffmodskillonendbconfig_ == NULL) buffmodskillonendbconfig_ = new ::pb::BuffModSkillOnEndConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModSkillOnEndBConfig)
  return buffmodskillonendbconfig_;
}
inline ::pb::BuffModSkillOnEndConfig* BuffData::release_buffmodskillonendbconfig() {
  clear_has_buffmodskillonendbconfig();
  ::pb::BuffModSkillOnEndConfig* temp = buffmodskillonendbconfig_;
  buffmodskillonendbconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodskillonendbconfig(::pb::BuffModSkillOnEndConfig* buffmodskillonendbconfig) {
  delete buffmodskillonendbconfig_;
  buffmodskillonendbconfig_ = buffmodskillonendbconfig;
  if (buffmodskillonendbconfig) {
    set_has_buffmodskillonendbconfig();
  } else {
    clear_has_buffmodskillonendbconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModSkillOnEndBConfig)
}

// optional .pb.BuffModHideSomeAppearanceConfig BuffModHideSomeAppearanceConfig = 51;
inline bool BuffData::has_buffmodhidesomeappearanceconfig() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void BuffData::set_has_buffmodhidesomeappearanceconfig() {
  _has_bits_[2] |= 0x00000040u;
}
inline void BuffData::clear_has_buffmodhidesomeappearanceconfig() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void BuffData::clear_buffmodhidesomeappearanceconfig() {
  if (buffmodhidesomeappearanceconfig_ != NULL) buffmodhidesomeappearanceconfig_->::pb::BuffModHideSomeAppearanceConfig::Clear();
  clear_has_buffmodhidesomeappearanceconfig();
}
inline const ::pb::BuffModHideSomeAppearanceConfig& BuffData::buffmodhidesomeappearanceconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModHideSomeAppearanceConfig)
  return buffmodhidesomeappearanceconfig_ != NULL ? *buffmodhidesomeappearanceconfig_ : *default_instance_->buffmodhidesomeappearanceconfig_;
}
inline ::pb::BuffModHideSomeAppearanceConfig* BuffData::mutable_buffmodhidesomeappearanceconfig() {
  set_has_buffmodhidesomeappearanceconfig();
  if (buffmodhidesomeappearanceconfig_ == NULL) buffmodhidesomeappearanceconfig_ = new ::pb::BuffModHideSomeAppearanceConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModHideSomeAppearanceConfig)
  return buffmodhidesomeappearanceconfig_;
}
inline ::pb::BuffModHideSomeAppearanceConfig* BuffData::release_buffmodhidesomeappearanceconfig() {
  clear_has_buffmodhidesomeappearanceconfig();
  ::pb::BuffModHideSomeAppearanceConfig* temp = buffmodhidesomeappearanceconfig_;
  buffmodhidesomeappearanceconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodhidesomeappearanceconfig(::pb::BuffModHideSomeAppearanceConfig* buffmodhidesomeappearanceconfig) {
  delete buffmodhidesomeappearanceconfig_;
  buffmodhidesomeappearanceconfig_ = buffmodhidesomeappearanceconfig;
  if (buffmodhidesomeappearanceconfig) {
    set_has_buffmodhidesomeappearanceconfig();
  } else {
    clear_has_buffmodhidesomeappearanceconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModHideSomeAppearanceConfig)
}

// optional .pb.BuffModInheritExistBuffStackConfig BuffModInheritExistBuffStackConfig = 54;
inline bool BuffData::has_buffmodinheritexistbuffstackconfig() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void BuffData::set_has_buffmodinheritexistbuffstackconfig() {
  _has_bits_[2] |= 0x00000080u;
}
inline void BuffData::clear_has_buffmodinheritexistbuffstackconfig() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void BuffData::clear_buffmodinheritexistbuffstackconfig() {
  if (buffmodinheritexistbuffstackconfig_ != NULL) buffmodinheritexistbuffstackconfig_->::pb::BuffModInheritExistBuffStackConfig::Clear();
  clear_has_buffmodinheritexistbuffstackconfig();
}
inline const ::pb::BuffModInheritExistBuffStackConfig& BuffData::buffmodinheritexistbuffstackconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModInheritExistBuffStackConfig)
  return buffmodinheritexistbuffstackconfig_ != NULL ? *buffmodinheritexistbuffstackconfig_ : *default_instance_->buffmodinheritexistbuffstackconfig_;
}
inline ::pb::BuffModInheritExistBuffStackConfig* BuffData::mutable_buffmodinheritexistbuffstackconfig() {
  set_has_buffmodinheritexistbuffstackconfig();
  if (buffmodinheritexistbuffstackconfig_ == NULL) buffmodinheritexistbuffstackconfig_ = new ::pb::BuffModInheritExistBuffStackConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModInheritExistBuffStackConfig)
  return buffmodinheritexistbuffstackconfig_;
}
inline ::pb::BuffModInheritExistBuffStackConfig* BuffData::release_buffmodinheritexistbuffstackconfig() {
  clear_has_buffmodinheritexistbuffstackconfig();
  ::pb::BuffModInheritExistBuffStackConfig* temp = buffmodinheritexistbuffstackconfig_;
  buffmodinheritexistbuffstackconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodinheritexistbuffstackconfig(::pb::BuffModInheritExistBuffStackConfig* buffmodinheritexistbuffstackconfig) {
  delete buffmodinheritexistbuffstackconfig_;
  buffmodinheritexistbuffstackconfig_ = buffmodinheritexistbuffstackconfig;
  if (buffmodinheritexistbuffstackconfig) {
    set_has_buffmodinheritexistbuffstackconfig();
  } else {
    clear_has_buffmodinheritexistbuffstackconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModInheritExistBuffStackConfig)
}

// optional .pb.BuffModScaleTextConfig BuffModScaleTextConfig = 58;
inline bool BuffData::has_buffmodscaletextconfig() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void BuffData::set_has_buffmodscaletextconfig() {
  _has_bits_[2] |= 0x00000100u;
}
inline void BuffData::clear_has_buffmodscaletextconfig() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void BuffData::clear_buffmodscaletextconfig() {
  if (buffmodscaletextconfig_ != NULL) buffmodscaletextconfig_->::pb::BuffModScaleTextConfig::Clear();
  clear_has_buffmodscaletextconfig();
}
inline const ::pb::BuffModScaleTextConfig& BuffData::buffmodscaletextconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModScaleTextConfig)
  return buffmodscaletextconfig_ != NULL ? *buffmodscaletextconfig_ : *default_instance_->buffmodscaletextconfig_;
}
inline ::pb::BuffModScaleTextConfig* BuffData::mutable_buffmodscaletextconfig() {
  set_has_buffmodscaletextconfig();
  if (buffmodscaletextconfig_ == NULL) buffmodscaletextconfig_ = new ::pb::BuffModScaleTextConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModScaleTextConfig)
  return buffmodscaletextconfig_;
}
inline ::pb::BuffModScaleTextConfig* BuffData::release_buffmodscaletextconfig() {
  clear_has_buffmodscaletextconfig();
  ::pb::BuffModScaleTextConfig* temp = buffmodscaletextconfig_;
  buffmodscaletextconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodscaletextconfig(::pb::BuffModScaleTextConfig* buffmodscaletextconfig) {
  delete buffmodscaletextconfig_;
  buffmodscaletextconfig_ = buffmodscaletextconfig;
  if (buffmodscaletextconfig) {
    set_has_buffmodscaletextconfig();
  } else {
    clear_has_buffmodscaletextconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModScaleTextConfig)
}

// optional .pb.BuffModAddDefPointConfig BuffModAddDefPointConfig = 59;
inline bool BuffData::has_buffmodadddefpointconfig() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void BuffData::set_has_buffmodadddefpointconfig() {
  _has_bits_[2] |= 0x00000200u;
}
inline void BuffData::clear_has_buffmodadddefpointconfig() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void BuffData::clear_buffmodadddefpointconfig() {
  if (buffmodadddefpointconfig_ != NULL) buffmodadddefpointconfig_->::pb::BuffModAddDefPointConfig::Clear();
  clear_has_buffmodadddefpointconfig();
}
inline const ::pb::BuffModAddDefPointConfig& BuffData::buffmodadddefpointconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModAddDefPointConfig)
  return buffmodadddefpointconfig_ != NULL ? *buffmodadddefpointconfig_ : *default_instance_->buffmodadddefpointconfig_;
}
inline ::pb::BuffModAddDefPointConfig* BuffData::mutable_buffmodadddefpointconfig() {
  set_has_buffmodadddefpointconfig();
  if (buffmodadddefpointconfig_ == NULL) buffmodadddefpointconfig_ = new ::pb::BuffModAddDefPointConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModAddDefPointConfig)
  return buffmodadddefpointconfig_;
}
inline ::pb::BuffModAddDefPointConfig* BuffData::release_buffmodadddefpointconfig() {
  clear_has_buffmodadddefpointconfig();
  ::pb::BuffModAddDefPointConfig* temp = buffmodadddefpointconfig_;
  buffmodadddefpointconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodadddefpointconfig(::pb::BuffModAddDefPointConfig* buffmodadddefpointconfig) {
  delete buffmodadddefpointconfig_;
  buffmodadddefpointconfig_ = buffmodadddefpointconfig;
  if (buffmodadddefpointconfig) {
    set_has_buffmodadddefpointconfig();
  } else {
    clear_has_buffmodadddefpointconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModAddDefPointConfig)
}

// optional .pb.BuffModRemoveDefPointConfig BuffModRemoveDefPointConfig = 60;
inline bool BuffData::has_buffmodremovedefpointconfig() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void BuffData::set_has_buffmodremovedefpointconfig() {
  _has_bits_[2] |= 0x00000400u;
}
inline void BuffData::clear_has_buffmodremovedefpointconfig() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void BuffData::clear_buffmodremovedefpointconfig() {
  if (buffmodremovedefpointconfig_ != NULL) buffmodremovedefpointconfig_->::pb::BuffModRemoveDefPointConfig::Clear();
  clear_has_buffmodremovedefpointconfig();
}
inline const ::pb::BuffModRemoveDefPointConfig& BuffData::buffmodremovedefpointconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModRemoveDefPointConfig)
  return buffmodremovedefpointconfig_ != NULL ? *buffmodremovedefpointconfig_ : *default_instance_->buffmodremovedefpointconfig_;
}
inline ::pb::BuffModRemoveDefPointConfig* BuffData::mutable_buffmodremovedefpointconfig() {
  set_has_buffmodremovedefpointconfig();
  if (buffmodremovedefpointconfig_ == NULL) buffmodremovedefpointconfig_ = new ::pb::BuffModRemoveDefPointConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModRemoveDefPointConfig)
  return buffmodremovedefpointconfig_;
}
inline ::pb::BuffModRemoveDefPointConfig* BuffData::release_buffmodremovedefpointconfig() {
  clear_has_buffmodremovedefpointconfig();
  ::pb::BuffModRemoveDefPointConfig* temp = buffmodremovedefpointconfig_;
  buffmodremovedefpointconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodremovedefpointconfig(::pb::BuffModRemoveDefPointConfig* buffmodremovedefpointconfig) {
  delete buffmodremovedefpointconfig_;
  buffmodremovedefpointconfig_ = buffmodremovedefpointconfig;
  if (buffmodremovedefpointconfig) {
    set_has_buffmodremovedefpointconfig();
  } else {
    clear_has_buffmodremovedefpointconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModRemoveDefPointConfig)
}

// optional .pb.BuffModEffectInRangeConditionConfig BuffModEffectInRangeConditionConfig = 61;
inline bool BuffData::has_buffmodeffectinrangeconditionconfig() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void BuffData::set_has_buffmodeffectinrangeconditionconfig() {
  _has_bits_[2] |= 0x00000800u;
}
inline void BuffData::clear_has_buffmodeffectinrangeconditionconfig() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void BuffData::clear_buffmodeffectinrangeconditionconfig() {
  if (buffmodeffectinrangeconditionconfig_ != NULL) buffmodeffectinrangeconditionconfig_->::pb::BuffModEffectInRangeConditionConfig::Clear();
  clear_has_buffmodeffectinrangeconditionconfig();
}
inline const ::pb::BuffModEffectInRangeConditionConfig& BuffData::buffmodeffectinrangeconditionconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModEffectInRangeConditionConfig)
  return buffmodeffectinrangeconditionconfig_ != NULL ? *buffmodeffectinrangeconditionconfig_ : *default_instance_->buffmodeffectinrangeconditionconfig_;
}
inline ::pb::BuffModEffectInRangeConditionConfig* BuffData::mutable_buffmodeffectinrangeconditionconfig() {
  set_has_buffmodeffectinrangeconditionconfig();
  if (buffmodeffectinrangeconditionconfig_ == NULL) buffmodeffectinrangeconditionconfig_ = new ::pb::BuffModEffectInRangeConditionConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModEffectInRangeConditionConfig)
  return buffmodeffectinrangeconditionconfig_;
}
inline ::pb::BuffModEffectInRangeConditionConfig* BuffData::release_buffmodeffectinrangeconditionconfig() {
  clear_has_buffmodeffectinrangeconditionconfig();
  ::pb::BuffModEffectInRangeConditionConfig* temp = buffmodeffectinrangeconditionconfig_;
  buffmodeffectinrangeconditionconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodeffectinrangeconditionconfig(::pb::BuffModEffectInRangeConditionConfig* buffmodeffectinrangeconditionconfig) {
  delete buffmodeffectinrangeconditionconfig_;
  buffmodeffectinrangeconditionconfig_ = buffmodeffectinrangeconditionconfig;
  if (buffmodeffectinrangeconditionconfig) {
    set_has_buffmodeffectinrangeconditionconfig();
  } else {
    clear_has_buffmodeffectinrangeconditionconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModEffectInRangeConditionConfig)
}

// optional .pb.BuffModChangeDirConfig BuffModChangeDirConfig = 69;
inline bool BuffData::has_buffmodchangedirconfig() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void BuffData::set_has_buffmodchangedirconfig() {
  _has_bits_[2] |= 0x00001000u;
}
inline void BuffData::clear_has_buffmodchangedirconfig() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void BuffData::clear_buffmodchangedirconfig() {
  if (buffmodchangedirconfig_ != NULL) buffmodchangedirconfig_->::pb::BuffModChangeDirConfig::Clear();
  clear_has_buffmodchangedirconfig();
}
inline const ::pb::BuffModChangeDirConfig& BuffData::buffmodchangedirconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModChangeDirConfig)
  return buffmodchangedirconfig_ != NULL ? *buffmodchangedirconfig_ : *default_instance_->buffmodchangedirconfig_;
}
inline ::pb::BuffModChangeDirConfig* BuffData::mutable_buffmodchangedirconfig() {
  set_has_buffmodchangedirconfig();
  if (buffmodchangedirconfig_ == NULL) buffmodchangedirconfig_ = new ::pb::BuffModChangeDirConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModChangeDirConfig)
  return buffmodchangedirconfig_;
}
inline ::pb::BuffModChangeDirConfig* BuffData::release_buffmodchangedirconfig() {
  clear_has_buffmodchangedirconfig();
  ::pb::BuffModChangeDirConfig* temp = buffmodchangedirconfig_;
  buffmodchangedirconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodchangedirconfig(::pb::BuffModChangeDirConfig* buffmodchangedirconfig) {
  delete buffmodchangedirconfig_;
  buffmodchangedirconfig_ = buffmodchangedirconfig;
  if (buffmodchangedirconfig) {
    set_has_buffmodchangedirconfig();
  } else {
    clear_has_buffmodchangedirconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModChangeDirConfig)
}

// optional .pb.BuffModTDMoniterDefenderStateConfig BuffModTDMoniterDefenderStateConfig = 70;
inline bool BuffData::has_buffmodtdmoniterdefenderstateconfig() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void BuffData::set_has_buffmodtdmoniterdefenderstateconfig() {
  _has_bits_[2] |= 0x00002000u;
}
inline void BuffData::clear_has_buffmodtdmoniterdefenderstateconfig() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void BuffData::clear_buffmodtdmoniterdefenderstateconfig() {
  if (buffmodtdmoniterdefenderstateconfig_ != NULL) buffmodtdmoniterdefenderstateconfig_->::pb::BuffModTDMoniterDefenderStateConfig::Clear();
  clear_has_buffmodtdmoniterdefenderstateconfig();
}
inline const ::pb::BuffModTDMoniterDefenderStateConfig& BuffData::buffmodtdmoniterdefenderstateconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTDMoniterDefenderStateConfig)
  return buffmodtdmoniterdefenderstateconfig_ != NULL ? *buffmodtdmoniterdefenderstateconfig_ : *default_instance_->buffmodtdmoniterdefenderstateconfig_;
}
inline ::pb::BuffModTDMoniterDefenderStateConfig* BuffData::mutable_buffmodtdmoniterdefenderstateconfig() {
  set_has_buffmodtdmoniterdefenderstateconfig();
  if (buffmodtdmoniterdefenderstateconfig_ == NULL) buffmodtdmoniterdefenderstateconfig_ = new ::pb::BuffModTDMoniterDefenderStateConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTDMoniterDefenderStateConfig)
  return buffmodtdmoniterdefenderstateconfig_;
}
inline ::pb::BuffModTDMoniterDefenderStateConfig* BuffData::release_buffmodtdmoniterdefenderstateconfig() {
  clear_has_buffmodtdmoniterdefenderstateconfig();
  ::pb::BuffModTDMoniterDefenderStateConfig* temp = buffmodtdmoniterdefenderstateconfig_;
  buffmodtdmoniterdefenderstateconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtdmoniterdefenderstateconfig(::pb::BuffModTDMoniterDefenderStateConfig* buffmodtdmoniterdefenderstateconfig) {
  delete buffmodtdmoniterdefenderstateconfig_;
  buffmodtdmoniterdefenderstateconfig_ = buffmodtdmoniterdefenderstateconfig;
  if (buffmodtdmoniterdefenderstateconfig) {
    set_has_buffmodtdmoniterdefenderstateconfig();
  } else {
    clear_has_buffmodtdmoniterdefenderstateconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTDMoniterDefenderStateConfig)
}

// optional .pb.BuffModTDNoBeanConfig BuffModTDNoBeanConfig = 71;
inline bool BuffData::has_buffmodtdnobeanconfig() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void BuffData::set_has_buffmodtdnobeanconfig() {
  _has_bits_[2] |= 0x00004000u;
}
inline void BuffData::clear_has_buffmodtdnobeanconfig() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void BuffData::clear_buffmodtdnobeanconfig() {
  if (buffmodtdnobeanconfig_ != NULL) buffmodtdnobeanconfig_->::pb::BuffModTDNoBeanConfig::Clear();
  clear_has_buffmodtdnobeanconfig();
}
inline const ::pb::BuffModTDNoBeanConfig& BuffData::buffmodtdnobeanconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTDNoBeanConfig)
  return buffmodtdnobeanconfig_ != NULL ? *buffmodtdnobeanconfig_ : *default_instance_->buffmodtdnobeanconfig_;
}
inline ::pb::BuffModTDNoBeanConfig* BuffData::mutable_buffmodtdnobeanconfig() {
  set_has_buffmodtdnobeanconfig();
  if (buffmodtdnobeanconfig_ == NULL) buffmodtdnobeanconfig_ = new ::pb::BuffModTDNoBeanConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTDNoBeanConfig)
  return buffmodtdnobeanconfig_;
}
inline ::pb::BuffModTDNoBeanConfig* BuffData::release_buffmodtdnobeanconfig() {
  clear_has_buffmodtdnobeanconfig();
  ::pb::BuffModTDNoBeanConfig* temp = buffmodtdnobeanconfig_;
  buffmodtdnobeanconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtdnobeanconfig(::pb::BuffModTDNoBeanConfig* buffmodtdnobeanconfig) {
  delete buffmodtdnobeanconfig_;
  buffmodtdnobeanconfig_ = buffmodtdnobeanconfig;
  if (buffmodtdnobeanconfig) {
    set_has_buffmodtdnobeanconfig();
  } else {
    clear_has_buffmodtdnobeanconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTDNoBeanConfig)
}

// optional .pb.BuffModTDRepeatSendBeanConfig BuffModTDRepeatSendBeanConfig = 72;
inline bool BuffData::has_buffmodtdrepeatsendbeanconfig() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void BuffData::set_has_buffmodtdrepeatsendbeanconfig() {
  _has_bits_[2] |= 0x00008000u;
}
inline void BuffData::clear_has_buffmodtdrepeatsendbeanconfig() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void BuffData::clear_buffmodtdrepeatsendbeanconfig() {
  if (buffmodtdrepeatsendbeanconfig_ != NULL) buffmodtdrepeatsendbeanconfig_->::pb::BuffModTDRepeatSendBeanConfig::Clear();
  clear_has_buffmodtdrepeatsendbeanconfig();
}
inline const ::pb::BuffModTDRepeatSendBeanConfig& BuffData::buffmodtdrepeatsendbeanconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTDRepeatSendBeanConfig)
  return buffmodtdrepeatsendbeanconfig_ != NULL ? *buffmodtdrepeatsendbeanconfig_ : *default_instance_->buffmodtdrepeatsendbeanconfig_;
}
inline ::pb::BuffModTDRepeatSendBeanConfig* BuffData::mutable_buffmodtdrepeatsendbeanconfig() {
  set_has_buffmodtdrepeatsendbeanconfig();
  if (buffmodtdrepeatsendbeanconfig_ == NULL) buffmodtdrepeatsendbeanconfig_ = new ::pb::BuffModTDRepeatSendBeanConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTDRepeatSendBeanConfig)
  return buffmodtdrepeatsendbeanconfig_;
}
inline ::pb::BuffModTDRepeatSendBeanConfig* BuffData::release_buffmodtdrepeatsendbeanconfig() {
  clear_has_buffmodtdrepeatsendbeanconfig();
  ::pb::BuffModTDRepeatSendBeanConfig* temp = buffmodtdrepeatsendbeanconfig_;
  buffmodtdrepeatsendbeanconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtdrepeatsendbeanconfig(::pb::BuffModTDRepeatSendBeanConfig* buffmodtdrepeatsendbeanconfig) {
  delete buffmodtdrepeatsendbeanconfig_;
  buffmodtdrepeatsendbeanconfig_ = buffmodtdrepeatsendbeanconfig;
  if (buffmodtdrepeatsendbeanconfig) {
    set_has_buffmodtdrepeatsendbeanconfig();
  } else {
    clear_has_buffmodtdrepeatsendbeanconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTDRepeatSendBeanConfig)
}

// optional .pb.BuffModTDRepeatCheckBeanConfig BuffModTDRepeatCheckBeanConfig = 73;
inline bool BuffData::has_buffmodtdrepeatcheckbeanconfig() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void BuffData::set_has_buffmodtdrepeatcheckbeanconfig() {
  _has_bits_[2] |= 0x00010000u;
}
inline void BuffData::clear_has_buffmodtdrepeatcheckbeanconfig() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void BuffData::clear_buffmodtdrepeatcheckbeanconfig() {
  if (buffmodtdrepeatcheckbeanconfig_ != NULL) buffmodtdrepeatcheckbeanconfig_->::pb::BuffModTDRepeatCheckBeanConfig::Clear();
  clear_has_buffmodtdrepeatcheckbeanconfig();
}
inline const ::pb::BuffModTDRepeatCheckBeanConfig& BuffData::buffmodtdrepeatcheckbeanconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModTDRepeatCheckBeanConfig)
  return buffmodtdrepeatcheckbeanconfig_ != NULL ? *buffmodtdrepeatcheckbeanconfig_ : *default_instance_->buffmodtdrepeatcheckbeanconfig_;
}
inline ::pb::BuffModTDRepeatCheckBeanConfig* BuffData::mutable_buffmodtdrepeatcheckbeanconfig() {
  set_has_buffmodtdrepeatcheckbeanconfig();
  if (buffmodtdrepeatcheckbeanconfig_ == NULL) buffmodtdrepeatcheckbeanconfig_ = new ::pb::BuffModTDRepeatCheckBeanConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModTDRepeatCheckBeanConfig)
  return buffmodtdrepeatcheckbeanconfig_;
}
inline ::pb::BuffModTDRepeatCheckBeanConfig* BuffData::release_buffmodtdrepeatcheckbeanconfig() {
  clear_has_buffmodtdrepeatcheckbeanconfig();
  ::pb::BuffModTDRepeatCheckBeanConfig* temp = buffmodtdrepeatcheckbeanconfig_;
  buffmodtdrepeatcheckbeanconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodtdrepeatcheckbeanconfig(::pb::BuffModTDRepeatCheckBeanConfig* buffmodtdrepeatcheckbeanconfig) {
  delete buffmodtdrepeatcheckbeanconfig_;
  buffmodtdrepeatcheckbeanconfig_ = buffmodtdrepeatcheckbeanconfig;
  if (buffmodtdrepeatcheckbeanconfig) {
    set_has_buffmodtdrepeatcheckbeanconfig();
  } else {
    clear_has_buffmodtdrepeatcheckbeanconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModTDRepeatCheckBeanConfig)
}

// optional .pb.BuffModBuffOnStackConfig BuffModBuffOnStackConfig = 76;
inline bool BuffData::has_buffmodbuffonstackconfig() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void BuffData::set_has_buffmodbuffonstackconfig() {
  _has_bits_[2] |= 0x00020000u;
}
inline void BuffData::clear_has_buffmodbuffonstackconfig() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void BuffData::clear_buffmodbuffonstackconfig() {
  if (buffmodbuffonstackconfig_ != NULL) buffmodbuffonstackconfig_->::pb::BuffModBuffOnStackConfig::Clear();
  clear_has_buffmodbuffonstackconfig();
}
inline const ::pb::BuffModBuffOnStackConfig& BuffData::buffmodbuffonstackconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModBuffOnStackConfig)
  return buffmodbuffonstackconfig_ != NULL ? *buffmodbuffonstackconfig_ : *default_instance_->buffmodbuffonstackconfig_;
}
inline ::pb::BuffModBuffOnStackConfig* BuffData::mutable_buffmodbuffonstackconfig() {
  set_has_buffmodbuffonstackconfig();
  if (buffmodbuffonstackconfig_ == NULL) buffmodbuffonstackconfig_ = new ::pb::BuffModBuffOnStackConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModBuffOnStackConfig)
  return buffmodbuffonstackconfig_;
}
inline ::pb::BuffModBuffOnStackConfig* BuffData::release_buffmodbuffonstackconfig() {
  clear_has_buffmodbuffonstackconfig();
  ::pb::BuffModBuffOnStackConfig* temp = buffmodbuffonstackconfig_;
  buffmodbuffonstackconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodbuffonstackconfig(::pb::BuffModBuffOnStackConfig* buffmodbuffonstackconfig) {
  delete buffmodbuffonstackconfig_;
  buffmodbuffonstackconfig_ = buffmodbuffonstackconfig;
  if (buffmodbuffonstackconfig) {
    set_has_buffmodbuffonstackconfig();
  } else {
    clear_has_buffmodbuffonstackconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModBuffOnStackConfig)
}

// optional .pb.BuffModChangeSummonedAIConfig BuffModChangeSummonedAIConfig = 80;
inline bool BuffData::has_buffmodchangesummonedaiconfig() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void BuffData::set_has_buffmodchangesummonedaiconfig() {
  _has_bits_[2] |= 0x00040000u;
}
inline void BuffData::clear_has_buffmodchangesummonedaiconfig() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void BuffData::clear_buffmodchangesummonedaiconfig() {
  if (buffmodchangesummonedaiconfig_ != NULL) buffmodchangesummonedaiconfig_->::pb::BuffModChangeSummonedAIConfig::Clear();
  clear_has_buffmodchangesummonedaiconfig();
}
inline const ::pb::BuffModChangeSummonedAIConfig& BuffData::buffmodchangesummonedaiconfig() const {
  // @@protoc_insertion_point(field_get:pb.BuffData.BuffModChangeSummonedAIConfig)
  return buffmodchangesummonedaiconfig_ != NULL ? *buffmodchangesummonedaiconfig_ : *default_instance_->buffmodchangesummonedaiconfig_;
}
inline ::pb::BuffModChangeSummonedAIConfig* BuffData::mutable_buffmodchangesummonedaiconfig() {
  set_has_buffmodchangesummonedaiconfig();
  if (buffmodchangesummonedaiconfig_ == NULL) buffmodchangesummonedaiconfig_ = new ::pb::BuffModChangeSummonedAIConfig;
  // @@protoc_insertion_point(field_mutable:pb.BuffData.BuffModChangeSummonedAIConfig)
  return buffmodchangesummonedaiconfig_;
}
inline ::pb::BuffModChangeSummonedAIConfig* BuffData::release_buffmodchangesummonedaiconfig() {
  clear_has_buffmodchangesummonedaiconfig();
  ::pb::BuffModChangeSummonedAIConfig* temp = buffmodchangesummonedaiconfig_;
  buffmodchangesummonedaiconfig_ = NULL;
  return temp;
}
inline void BuffData::set_allocated_buffmodchangesummonedaiconfig(::pb::BuffModChangeSummonedAIConfig* buffmodchangesummonedaiconfig) {
  delete buffmodchangesummonedaiconfig_;
  buffmodchangesummonedaiconfig_ = buffmodchangesummonedaiconfig;
  if (buffmodchangesummonedaiconfig) {
    set_has_buffmodchangesummonedaiconfig();
  } else {
    clear_has_buffmodchangesummonedaiconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BuffData.BuffModChangeSummonedAIConfig)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fBuffData_2eproto__INCLUDED
