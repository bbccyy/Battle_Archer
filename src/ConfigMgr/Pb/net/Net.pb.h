// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net/Net.proto

#ifndef PROTOBUF_net_2fNet_2eproto__INCLUDED
#define PROTOBUF_net_2fNet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_net_2fNet_2eproto();
void protobuf_AssignDesc_net_2fNet_2eproto();
void protobuf_ShutdownFile_net_2fNet_2eproto();

class TRequest;
class TResponse;
class TRetInitQueueInfo;
class TLoginQueueNotify;
class TBeKickNotify;
class TEmptyReq;
class TEmptyRsp;

// ===================================================================

/*FOR2LUA
<Record>
	<name>TRequest</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TRequest : public ::google::protobuf::Message {
 public:
  TRequest();
  virtual ~TRequest();

  TRequest(const TRequest& from);

  inline TRequest& operator=(const TRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRequest& default_instance();

  void Swap(TRequest* other);

  // implements Message ----------------------------------------------

  TRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRequest& from);
  void MergeFrom(const TRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TRequest</name>
  	<Function>
  		<name>method</name>
  		<replaceName>Method</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_method</name>
  		<replaceName>Method</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_method</name>
  		<replaceName>Method</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // required bytes Args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TRequest</name>
  	<Function>
  		<name>args</name>
  		<replaceName>Args</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_args</name>
  		<replaceName>Args</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_args</name>
  		<replaceName>Args</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& args() const;
  inline void set_args(const ::std::string& value);
  inline void set_args(const char* value);
  inline void set_args(const void* value, size_t size);
  inline ::std::string* mutable_args();
  inline ::std::string* release_args();
  inline void set_allocated_args(::std::string* args);

  // optional uint32 CallbackHandler = 3;
  inline bool has_callbackhandler() const;
  inline void clear_callbackhandler();
  static const int kCallbackHandlerFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TRequest</name>
  	<Function>
  		<name>callbackhandler</name>
  		<replaceName>CallbackHandler</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_callbackhandler</name>
  		<replaceName>CallbackHandler</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_callbackhandler</name>
  		<replaceName>CallbackHandler</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 callbackhandler() const;
  inline void set_callbackhandler(::google::protobuf::uint32 value);

  // optional string Token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TRequest</name>
  	<Function>
  		<name>token</name>
  		<replaceName>Token</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_token</name>
  		<replaceName>Token</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_token</name>
  		<replaceName>Token</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:pb.TRequest)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_args();
  inline void clear_has_args();
  inline void set_has_callbackhandler();
  inline void clear_has_callbackhandler();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* method_;
  ::std::string* args_;
  ::std::string* token_;
  ::google::protobuf::uint32 callbackhandler_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TRequest* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TResponse</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TResponse : public ::google::protobuf::Message {
 public:
  TResponse();
  virtual ~TResponse();

  TResponse(const TResponse& from);

  inline TResponse& operator=(const TResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TResponse& default_instance();

  void Swap(TResponse* other);

  // implements Message ----------------------------------------------

  TResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TResponse& from);
  void MergeFrom(const TResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Err = 1;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>err</name>
  		<replaceName>Err</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_err</name>
  		<replaceName>Err</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_err</name>
  		<replaceName>Err</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 err() const;
  inline void set_err(::google::protobuf::int32 value);

  // optional string ErrMsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrMsgFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>errmsg</name>
  		<replaceName>ErrMsg</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_errmsg</name>
  		<replaceName>ErrMsg</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_errmsg</name>
  		<replaceName>ErrMsg</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // required string Method = 3;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>method</name>
  		<replaceName>Method</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_method</name>
  		<replaceName>Method</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_method</name>
  		<replaceName>Method</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional bytes Ret = 4;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>ret</name>
  		<replaceName>Ret</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_ret</name>
  		<replaceName>Ret</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_ret</name>
  		<replaceName>Ret</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& ret() const;
  inline void set_ret(const ::std::string& value);
  inline void set_ret(const char* value);
  inline void set_ret(const void* value, size_t size);
  inline ::std::string* mutable_ret();
  inline ::std::string* release_ret();
  inline void set_allocated_ret(::std::string* ret);

  // optional uint32 CallbackHandler = 5;
  inline bool has_callbackhandler() const;
  inline void clear_callbackhandler();
  static const int kCallbackHandlerFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>callbackhandler</name>
  		<replaceName>CallbackHandler</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_callbackhandler</name>
  		<replaceName>CallbackHandler</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_callbackhandler</name>
  		<replaceName>CallbackHandler</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 callbackhandler() const;
  inline void set_callbackhandler(::google::protobuf::uint32 value);

  // optional uint32 Time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>time</name>
  		<replaceName>Time</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_time</name>
  		<replaceName>Time</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_time</name>
  		<replaceName>Time</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional string Token = 7;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>TResponse</name>
  	<Function>
  		<name>token</name>
  		<replaceName>Token</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_token</name>
  		<replaceName>Token</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_token</name>
  		<replaceName>Token</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:pb.TResponse)
 private:
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_callbackhandler();
  inline void clear_has_callbackhandler();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* errmsg_;
  ::std::string* method_;
  ::google::protobuf::int32 err_;
  ::google::protobuf::uint32 callbackhandler_;
  ::std::string* ret_;
  ::std::string* token_;
  ::google::protobuf::uint32 time_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TResponse* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TRetInitQueueInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TRetInitQueueInfo : public ::google::protobuf::Message {
 public:
  TRetInitQueueInfo();
  virtual ~TRetInitQueueInfo();

  TRetInitQueueInfo(const TRetInitQueueInfo& from);

  inline TRetInitQueueInfo& operator=(const TRetInitQueueInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRetInitQueueInfo& default_instance();

  void Swap(TRetInitQueueInfo* other);

  // implements Message ----------------------------------------------

  TRetInitQueueInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRetInitQueueInfo& from);
  void MergeFrom(const TRetInitQueueInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 QueuePos = 1;
  inline bool has_queuepos() const;
  inline void clear_queuepos();
  static const int kQueuePosFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TRetInitQueueInfo</name>
  	<Function>
  		<name>queuepos</name>
  		<replaceName>QueuePos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_queuepos</name>
  		<replaceName>QueuePos</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_queuepos</name>
  		<replaceName>QueuePos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 queuepos() const;
  inline void set_queuepos(::google::protobuf::int32 value);

  // optional int32 QueueLen = 2;
  inline bool has_queuelen() const;
  inline void clear_queuelen();
  static const int kQueueLenFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TRetInitQueueInfo</name>
  	<Function>
  		<name>queuelen</name>
  		<replaceName>QueueLen</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_queuelen</name>
  		<replaceName>QueueLen</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_queuelen</name>
  		<replaceName>QueueLen</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 queuelen() const;
  inline void set_queuelen(::google::protobuf::int32 value);

  // optional int32 SelfPos = 3;
  inline bool has_selfpos() const;
  inline void clear_selfpos();
  static const int kSelfPosFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TRetInitQueueInfo</name>
  	<Function>
  		<name>selfpos</name>
  		<replaceName>SelfPos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_selfpos</name>
  		<replaceName>SelfPos</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_selfpos</name>
  		<replaceName>SelfPos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 selfpos() const;
  inline void set_selfpos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.TRetInitQueueInfo)
 private:
  inline void set_has_queuepos();
  inline void clear_has_queuepos();
  inline void set_has_queuelen();
  inline void clear_has_queuelen();
  inline void set_has_selfpos();
  inline void clear_has_selfpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 queuepos_;
  ::google::protobuf::int32 queuelen_;
  ::google::protobuf::int32 selfpos_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TRetInitQueueInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TLoginQueueNotify</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TLoginQueueNotify : public ::google::protobuf::Message {
 public:
  TLoginQueueNotify();
  virtual ~TLoginQueueNotify();

  TLoginQueueNotify(const TLoginQueueNotify& from);

  inline TLoginQueueNotify& operator=(const TLoginQueueNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLoginQueueNotify& default_instance();

  void Swap(TLoginQueueNotify* other);

  // implements Message ----------------------------------------------

  TLoginQueueNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLoginQueueNotify& from);
  void MergeFrom(const TLoginQueueNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 QueuePos = 1;
  inline bool has_queuepos() const;
  inline void clear_queuepos();
  static const int kQueuePosFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TLoginQueueNotify</name>
  	<Function>
  		<name>queuepos</name>
  		<replaceName>QueuePos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_queuepos</name>
  		<replaceName>QueuePos</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_queuepos</name>
  		<replaceName>QueuePos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 queuepos() const;
  inline void set_queuepos(::google::protobuf::int32 value);

  // optional int32 QueueLen = 2;
  inline bool has_queuelen() const;
  inline void clear_queuelen();
  static const int kQueueLenFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TLoginQueueNotify</name>
  	<Function>
  		<name>queuelen</name>
  		<replaceName>QueueLen</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_queuelen</name>
  		<replaceName>QueueLen</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_queuelen</name>
  		<replaceName>QueueLen</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 queuelen() const;
  inline void set_queuelen(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.TLoginQueueNotify)
 private:
  inline void set_has_queuepos();
  inline void clear_has_queuepos();
  inline void set_has_queuelen();
  inline void clear_has_queuelen();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 queuepos_;
  ::google::protobuf::int32 queuelen_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TLoginQueueNotify* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TBeKickNotify</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TBeKickNotify : public ::google::protobuf::Message {
 public:
  TBeKickNotify();
  virtual ~TBeKickNotify();

  TBeKickNotify(const TBeKickNotify& from);

  inline TBeKickNotify& operator=(const TBeKickNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TBeKickNotify& default_instance();

  void Swap(TBeKickNotify* other);

  // implements Message ----------------------------------------------

  TBeKickNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TBeKickNotify& from);
  void MergeFrom(const TBeKickNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TBeKickNotify</name>
  	<Function>
  		<name>info</name>
  		<replaceName>info</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_info</name>
  		<replaceName>info</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_info</name>
  		<replaceName>info</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // optional int32 kickNo = 2;
  inline bool has_kickno() const;
  inline void clear_kickno();
  static const int kKickNoFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TBeKickNotify</name>
  	<Function>
  		<name>kickno</name>
  		<replaceName>kickNo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_kickno</name>
  		<replaceName>kickNo</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_kickno</name>
  		<replaceName>kickNo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 kickno() const;
  inline void set_kickno(::google::protobuf::int32 value);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TBeKickNotify</name>
  	<Function>
  		<name>version</name>
  		<replaceName>version</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_version</name>
  		<replaceName>version</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_version</name>
  		<replaceName>version</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:pb.TBeKickNotify)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_kickno();
  inline void clear_has_kickno();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_;
  ::std::string* version_;
  ::google::protobuf::int32 kickno_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TBeKickNotify* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TEmptyReq</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TEmptyReq : public ::google::protobuf::Message {
 public:
  TEmptyReq();
  virtual ~TEmptyReq();

  TEmptyReq(const TEmptyReq& from);

  inline TEmptyReq& operator=(const TEmptyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEmptyReq& default_instance();

  void Swap(TEmptyReq* other);

  // implements Message ----------------------------------------------

  TEmptyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEmptyReq& from);
  void MergeFrom(const TEmptyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.TEmptyReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TEmptyReq* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TEmptyRsp</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Net.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TEmptyRsp : public ::google::protobuf::Message {
 public:
  TEmptyRsp();
  virtual ~TEmptyRsp();

  TEmptyRsp(const TEmptyRsp& from);

  inline TEmptyRsp& operator=(const TEmptyRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TEmptyRsp& default_instance();

  void Swap(TEmptyRsp* other);

  // implements Message ----------------------------------------------

  TEmptyRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TEmptyRsp& from);
  void MergeFrom(const TEmptyRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.TEmptyRsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_net_2fNet_2eproto();
  friend void protobuf_AssignDesc_net_2fNet_2eproto();
  friend void protobuf_ShutdownFile_net_2fNet_2eproto();

  void InitAsDefaultInstance();
  static TEmptyRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// TRequest

// required string Method = 1;
inline bool TRequest::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRequest::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRequest::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRequest::clear_method() {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& TRequest::method() const {
  // @@protoc_insertion_point(field_get:pb.TRequest.Method)
  return *method_;
}
inline void TRequest::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TRequest.Method)
}
inline void TRequest::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TRequest.Method)
}
inline void TRequest::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TRequest.Method)
}
inline ::std::string* TRequest::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TRequest.Method)
  return method_;
}
inline ::std::string* TRequest::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TRequest::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TRequest.Method)
}

// required bytes Args = 2;
inline bool TRequest::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRequest::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRequest::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRequest::clear_args() {
  if (args_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_->clear();
  }
  clear_has_args();
}
inline const ::std::string& TRequest::args() const {
  // @@protoc_insertion_point(field_get:pb.TRequest.Args)
  return *args_;
}
inline void TRequest::set_args(const ::std::string& value) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  args_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TRequest.Args)
}
inline void TRequest::set_args(const char* value) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  args_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TRequest.Args)
}
inline void TRequest::set_args(const void* value, size_t size) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  args_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TRequest.Args)
}
inline ::std::string* TRequest::mutable_args() {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TRequest.Args)
  return args_;
}
inline ::std::string* TRequest::release_args() {
  clear_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = args_;
    args_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TRequest::set_allocated_args(::std::string* args) {
  if (args_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete args_;
  }
  if (args) {
    set_has_args();
    args_ = args;
  } else {
    clear_has_args();
    args_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TRequest.Args)
}

// optional uint32 CallbackHandler = 3;
inline bool TRequest::has_callbackhandler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRequest::set_has_callbackhandler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRequest::clear_has_callbackhandler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRequest::clear_callbackhandler() {
  callbackhandler_ = 0u;
  clear_has_callbackhandler();
}
inline ::google::protobuf::uint32 TRequest::callbackhandler() const {
  // @@protoc_insertion_point(field_get:pb.TRequest.CallbackHandler)
  return callbackhandler_;
}
inline void TRequest::set_callbackhandler(::google::protobuf::uint32 value) {
  set_has_callbackhandler();
  callbackhandler_ = value;
  // @@protoc_insertion_point(field_set:pb.TRequest.CallbackHandler)
}

// optional string Token = 4;
inline bool TRequest::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TRequest::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& TRequest::token() const {
  // @@protoc_insertion_point(field_get:pb.TRequest.Token)
  return *token_;
}
inline void TRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TRequest.Token)
}
inline void TRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TRequest.Token)
}
inline void TRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TRequest.Token)
}
inline ::std::string* TRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TRequest.Token)
  return token_;
}
inline ::std::string* TRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TRequest.Token)
}

// -------------------------------------------------------------------

// TResponse

// required int32 Err = 1;
inline bool TResponse::has_err() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TResponse::set_has_err() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TResponse::clear_has_err() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TResponse::clear_err() {
  err_ = 0;
  clear_has_err();
}
inline ::google::protobuf::int32 TResponse::err() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.Err)
  return err_;
}
inline void TResponse::set_err(::google::protobuf::int32 value) {
  set_has_err();
  err_ = value;
  // @@protoc_insertion_point(field_set:pb.TResponse.Err)
}

// optional string ErrMsg = 2;
inline bool TResponse::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TResponse::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TResponse::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TResponse::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& TResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.ErrMsg)
  return *errmsg_;
}
inline void TResponse::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TResponse.ErrMsg)
}
inline void TResponse::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TResponse.ErrMsg)
}
inline void TResponse::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TResponse.ErrMsg)
}
inline ::std::string* TResponse::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TResponse.ErrMsg)
  return errmsg_;
}
inline ::std::string* TResponse::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TResponse::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TResponse.ErrMsg)
}

// required string Method = 3;
inline bool TResponse::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TResponse::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TResponse::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TResponse::clear_method() {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& TResponse::method() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.Method)
  return *method_;
}
inline void TResponse::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TResponse.Method)
}
inline void TResponse::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TResponse.Method)
}
inline void TResponse::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TResponse.Method)
}
inline ::std::string* TResponse::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TResponse.Method)
  return method_;
}
inline ::std::string* TResponse::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TResponse::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TResponse.Method)
}

// optional bytes Ret = 4;
inline bool TResponse::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TResponse::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TResponse::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TResponse::clear_ret() {
  if (ret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_->clear();
  }
  clear_has_ret();
}
inline const ::std::string& TResponse::ret() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.Ret)
  return *ret_;
}
inline void TResponse::set_ret(const ::std::string& value) {
  set_has_ret();
  if (ret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_ = new ::std::string;
  }
  ret_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TResponse.Ret)
}
inline void TResponse::set_ret(const char* value) {
  set_has_ret();
  if (ret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_ = new ::std::string;
  }
  ret_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TResponse.Ret)
}
inline void TResponse::set_ret(const void* value, size_t size) {
  set_has_ret();
  if (ret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_ = new ::std::string;
  }
  ret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TResponse.Ret)
}
inline ::std::string* TResponse::mutable_ret() {
  set_has_ret();
  if (ret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TResponse.Ret)
  return ret_;
}
inline ::std::string* TResponse::release_ret() {
  clear_has_ret();
  if (ret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ret_;
    ret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TResponse::set_allocated_ret(::std::string* ret) {
  if (ret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ret_;
  }
  if (ret) {
    set_has_ret();
    ret_ = ret;
  } else {
    clear_has_ret();
    ret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TResponse.Ret)
}

// optional uint32 CallbackHandler = 5;
inline bool TResponse::has_callbackhandler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TResponse::set_has_callbackhandler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TResponse::clear_has_callbackhandler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TResponse::clear_callbackhandler() {
  callbackhandler_ = 0u;
  clear_has_callbackhandler();
}
inline ::google::protobuf::uint32 TResponse::callbackhandler() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.CallbackHandler)
  return callbackhandler_;
}
inline void TResponse::set_callbackhandler(::google::protobuf::uint32 value) {
  set_has_callbackhandler();
  callbackhandler_ = value;
  // @@protoc_insertion_point(field_set:pb.TResponse.CallbackHandler)
}

// optional uint32 Time = 6;
inline bool TResponse::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TResponse::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TResponse::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TResponse::time() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.Time)
  return time_;
}
inline void TResponse::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:pb.TResponse.Time)
}

// optional string Token = 7;
inline bool TResponse::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TResponse::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& TResponse::token() const {
  // @@protoc_insertion_point(field_get:pb.TResponse.Token)
  return *token_;
}
inline void TResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TResponse.Token)
}
inline void TResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TResponse.Token)
}
inline void TResponse::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TResponse.Token)
}
inline ::std::string* TResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TResponse.Token)
  return token_;
}
inline ::std::string* TResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TResponse::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TResponse.Token)
}

// -------------------------------------------------------------------

// TRetInitQueueInfo

// optional int32 QueuePos = 1;
inline bool TRetInitQueueInfo::has_queuepos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRetInitQueueInfo::set_has_queuepos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRetInitQueueInfo::clear_has_queuepos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRetInitQueueInfo::clear_queuepos() {
  queuepos_ = 0;
  clear_has_queuepos();
}
inline ::google::protobuf::int32 TRetInitQueueInfo::queuepos() const {
  // @@protoc_insertion_point(field_get:pb.TRetInitQueueInfo.QueuePos)
  return queuepos_;
}
inline void TRetInitQueueInfo::set_queuepos(::google::protobuf::int32 value) {
  set_has_queuepos();
  queuepos_ = value;
  // @@protoc_insertion_point(field_set:pb.TRetInitQueueInfo.QueuePos)
}

// optional int32 QueueLen = 2;
inline bool TRetInitQueueInfo::has_queuelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRetInitQueueInfo::set_has_queuelen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRetInitQueueInfo::clear_has_queuelen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRetInitQueueInfo::clear_queuelen() {
  queuelen_ = 0;
  clear_has_queuelen();
}
inline ::google::protobuf::int32 TRetInitQueueInfo::queuelen() const {
  // @@protoc_insertion_point(field_get:pb.TRetInitQueueInfo.QueueLen)
  return queuelen_;
}
inline void TRetInitQueueInfo::set_queuelen(::google::protobuf::int32 value) {
  set_has_queuelen();
  queuelen_ = value;
  // @@protoc_insertion_point(field_set:pb.TRetInitQueueInfo.QueueLen)
}

// optional int32 SelfPos = 3;
inline bool TRetInitQueueInfo::has_selfpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TRetInitQueueInfo::set_has_selfpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TRetInitQueueInfo::clear_has_selfpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TRetInitQueueInfo::clear_selfpos() {
  selfpos_ = 0;
  clear_has_selfpos();
}
inline ::google::protobuf::int32 TRetInitQueueInfo::selfpos() const {
  // @@protoc_insertion_point(field_get:pb.TRetInitQueueInfo.SelfPos)
  return selfpos_;
}
inline void TRetInitQueueInfo::set_selfpos(::google::protobuf::int32 value) {
  set_has_selfpos();
  selfpos_ = value;
  // @@protoc_insertion_point(field_set:pb.TRetInitQueueInfo.SelfPos)
}

// -------------------------------------------------------------------

// TLoginQueueNotify

// optional int32 QueuePos = 1;
inline bool TLoginQueueNotify::has_queuepos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TLoginQueueNotify::set_has_queuepos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TLoginQueueNotify::clear_has_queuepos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TLoginQueueNotify::clear_queuepos() {
  queuepos_ = 0;
  clear_has_queuepos();
}
inline ::google::protobuf::int32 TLoginQueueNotify::queuepos() const {
  // @@protoc_insertion_point(field_get:pb.TLoginQueueNotify.QueuePos)
  return queuepos_;
}
inline void TLoginQueueNotify::set_queuepos(::google::protobuf::int32 value) {
  set_has_queuepos();
  queuepos_ = value;
  // @@protoc_insertion_point(field_set:pb.TLoginQueueNotify.QueuePos)
}

// optional int32 QueueLen = 2;
inline bool TLoginQueueNotify::has_queuelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TLoginQueueNotify::set_has_queuelen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TLoginQueueNotify::clear_has_queuelen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TLoginQueueNotify::clear_queuelen() {
  queuelen_ = 0;
  clear_has_queuelen();
}
inline ::google::protobuf::int32 TLoginQueueNotify::queuelen() const {
  // @@protoc_insertion_point(field_get:pb.TLoginQueueNotify.QueueLen)
  return queuelen_;
}
inline void TLoginQueueNotify::set_queuelen(::google::protobuf::int32 value) {
  set_has_queuelen();
  queuelen_ = value;
  // @@protoc_insertion_point(field_set:pb.TLoginQueueNotify.QueueLen)
}

// -------------------------------------------------------------------

// TBeKickNotify

// optional string info = 1;
inline bool TBeKickNotify::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TBeKickNotify::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TBeKickNotify::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TBeKickNotify::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& TBeKickNotify::info() const {
  // @@protoc_insertion_point(field_get:pb.TBeKickNotify.info)
  return *info_;
}
inline void TBeKickNotify::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TBeKickNotify.info)
}
inline void TBeKickNotify::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TBeKickNotify.info)
}
inline void TBeKickNotify::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TBeKickNotify.info)
}
inline ::std::string* TBeKickNotify::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TBeKickNotify.info)
  return info_;
}
inline ::std::string* TBeKickNotify::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TBeKickNotify::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TBeKickNotify.info)
}

// optional int32 kickNo = 2;
inline bool TBeKickNotify::has_kickno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TBeKickNotify::set_has_kickno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TBeKickNotify::clear_has_kickno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TBeKickNotify::clear_kickno() {
  kickno_ = 0;
  clear_has_kickno();
}
inline ::google::protobuf::int32 TBeKickNotify::kickno() const {
  // @@protoc_insertion_point(field_get:pb.TBeKickNotify.kickNo)
  return kickno_;
}
inline void TBeKickNotify::set_kickno(::google::protobuf::int32 value) {
  set_has_kickno();
  kickno_ = value;
  // @@protoc_insertion_point(field_set:pb.TBeKickNotify.kickNo)
}

// optional string version = 3;
inline bool TBeKickNotify::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TBeKickNotify::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TBeKickNotify::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TBeKickNotify::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TBeKickNotify::version() const {
  // @@protoc_insertion_point(field_get:pb.TBeKickNotify.version)
  return *version_;
}
inline void TBeKickNotify::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TBeKickNotify.version)
}
inline void TBeKickNotify::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TBeKickNotify.version)
}
inline void TBeKickNotify::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TBeKickNotify.version)
}
inline ::std::string* TBeKickNotify::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TBeKickNotify.version)
  return version_;
}
inline ::std::string* TBeKickNotify::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TBeKickNotify::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TBeKickNotify.version)
}

// -------------------------------------------------------------------

// TEmptyReq

// -------------------------------------------------------------------

// TEmptyRsp


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_net_2fNet_2eproto__INCLUDED
