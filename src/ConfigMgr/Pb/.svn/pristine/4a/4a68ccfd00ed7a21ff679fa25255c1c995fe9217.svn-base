// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/SceneConf3d.proto

#ifndef PROTOBUF_module_2fSceneConf3d_2eproto__INCLUDED
#define PROTOBUF_module_2fSceneConf3d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/SceneElementDefine.pb.h"
#include "module/Util.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

class PointElement3;
class RectArea3;
class Destructable;
class Camera3;
class CustomArea3;
class BlockLineFastFilter;
class TDSpawnMapping;
class StripInfo;
class AnimAsset3;
class StaticAsset3;
class EffectAsset3;
class LeapTrackPoint;
class LeapTrack;
class CurveTrack;
class PathPoint;
class PathTrack;
class CameraTrackPoint;
class CameraTrack;
class FieldConf3;
class SceneConf3d;

// ===================================================================

/*FOR2LUA
<Record>
	<name>PointElement3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PointElement3 : public ::google::protobuf::Message {
 public:
  PointElement3();
  virtual ~PointElement3();

  PointElement3(const PointElement3& from);

  inline PointElement3& operator=(const PointElement3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointElement3& default_instance();

  void Swap(PointElement3* other);

  // implements Message ----------------------------------------------

  PointElement3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointElement3& from);
  void MergeFrom(const PointElement3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ESceneElementType ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PointElement3</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PointElement3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector3_Int Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>PointElement3</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // optional .pb.PbVector3_Int Direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>PointElement3</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& direction() const;
  inline ::pb::PbVector3_Int* mutable_direction();
  inline ::pb::PbVector3_Int* release_direction();
  inline void set_allocated_direction(::pb::PbVector3_Int* direction);

  // repeated string JumpTrackNameArr = 5;
  inline int jumptracknamearr_size() const;
  inline void clear_jumptracknamearr();
  static const int kJumpTrackNameArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>PointElement3</name>
  	<Function>
  		<name>jumptracknamearr</name>
  		<replaceName>JumpTrackNameArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_jumptracknamearr</name>
  		<replaceName>JumpTrackNameArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_jumptracknamearr</name>
  		<replaceName>JumpTrackNameArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_jumptracknamearr</name>
  		<replaceName>JumpTrackNameArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>jumptracknamearr_size</name>
  		<replaceName>JumpTrackNameArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& jumptracknamearr(int index) const;
  inline ::std::string* mutable_jumptracknamearr(int index);
  inline void set_jumptracknamearr(int index, const ::std::string& value);
  inline void set_jumptracknamearr(int index, const char* value);
  inline void set_jumptracknamearr(int index, const char* value, size_t size);
  inline ::std::string* add_jumptracknamearr();
  inline void add_jumptracknamearr(const ::std::string& value);
  inline void add_jumptracknamearr(const char* value);
  inline void add_jumptracknamearr(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& jumptracknamearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_jumptracknamearr();

  // optional int32 PathTrackIndex = 6;
  inline bool has_pathtrackindex() const;
  inline void clear_pathtrackindex();
  static const int kPathTrackIndexFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>PointElement3</name>
  	<Function>
  		<name>pathtrackindex</name>
  		<replaceName>PathTrackIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_pathtrackindex</name>
  		<replaceName>PathTrackIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pathtrackindex</name>
  		<replaceName>PathTrackIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 pathtrackindex() const;
  inline void set_pathtrackindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.PointElement3)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_pathtrackindex();
  inline void clear_has_pathtrackindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector3_Int* position_;
  int elementtype_;
  ::google::protobuf::int32 pathtrackindex_;
  ::pb::PbVector3_Int* direction_;
  ::google::protobuf::RepeatedPtrField< ::std::string> jumptracknamearr_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static PointElement3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>RectArea3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class RectArea3 : public ::google::protobuf::Message {
 public:
  RectArea3();
  virtual ~RectArea3();

  RectArea3(const RectArea3& from);

  inline RectArea3& operator=(const RectArea3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectArea3& default_instance();

  void Swap(RectArea3* other);

  // implements Message ----------------------------------------------

  RectArea3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RectArea3& from);
  void MergeFrom(const RectArea3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ESceneElementType ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>RectArea3</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>RectArea3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbRect_Int RectInfo = 3;
  inline bool has_rectinfo() const;
  inline void clear_rectinfo();
  static const int kRectInfoFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>RectArea3</name>
  	<Function>
  		<name>rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect_Int& rectinfo() const;
  inline ::pb::PbRect_Int* mutable_rectinfo();
  inline ::pb::PbRect_Int* release_rectinfo();
  inline void set_allocated_rectinfo(::pb::PbRect_Int* rectinfo);

  // required .pb.PbVector3_Int CenterPosition = 4;
  inline bool has_centerposition() const;
  inline void clear_centerposition();
  static const int kCenterPositionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>RectArea3</name>
  	<Function>
  		<name>centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& centerposition() const;
  inline ::pb::PbVector3_Int* mutable_centerposition();
  inline ::pb::PbVector3_Int* release_centerposition();
  inline void set_allocated_centerposition(::pb::PbVector3_Int* centerposition);

  // required bool Visible = 5;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>RectArea3</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:pb.RectArea3)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rectinfo();
  inline void clear_has_rectinfo();
  inline void set_has_centerposition();
  inline void clear_has_centerposition();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbRect_Int* rectinfo_;
  int elementtype_;
  bool visible_;
  ::pb::PbVector3_Int* centerposition_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static RectArea3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>Destructable</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class Destructable : public ::google::protobuf::Message {
 public:
  Destructable();
  virtual ~Destructable();

  Destructable(const Destructable& from);

  inline Destructable& operator=(const Destructable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Destructable& default_instance();

  void Swap(Destructable* other);

  // implements Message ----------------------------------------------

  Destructable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Destructable& from);
  void MergeFrom(const Destructable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>Destructable</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string ArtObjectName = 2;
  inline bool has_artobjectname() const;
  inline void clear_artobjectname();
  static const int kArtObjectNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>Destructable</name>
  	<Function>
  		<name>artobjectname</name>
  		<replaceName>ArtObjectName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artobjectname</name>
  		<replaceName>ArtObjectName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artobjectname</name>
  		<replaceName>ArtObjectName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& artobjectname() const;
  inline void set_artobjectname(const ::std::string& value);
  inline void set_artobjectname(const char* value);
  inline void set_artobjectname(const char* value, size_t size);
  inline ::std::string* mutable_artobjectname();
  inline ::std::string* release_artobjectname();
  inline void set_allocated_artobjectname(::std::string* artobjectname);

  // optional .pb.PbVector3_Int ArtObjectPosition = 3;
  inline bool has_artobjectposition() const;
  inline void clear_artobjectposition();
  static const int kArtObjectPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>Destructable</name>
  	<Function>
  		<name>artobjectposition</name>
  		<replaceName>ArtObjectPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artobjectposition</name>
  		<replaceName>ArtObjectPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_artobjectposition</name>
  		<replaceName>ArtObjectPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artobjectposition</name>
  		<replaceName>ArtObjectPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& artobjectposition() const;
  inline ::pb::PbVector3_Int* mutable_artobjectposition();
  inline ::pb::PbVector3_Int* release_artobjectposition();
  inline void set_allocated_artobjectposition(::pb::PbVector3_Int* artobjectposition);

  // optional string DestructableEffectPath = 4;
  inline bool has_destructableeffectpath() const;
  inline void clear_destructableeffectpath();
  static const int kDestructableEffectPathFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>Destructable</name>
  	<Function>
  		<name>destructableeffectpath</name>
  		<replaceName>DestructableEffectPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_destructableeffectpath</name>
  		<replaceName>DestructableEffectPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_destructableeffectpath</name>
  		<replaceName>DestructableEffectPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& destructableeffectpath() const;
  inline void set_destructableeffectpath(const ::std::string& value);
  inline void set_destructableeffectpath(const char* value);
  inline void set_destructableeffectpath(const char* value, size_t size);
  inline ::std::string* mutable_destructableeffectpath();
  inline ::std::string* release_destructableeffectpath();
  inline void set_allocated_destructableeffectpath(::std::string* destructableeffectpath);

  // optional uint32 Tid = 5;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>Destructable</name>
  	<Function>
  		<name>tid</name>
  		<replaceName>Tid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_tid</name>
  		<replaceName>Tid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_tid</name>
  		<replaceName>Tid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional .pb.PbRect_Int RectInfo = 6;
  inline bool has_rectinfo() const;
  inline void clear_rectinfo();
  static const int kRectInfoFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>Destructable</name>
  	<Function>
  		<name>rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect_Int& rectinfo() const;
  inline ::pb::PbRect_Int* mutable_rectinfo();
  inline ::pb::PbRect_Int* release_rectinfo();
  inline void set_allocated_rectinfo(::pb::PbRect_Int* rectinfo);

  // @@protoc_insertion_point(class_scope:pb.Destructable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_artobjectname();
  inline void clear_has_artobjectname();
  inline void set_has_artobjectposition();
  inline void clear_has_artobjectposition();
  inline void set_has_destructableeffectpath();
  inline void clear_has_destructableeffectpath();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_rectinfo();
  inline void clear_has_rectinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* artobjectname_;
  ::pb::PbVector3_Int* artobjectposition_;
  ::std::string* destructableeffectpath_;
  ::pb::PbRect_Int* rectinfo_;
  ::google::protobuf::uint32 tid_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static Destructable* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>Camera3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class Camera3 : public ::google::protobuf::Message {
 public:
  Camera3();
  virtual ~Camera3();

  Camera3(const Camera3& from);

  inline Camera3& operator=(const Camera3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Camera3& default_instance();

  void Swap(Camera3* other);

  // implements Message ----------------------------------------------

  Camera3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Camera3& from);
  void MergeFrom(const Camera3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float Fov = 2;
  inline bool has_fov() const;
  inline void clear_fov();
  static const int kFovFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>fov</name>
  		<replaceName>Fov</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fov</name>
  		<replaceName>Fov</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fov</name>
  		<replaceName>Fov</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fov() const;
  inline void set_fov(float value);

  // required .pb.PbVector3_Int Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // required .pb.PbVector3_Int Direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& direction() const;
  inline ::pb::PbVector3_Int* mutable_direction();
  inline ::pb::PbVector3_Int* release_direction();
  inline void set_allocated_direction(::pb::PbVector3_Int* direction);

  // required string FollowTargetName = 5;
  inline bool has_followtargetname() const;
  inline void clear_followtargetname();
  static const int kFollowTargetNameFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>followtargetname</name>
  		<replaceName>FollowTargetName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_followtargetname</name>
  		<replaceName>FollowTargetName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_followtargetname</name>
  		<replaceName>FollowTargetName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& followtargetname() const;
  inline void set_followtargetname(const ::std::string& value);
  inline void set_followtargetname(const char* value);
  inline void set_followtargetname(const char* value, size_t size);
  inline ::std::string* mutable_followtargetname();
  inline ::std::string* release_followtargetname();
  inline void set_allocated_followtargetname(::std::string* followtargetname);

  // optional .pb.ESceneElementType ElementType = 6;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // optional .pb.PbQuaternion LocalRotation = 7;
  inline bool has_localrotation() const;
  inline void clear_localrotation();
  static const int kLocalRotationFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>Camera3</name>
  	<Function>
  		<name>localrotation</name>
  		<replaceName>LocalRotation</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_localrotation</name>
  		<replaceName>LocalRotation</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_localrotation</name>
  		<replaceName>LocalRotation</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_localrotation</name>
  		<replaceName>LocalRotation</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbQuaternion& localrotation() const;
  inline ::pb::PbQuaternion* mutable_localrotation();
  inline ::pb::PbQuaternion* release_localrotation();
  inline void set_allocated_localrotation(::pb::PbQuaternion* localrotation);

  // @@protoc_insertion_point(class_scope:pb.Camera3)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fov();
  inline void clear_has_fov();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_followtargetname();
  inline void clear_has_followtargetname();
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_localrotation();
  inline void clear_has_localrotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector3_Int* position_;
  ::pb::PbVector3_Int* direction_;
  float fov_;
  int elementtype_;
  ::std::string* followtargetname_;
  ::pb::PbQuaternion* localrotation_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static Camera3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CustomArea3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CustomArea3 : public ::google::protobuf::Message {
 public:
  CustomArea3();
  virtual ~CustomArea3();

  CustomArea3(const CustomArea3& from);

  inline CustomArea3& operator=(const CustomArea3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomArea3& default_instance();

  void Swap(CustomArea3* other);

  // implements Message ----------------------------------------------

  CustomArea3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomArea3& from);
  void MergeFrom(const CustomArea3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ESceneElementType ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CustomArea3</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CustomArea3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.PbVector3_Int PointArr = 3;
  inline int pointarr_size() const;
  inline void clear_pointarr();
  static const int kPointArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>CustomArea3</name>
  	<Function>
  		<name>pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointarr_size</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& pointarr(int index) const;
  inline ::pb::PbVector3_Int* mutable_pointarr(int index);
  inline ::pb::PbVector3_Int* add_pointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >&
      pointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >*
      mutable_pointarr();

  // required bool Visible = 4;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>CustomArea3</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional int32 Index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>CustomArea3</name>
  	<Function>
  		<name>index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.CustomArea3)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int elementtype_;
  bool visible_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int > pointarr_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static CustomArea3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BlockLineFastFilter</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BlockLineFastFilter : public ::google::protobuf::Message {
 public:
  BlockLineFastFilter();
  virtual ~BlockLineFastFilter();

  BlockLineFastFilter(const BlockLineFastFilter& from);

  inline BlockLineFastFilter& operator=(const BlockLineFastFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockLineFastFilter& default_instance();

  void Swap(BlockLineFastFilter* other);

  // implements Message ----------------------------------------------

  BlockLineFastFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockLineFastFilter& from);
  void MergeFrom(const BlockLineFastFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 StripWidth = 1;
  inline bool has_stripwidth() const;
  inline void clear_stripwidth();
  static const int kStripWidthFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BlockLineFastFilter</name>
  	<Function>
  		<name>stripwidth</name>
  		<replaceName>StripWidth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_stripwidth</name>
  		<replaceName>StripWidth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_stripwidth</name>
  		<replaceName>StripWidth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 stripwidth() const;
  inline void set_stripwidth(::google::protobuf::int32 value);

  // repeated .pb.StripInfo ColStrips = 2;
  inline int colstrips_size() const;
  inline void clear_colstrips();
  static const int kColStripsFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BlockLineFastFilter</name>
  	<Function>
  		<name>colstrips</name>
  		<replaceName>ColStrips</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_colstrips</name>
  		<replaceName>ColStrips</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_colstrips</name>
  		<replaceName>ColStrips</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_colstrips</name>
  		<replaceName>ColStrips</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>colstrips_size</name>
  		<replaceName>ColStrips</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StripInfo& colstrips(int index) const;
  inline ::pb::StripInfo* mutable_colstrips(int index);
  inline ::pb::StripInfo* add_colstrips();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >&
      colstrips() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >*
      mutable_colstrips();

  // repeated .pb.StripInfo RowStrips = 3;
  inline int rowstrips_size() const;
  inline void clear_rowstrips();
  static const int kRowStripsFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BlockLineFastFilter</name>
  	<Function>
  		<name>rowstrips</name>
  		<replaceName>RowStrips</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rowstrips</name>
  		<replaceName>RowStrips</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rowstrips</name>
  		<replaceName>RowStrips</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rowstrips</name>
  		<replaceName>RowStrips</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rowstrips_size</name>
  		<replaceName>RowStrips</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StripInfo& rowstrips(int index) const;
  inline ::pb::StripInfo* mutable_rowstrips(int index);
  inline ::pb::StripInfo* add_rowstrips();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >&
      rowstrips() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >*
      mutable_rowstrips();

  // @@protoc_insertion_point(class_scope:pb.BlockLineFastFilter)
 private:
  inline void set_has_stripwidth();
  inline void clear_has_stripwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::StripInfo > colstrips_;
  ::google::protobuf::RepeatedPtrField< ::pb::StripInfo > rowstrips_;
  ::google::protobuf::int32 stripwidth_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static BlockLineFastFilter* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TDSpawnMapping</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TDSpawnMapping : public ::google::protobuf::Message {
 public:
  TDSpawnMapping();
  virtual ~TDSpawnMapping();

  TDSpawnMapping(const TDSpawnMapping& from);

  inline TDSpawnMapping& operator=(const TDSpawnMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TDSpawnMapping& default_instance();

  void Swap(TDSpawnMapping* other);

  // implements Message ----------------------------------------------

  TDSpawnMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TDSpawnMapping& from);
  void MergeFrom(const TDSpawnMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 PlatIndex = 1;
  inline bool has_platindex() const;
  inline void clear_platindex();
  static const int kPlatIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TDSpawnMapping</name>
  	<Function>
  		<name>platindex</name>
  		<replaceName>PlatIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_platindex</name>
  		<replaceName>PlatIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_platindex</name>
  		<replaceName>PlatIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 platindex() const;
  inline void set_platindex(::google::protobuf::int32 value);

  // optional int32 MeleeIndex = 2;
  inline bool has_meleeindex() const;
  inline void clear_meleeindex();
  static const int kMeleeIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TDSpawnMapping</name>
  	<Function>
  		<name>meleeindex</name>
  		<replaceName>MeleeIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_meleeindex</name>
  		<replaceName>MeleeIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_meleeindex</name>
  		<replaceName>MeleeIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 meleeindex() const;
  inline void set_meleeindex(::google::protobuf::int32 value);

  // optional int32 PlatWidth = 3;
  inline bool has_platwidth() const;
  inline void clear_platwidth();
  static const int kPlatWidthFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TDSpawnMapping</name>
  	<Function>
  		<name>platwidth</name>
  		<replaceName>PlatWidth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_platwidth</name>
  		<replaceName>PlatWidth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_platwidth</name>
  		<replaceName>PlatWidth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 platwidth() const;
  inline void set_platwidth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.TDSpawnMapping)
 private:
  inline void set_has_platindex();
  inline void clear_has_platindex();
  inline void set_has_meleeindex();
  inline void clear_has_meleeindex();
  inline void set_has_platwidth();
  inline void clear_has_platwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 platindex_;
  ::google::protobuf::int32 meleeindex_;
  ::google::protobuf::int32 platwidth_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static TDSpawnMapping* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>StripInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class StripInfo : public ::google::protobuf::Message {
 public:
  StripInfo();
  virtual ~StripInfo();

  StripInfo(const StripInfo& from);

  inline StripInfo& operator=(const StripInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StripInfo& default_instance();

  void Swap(StripInfo* other);

  // implements Message ----------------------------------------------

  StripInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StripInfo& from);
  void MergeFrom(const StripInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>StripInfo</name>
  	<Function>
  		<name>index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated int32 BlockLineArr = 2;
  inline int blocklinearr_size() const;
  inline void clear_blocklinearr();
  static const int kBlockLineArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>StripInfo</name>
  	<Function>
  		<name>blocklinearr</name>
  		<replaceName>BlockLineArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_blocklinearr</name>
  		<replaceName>BlockLineArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_blocklinearr</name>
  		<replaceName>BlockLineArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_blocklinearr</name>
  		<replaceName>BlockLineArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>blocklinearr_size</name>
  		<replaceName>BlockLineArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 blocklinearr(int index) const;
  inline void set_blocklinearr(int index, ::google::protobuf::int32 value);
  inline void add_blocklinearr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      blocklinearr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_blocklinearr();

  // @@protoc_insertion_point(class_scope:pb.StripInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > blocklinearr_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static StripInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AnimAsset3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AnimAsset3 : public ::google::protobuf::Message {
 public:
  AnimAsset3();
  virtual ~AnimAsset3();

  AnimAsset3(const AnimAsset3& from);

  inline AnimAsset3& operator=(const AnimAsset3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimAsset3& default_instance();

  void Swap(AnimAsset3* other);

  // implements Message ----------------------------------------------

  AnimAsset3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimAsset3& from);
  void MergeFrom(const AnimAsset3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector3_Int Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // required .pb.PbVector3_Int Direction = 3;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& direction() const;
  inline ::pb::PbVector3_Int* mutable_direction();
  inline ::pb::PbVector3_Int* release_direction();
  inline void set_allocated_direction(::pb::PbVector3_Int* direction);

  // required .pb.PbVector3_Int Scale = 4;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& scale() const;
  inline ::pb::PbVector3_Int* mutable_scale();
  inline ::pb::PbVector3_Int* release_scale();
  inline void set_allocated_scale(::pb::PbVector3_Int* scale);

  // required string AssetPath = 5;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // optional string DefaultAnim = 6;
  inline bool has_defaultanim() const;
  inline void clear_defaultanim();
  static const int kDefaultAnimFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& defaultanim() const;
  inline void set_defaultanim(const ::std::string& value);
  inline void set_defaultanim(const char* value);
  inline void set_defaultanim(const char* value, size_t size);
  inline ::std::string* mutable_defaultanim();
  inline ::std::string* release_defaultanim();
  inline void set_allocated_defaultanim(::std::string* defaultanim);

  // required bool Visible = 7;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset3</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:pb.AnimAsset3)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_defaultanim();
  inline void clear_has_defaultanim();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector3_Int* position_;
  ::pb::PbVector3_Int* direction_;
  ::pb::PbVector3_Int* scale_;
  ::std::string* assetpath_;
  ::std::string* defaultanim_;
  bool visible_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static AnimAsset3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>StaticAsset3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class StaticAsset3 : public ::google::protobuf::Message {
 public:
  StaticAsset3();
  virtual ~StaticAsset3();

  StaticAsset3(const StaticAsset3& from);

  inline StaticAsset3& operator=(const StaticAsset3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticAsset3& default_instance();

  void Swap(StaticAsset3* other);

  // implements Message ----------------------------------------------

  StaticAsset3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StaticAsset3& from);
  void MergeFrom(const StaticAsset3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector3_Int Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset3</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // required .pb.PbVector3_Int Direction = 3;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset3</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& direction() const;
  inline ::pb::PbVector3_Int* mutable_direction();
  inline ::pb::PbVector3_Int* release_direction();
  inline void set_allocated_direction(::pb::PbVector3_Int* direction);

  // required .pb.PbVector3_Int Scale = 4;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset3</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& scale() const;
  inline ::pb::PbVector3_Int* mutable_scale();
  inline ::pb::PbVector3_Int* release_scale();
  inline void set_allocated_scale(::pb::PbVector3_Int* scale);

  // required string AssetPath = 5;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset3</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // required bool Visible = 6;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset3</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:pb.StaticAsset3)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector3_Int* position_;
  ::pb::PbVector3_Int* direction_;
  ::pb::PbVector3_Int* scale_;
  ::std::string* assetpath_;
  bool visible_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static StaticAsset3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>EffectAsset3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class EffectAsset3 : public ::google::protobuf::Message {
 public:
  EffectAsset3();
  virtual ~EffectAsset3();

  EffectAsset3(const EffectAsset3& from);

  inline EffectAsset3& operator=(const EffectAsset3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EffectAsset3& default_instance();

  void Swap(EffectAsset3* other);

  // implements Message ----------------------------------------------

  EffectAsset3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EffectAsset3& from);
  void MergeFrom(const EffectAsset3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset3</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector3_Int Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset3</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // required string AssetPath = 3;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset3</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // required bool Visible = 4;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset3</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .pb.PbVector3_Int Direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset3</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& direction() const;
  inline ::pb::PbVector3_Int* mutable_direction();
  inline ::pb::PbVector3_Int* release_direction();
  inline void set_allocated_direction(::pb::PbVector3_Int* direction);

  // optional .pb.PbVector3_Int Scale = 6;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset3</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& scale() const;
  inline ::pb::PbVector3_Int* mutable_scale();
  inline ::pb::PbVector3_Int* release_scale();
  inline void set_allocated_scale(::pb::PbVector3_Int* scale);

  // @@protoc_insertion_point(class_scope:pb.EffectAsset3)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector3_Int* position_;
  ::std::string* assetpath_;
  ::pb::PbVector3_Int* direction_;
  ::pb::PbVector3_Int* scale_;
  bool visible_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static EffectAsset3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>LeapTrackPoint</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class LeapTrackPoint : public ::google::protobuf::Message {
 public:
  LeapTrackPoint();
  virtual ~LeapTrackPoint();

  LeapTrackPoint(const LeapTrackPoint& from);

  inline LeapTrackPoint& operator=(const LeapTrackPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeapTrackPoint& default_instance();

  void Swap(LeapTrackPoint* other);

  // implements Message ----------------------------------------------

  LeapTrackPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeapTrackPoint& from);
  void MergeFrom(const LeapTrackPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.PbVector3_Int Position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>LeapTrackPoint</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // optional float ToNextTrackPointTime = 2;
  inline bool has_tonexttrackpointtime() const;
  inline void clear_tonexttrackpointtime();
  static const int kToNextTrackPointTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>LeapTrackPoint</name>
  	<Function>
  		<name>tonexttrackpointtime</name>
  		<replaceName>ToNextTrackPointTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_tonexttrackpointtime</name>
  		<replaceName>ToNextTrackPointTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_tonexttrackpointtime</name>
  		<replaceName>ToNextTrackPointTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float tonexttrackpointtime() const;
  inline void set_tonexttrackpointtime(float value);

  // @@protoc_insertion_point(class_scope:pb.LeapTrackPoint)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_tonexttrackpointtime();
  inline void clear_has_tonexttrackpointtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector3_Int* position_;
  float tonexttrackpointtime_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static LeapTrackPoint* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>LeapTrack</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class LeapTrack : public ::google::protobuf::Message {
 public:
  LeapTrack();
  virtual ~LeapTrack();

  LeapTrack(const LeapTrack& from);

  inline LeapTrack& operator=(const LeapTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeapTrack& default_instance();

  void Swap(LeapTrack* other);

  // implements Message ----------------------------------------------

  LeapTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeapTrack& from);
  void MergeFrom(const LeapTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>LeapTrack</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.LeapTrackPoint PointArr = 2;
  inline int pointarr_size() const;
  inline void clear_pointarr();
  static const int kPointArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>LeapTrack</name>
  	<Function>
  		<name>pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointarr_size</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::LeapTrackPoint& pointarr(int index) const;
  inline ::pb::LeapTrackPoint* mutable_pointarr(int index);
  inline ::pb::LeapTrackPoint* add_pointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::LeapTrackPoint >&
      pointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::LeapTrackPoint >*
      mutable_pointarr();

  // optional float DropTime = 3;
  inline bool has_droptime() const;
  inline void clear_droptime();
  static const int kDropTimeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>LeapTrack</name>
  	<Function>
  		<name>droptime</name>
  		<replaceName>DropTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_droptime</name>
  		<replaceName>DropTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_droptime</name>
  		<replaceName>DropTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float droptime() const;
  inline void set_droptime(float value);

  // @@protoc_insertion_point(class_scope:pb.LeapTrack)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_droptime();
  inline void clear_has_droptime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::LeapTrackPoint > pointarr_;
  float droptime_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static LeapTrack* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CurveTrack</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CurveTrack : public ::google::protobuf::Message {
 public:
  CurveTrack();
  virtual ~CurveTrack();

  CurveTrack(const CurveTrack& from);

  inline CurveTrack& operator=(const CurveTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveTrack& default_instance();

  void Swap(CurveTrack* other);

  // implements Message ----------------------------------------------

  CurveTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveTrack& from);
  void MergeFrom(const CurveTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CurveTrack</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.PbVector3_Int PointPositionArr = 2;
  inline int pointpositionarr_size() const;
  inline void clear_pointpositionarr();
  static const int kPointPositionArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CurveTrack</name>
  	<Function>
  		<name>pointpositionarr</name>
  		<replaceName>PointPositionArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointpositionarr</name>
  		<replaceName>PointPositionArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointpositionarr</name>
  		<replaceName>PointPositionArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointpositionarr</name>
  		<replaceName>PointPositionArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointpositionarr_size</name>
  		<replaceName>PointPositionArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& pointpositionarr(int index) const;
  inline ::pb::PbVector3_Int* mutable_pointpositionarr(int index);
  inline ::pb::PbVector3_Int* add_pointpositionarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >&
      pointpositionarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >*
      mutable_pointpositionarr();

  // @@protoc_insertion_point(class_scope:pb.CurveTrack)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int > pointpositionarr_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static CurveTrack* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>PathPoint</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PathPoint : public ::google::protobuf::Message {
 public:
  PathPoint();
  virtual ~PathPoint();

  PathPoint(const PathPoint& from);

  inline PathPoint& operator=(const PathPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathPoint& default_instance();

  void Swap(PathPoint* other);

  // implements Message ----------------------------------------------

  PathPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathPoint& from);
  void MergeFrom(const PathPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 PointEvent = 1;
  inline bool has_pointevent() const;
  inline void clear_pointevent();
  static const int kPointEventFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PathPoint</name>
  	<Function>
  		<name>pointevent</name>
  		<replaceName>PointEvent</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_pointevent</name>
  		<replaceName>PointEvent</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointevent</name>
  		<replaceName>PointEvent</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 pointevent() const;
  inline void set_pointevent(::google::protobuf::int32 value);

  // optional .pb.PbVector3_Int Point = 2;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PathPoint</name>
  	<Function>
  		<name>point</name>
  		<replaceName>Point</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_point</name>
  		<replaceName>Point</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_point</name>
  		<replaceName>Point</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_point</name>
  		<replaceName>Point</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& point() const;
  inline ::pb::PbVector3_Int* mutable_point();
  inline ::pb::PbVector3_Int* release_point();
  inline void set_allocated_point(::pb::PbVector3_Int* point);

  // @@protoc_insertion_point(class_scope:pb.PathPoint)
 private:
  inline void set_has_pointevent();
  inline void clear_has_pointevent();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector3_Int* point_;
  ::google::protobuf::int32 pointevent_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static PathPoint* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>PathTrack</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PathTrack : public ::google::protobuf::Message {
 public:
  PathTrack();
  virtual ~PathTrack();

  PathTrack(const PathTrack& from);

  inline PathTrack& operator=(const PathTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathTrack& default_instance();

  void Swap(PathTrack* other);

  // implements Message ----------------------------------------------

  PathTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathTrack& from);
  void MergeFrom(const PathTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PathTrack</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 Index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PathTrack</name>
  	<Function>
  		<name>index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated .pb.PathPoint PointArr = 3;
  inline int pointarr_size() const;
  inline void clear_pointarr();
  static const int kPointArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>PathTrack</name>
  	<Function>
  		<name>pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointarr_size</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PathPoint& pointarr(int index) const;
  inline ::pb::PathPoint* mutable_pointarr(int index);
  inline ::pb::PathPoint* add_pointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PathPoint >&
      pointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PathPoint >*
      mutable_pointarr();

  // @@protoc_insertion_point(class_scope:pb.PathTrack)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::PathPoint > pointarr_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static PathTrack* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CameraTrackPoint</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CameraTrackPoint : public ::google::protobuf::Message {
 public:
  CameraTrackPoint();
  virtual ~CameraTrackPoint();

  CameraTrackPoint(const CameraTrackPoint& from);

  inline CameraTrackPoint& operator=(const CameraTrackPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraTrackPoint& default_instance();

  void Swap(CameraTrackPoint* other);

  // implements Message ----------------------------------------------

  CameraTrackPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraTrackPoint& from);
  void MergeFrom(const CameraTrackPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.PbVector3_Int Position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CameraTrackPoint</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // optional .pb.PbQuaternion Rotation = 2;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CameraTrackPoint</name>
  	<Function>
  		<name>rotation</name>
  		<replaceName>Rotation</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rotation</name>
  		<replaceName>Rotation</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rotation</name>
  		<replaceName>Rotation</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rotation</name>
  		<replaceName>Rotation</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbQuaternion& rotation() const;
  inline ::pb::PbQuaternion* mutable_rotation();
  inline ::pb::PbQuaternion* release_rotation();
  inline void set_allocated_rotation(::pb::PbQuaternion* rotation);

  // optional float StartTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>CameraTrackPoint</name>
  	<Function>
  		<name>starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float starttime() const;
  inline void set_starttime(float value);

  // @@protoc_insertion_point(class_scope:pb.CameraTrackPoint)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_starttime();
  inline void clear_has_starttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector3_Int* position_;
  ::pb::PbQuaternion* rotation_;
  float starttime_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static CameraTrackPoint* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CameraTrack</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CameraTrack : public ::google::protobuf::Message {
 public:
  CameraTrack();
  virtual ~CameraTrack();

  CameraTrack(const CameraTrack& from);

  inline CameraTrack& operator=(const CameraTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraTrack& default_instance();

  void Swap(CameraTrack* other);

  // implements Message ----------------------------------------------

  CameraTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraTrack& from);
  void MergeFrom(const CameraTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CameraTrack</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string AnimResPath = 2;
  inline bool has_animrespath() const;
  inline void clear_animrespath();
  static const int kAnimResPathFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CameraTrack</name>
  	<Function>
  		<name>animrespath</name>
  		<replaceName>AnimResPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_animrespath</name>
  		<replaceName>AnimResPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animrespath</name>
  		<replaceName>AnimResPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& animrespath() const;
  inline void set_animrespath(const ::std::string& value);
  inline void set_animrespath(const char* value);
  inline void set_animrespath(const char* value, size_t size);
  inline ::std::string* mutable_animrespath();
  inline ::std::string* release_animrespath();
  inline void set_allocated_animrespath(::std::string* animrespath);

  // repeated .pb.CameraTrackPoint PointArr = 3;
  inline int pointarr_size() const;
  inline void clear_pointarr();
  static const int kPointArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>CameraTrack</name>
  	<Function>
  		<name>pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointarr_size</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CameraTrackPoint& pointarr(int index) const;
  inline ::pb::CameraTrackPoint* mutable_pointarr(int index);
  inline ::pb::CameraTrackPoint* add_pointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraTrackPoint >&
      pointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CameraTrackPoint >*
      mutable_pointarr();

  // optional float Length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>CameraTrack</name>
  	<Function>
  		<name>length</name>
  		<replaceName>Length</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_length</name>
  		<replaceName>Length</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_length</name>
  		<replaceName>Length</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float length() const;
  inline void set_length(float value);

  // @@protoc_insertion_point(class_scope:pb.CameraTrack)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_animrespath();
  inline void clear_has_animrespath();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* animrespath_;
  ::google::protobuf::RepeatedPtrField< ::pb::CameraTrackPoint > pointarr_;
  float length_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static CameraTrack* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>FieldConf3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class FieldConf3 : public ::google::protobuf::Message {
 public:
  FieldConf3();
  virtual ~FieldConf3();

  FieldConf3(const FieldConf3& from);

  inline FieldConf3& operator=(const FieldConf3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldConf3& default_instance();

  void Swap(FieldConf3* other);

  // implements Message ----------------------------------------------

  FieldConf3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FieldConf3& from);
  void MergeFrom(const FieldConf3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string FieldConfName = 1;
  inline bool has_fieldconfname() const;
  inline void clear_fieldconfname();
  static const int kFieldConfNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>fieldconfname</name>
  		<replaceName>FieldConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fieldconfname</name>
  		<replaceName>FieldConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fieldconfname</name>
  		<replaceName>FieldConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& fieldconfname() const;
  inline void set_fieldconfname(const ::std::string& value);
  inline void set_fieldconfname(const char* value);
  inline void set_fieldconfname(const char* value, size_t size);
  inline ::std::string* mutable_fieldconfname();
  inline ::std::string* release_fieldconfname();
  inline void set_allocated_fieldconfname(::std::string* fieldconfname);

  // repeated .pb.PointElement3 PointElementArr = 2;
  inline int pointelementarr_size() const;
  inline void clear_pointelementarr();
  static const int kPointElementArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointelementarr_size</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PointElement3& pointelementarr(int index) const;
  inline ::pb::PointElement3* mutable_pointelementarr(int index);
  inline ::pb::PointElement3* add_pointelementarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement3 >&
      pointelementarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement3 >*
      mutable_pointelementarr();

  // repeated .pb.RectArea3 RectAreaArr = 3;
  inline int rectareaarr_size() const;
  inline void clear_rectareaarr();
  static const int kRectAreaArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rectareaarr_size</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::RectArea3& rectareaarr(int index) const;
  inline ::pb::RectArea3* mutable_rectareaarr(int index);
  inline ::pb::RectArea3* add_rectareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea3 >&
      rectareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea3 >*
      mutable_rectareaarr();

  // repeated .pb.Camera3 CameraInfoArr = 4;
  inline int camerainfoarr_size() const;
  inline void clear_camerainfoarr();
  static const int kCameraInfoArrFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>camerainfoarr</name>
  		<replaceName>CameraInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_camerainfoarr</name>
  		<replaceName>CameraInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_camerainfoarr</name>
  		<replaceName>CameraInfoArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_camerainfoarr</name>
  		<replaceName>CameraInfoArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>camerainfoarr_size</name>
  		<replaceName>CameraInfoArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::Camera3& camerainfoarr(int index) const;
  inline ::pb::Camera3* mutable_camerainfoarr(int index);
  inline ::pb::Camera3* add_camerainfoarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Camera3 >&
      camerainfoarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Camera3 >*
      mutable_camerainfoarr();

  // repeated .pb.CustomArea3 CustomAreaArr = 5;
  inline int customareaarr_size() const;
  inline void clear_customareaarr();
  static const int kCustomAreaArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>customareaarr_size</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CustomArea3& customareaarr(int index) const;
  inline ::pb::CustomArea3* mutable_customareaarr(int index);
  inline ::pb::CustomArea3* add_customareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea3 >&
      customareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea3 >*
      mutable_customareaarr();

  // repeated .pb.AnimAsset3 AnimAssetArr = 6;
  inline int animassetarr_size() const;
  inline void clear_animassetarr();
  static const int kAnimAssetArrFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>animassetarr_size</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AnimAsset3& animassetarr(int index) const;
  inline ::pb::AnimAsset3* mutable_animassetarr(int index);
  inline ::pb::AnimAsset3* add_animassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset3 >&
      animassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset3 >*
      mutable_animassetarr();

  // repeated .pb.StaticAsset3 StaticAssetArr = 7;
  inline int staticassetarr_size() const;
  inline void clear_staticassetarr();
  static const int kStaticAssetArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>staticassetarr_size</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StaticAsset3& staticassetarr(int index) const;
  inline ::pb::StaticAsset3* mutable_staticassetarr(int index);
  inline ::pb::StaticAsset3* add_staticassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset3 >&
      staticassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset3 >*
      mutable_staticassetarr();

  // repeated .pb.EffectAsset3 EffectAssetArr = 8;
  inline int effectassetarr_size() const;
  inline void clear_effectassetarr();
  static const int kEffectAssetArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectassetarr_size</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectAsset3& effectassetarr(int index) const;
  inline ::pb::EffectAsset3* mutable_effectassetarr(int index);
  inline ::pb::EffectAsset3* add_effectassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset3 >&
      effectassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset3 >*
      mutable_effectassetarr();

  // optional .pb.PbVector3_Int RootPosition = 9;
  inline bool has_rootposition() const;
  inline void clear_rootposition();
  static const int kRootPositionFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>rootposition</name>
  		<replaceName>RootPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rootposition</name>
  		<replaceName>RootPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rootposition</name>
  		<replaceName>RootPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rootposition</name>
  		<replaceName>RootPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& rootposition() const;
  inline ::pb::PbVector3_Int* mutable_rootposition();
  inline ::pb::PbVector3_Int* release_rootposition();
  inline void set_allocated_rootposition(::pb::PbVector3_Int* rootposition);

  // optional .pb.PbVector3_Int RootDirection = 10;
  inline bool has_rootdirection() const;
  inline void clear_rootdirection();
  static const int kRootDirectionFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>rootdirection</name>
  		<replaceName>RootDirection</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rootdirection</name>
  		<replaceName>RootDirection</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rootdirection</name>
  		<replaceName>RootDirection</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rootdirection</name>
  		<replaceName>RootDirection</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& rootdirection() const;
  inline ::pb::PbVector3_Int* mutable_rootdirection();
  inline ::pb::PbVector3_Int* release_rootdirection();
  inline void set_allocated_rootdirection(::pb::PbVector3_Int* rootdirection);

  // optional int32 StandardlinePosX = 11;
  inline bool has_standardlineposx() const;
  inline void clear_standardlineposx();
  static const int kStandardlinePosXFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>standardlineposx</name>
  		<replaceName>StandardlinePosX</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_standardlineposx</name>
  		<replaceName>StandardlinePosX</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_standardlineposx</name>
  		<replaceName>StandardlinePosX</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 standardlineposx() const;
  inline void set_standardlineposx(::google::protobuf::int32 value);

  // optional .pb.PbVector2_Int LenAndWid = 12;
  inline bool has_lenandwid() const;
  inline void clear_lenandwid();
  static const int kLenAndWidFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>lenandwid</name>
  		<replaceName>LenAndWid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_lenandwid</name>
  		<replaceName>LenAndWid</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_lenandwid</name>
  		<replaceName>LenAndWid</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_lenandwid</name>
  		<replaceName>LenAndWid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2_Int& lenandwid() const;
  inline ::pb::PbVector2_Int* mutable_lenandwid();
  inline ::pb::PbVector2_Int* release_lenandwid();
  inline void set_allocated_lenandwid(::pb::PbVector2_Int* lenandwid);

  // repeated .pb.Destructable DestructableArr = 13;
  inline int destructablearr_size() const;
  inline void clear_destructablearr();
  static const int kDestructableArrFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>destructablearr</name>
  		<replaceName>DestructableArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_destructablearr</name>
  		<replaceName>DestructableArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_destructablearr</name>
  		<replaceName>DestructableArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_destructablearr</name>
  		<replaceName>DestructableArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>destructablearr_size</name>
  		<replaceName>DestructableArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::Destructable& destructablearr(int index) const;
  inline ::pb::Destructable* mutable_destructablearr(int index);
  inline ::pb::Destructable* add_destructablearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Destructable >&
      destructablearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Destructable >*
      mutable_destructablearr();

  // optional string CutSceneCameraTrackName = 14;
  inline bool has_cutscenecameratrackname() const;
  inline void clear_cutscenecameratrackname();
  static const int kCutSceneCameraTrackNameFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>cutscenecameratrackname</name>
  		<replaceName>CutSceneCameraTrackName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_cutscenecameratrackname</name>
  		<replaceName>CutSceneCameraTrackName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cutscenecameratrackname</name>
  		<replaceName>CutSceneCameraTrackName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& cutscenecameratrackname() const;
  inline void set_cutscenecameratrackname(const ::std::string& value);
  inline void set_cutscenecameratrackname(const char* value);
  inline void set_cutscenecameratrackname(const char* value, size_t size);
  inline ::std::string* mutable_cutscenecameratrackname();
  inline ::std::string* release_cutscenecameratrackname();
  inline void set_allocated_cutscenecameratrackname(::std::string* cutscenecameratrackname);

  // repeated int32 PositionlinePosX = 15;
  inline int positionlineposx_size() const;
  inline void clear_positionlineposx();
  static const int kPositionlinePosXFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>positionlineposx</name>
  		<replaceName>PositionlinePosX</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_positionlineposx</name>
  		<replaceName>PositionlinePosX</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_positionlineposx</name>
  		<replaceName>PositionlinePosX</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_positionlineposx</name>
  		<replaceName>PositionlinePosX</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>positionlineposx_size</name>
  		<replaceName>PositionlinePosX</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 positionlineposx(int index) const;
  inline void set_positionlineposx(int index, ::google::protobuf::int32 value);
  inline void add_positionlineposx(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      positionlineposx() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_positionlineposx();

  // optional bool NeedSyncTimeline = 16;
  inline bool has_needsynctimeline() const;
  inline void clear_needsynctimeline();
  static const int kNeedSyncTimelineFieldNumber = 16;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>needsynctimeline</name>
  		<replaceName>NeedSyncTimeline</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_needsynctimeline</name>
  		<replaceName>NeedSyncTimeline</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_needsynctimeline</name>
  		<replaceName>NeedSyncTimeline</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool needsynctimeline() const;
  inline void set_needsynctimeline(bool value);

  // repeated .pb.PathTrack PathTrackArr = 17;
  inline int pathtrackarr_size() const;
  inline void clear_pathtrackarr();
  static const int kPathTrackArrFieldNumber = 17;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>pathtrackarr</name>
  		<replaceName>PathTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pathtrackarr</name>
  		<replaceName>PathTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pathtrackarr</name>
  		<replaceName>PathTrackArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pathtrackarr</name>
  		<replaceName>PathTrackArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pathtrackarr_size</name>
  		<replaceName>PathTrackArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PathTrack& pathtrackarr(int index) const;
  inline ::pb::PathTrack* mutable_pathtrackarr(int index);
  inline ::pb::PathTrack* add_pathtrackarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PathTrack >&
      pathtrackarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PathTrack >*
      mutable_pathtrackarr();

  // optional .pb.BlockLineFastFilter Filter = 18;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 18;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>filter</name>
  		<replaceName>Filter</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_filter</name>
  		<replaceName>Filter</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_filter</name>
  		<replaceName>Filter</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_filter</name>
  		<replaceName>Filter</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BlockLineFastFilter& filter() const;
  inline ::pb::BlockLineFastFilter* mutable_filter();
  inline ::pb::BlockLineFastFilter* release_filter();
  inline void set_allocated_filter(::pb::BlockLineFastFilter* filter);

  // repeated .pb.TDSpawnMapping SpawnMapping = 19;
  inline int spawnmapping_size() const;
  inline void clear_spawnmapping();
  static const int kSpawnMappingFieldNumber = 19;
  /*FOR2LUA
  <Record>
  	<name>FieldConf3</name>
  	<Function>
  		<name>spawnmapping</name>
  		<replaceName>SpawnMapping</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_spawnmapping</name>
  		<replaceName>SpawnMapping</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_spawnmapping</name>
  		<replaceName>SpawnMapping</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_spawnmapping</name>
  		<replaceName>SpawnMapping</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>spawnmapping_size</name>
  		<replaceName>SpawnMapping</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TDSpawnMapping& spawnmapping(int index) const;
  inline ::pb::TDSpawnMapping* mutable_spawnmapping(int index);
  inline ::pb::TDSpawnMapping* add_spawnmapping();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TDSpawnMapping >&
      spawnmapping() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TDSpawnMapping >*
      mutable_spawnmapping();

  // @@protoc_insertion_point(class_scope:pb.FieldConf3)
 private:
  inline void set_has_fieldconfname();
  inline void clear_has_fieldconfname();
  inline void set_has_rootposition();
  inline void clear_has_rootposition();
  inline void set_has_rootdirection();
  inline void clear_has_rootdirection();
  inline void set_has_standardlineposx();
  inline void clear_has_standardlineposx();
  inline void set_has_lenandwid();
  inline void clear_has_lenandwid();
  inline void set_has_cutscenecameratrackname();
  inline void clear_has_cutscenecameratrackname();
  inline void set_has_needsynctimeline();
  inline void clear_has_needsynctimeline();
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fieldconfname_;
  ::google::protobuf::RepeatedPtrField< ::pb::PointElement3 > pointelementarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::RectArea3 > rectareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::Camera3 > camerainfoarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::CustomArea3 > customareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset3 > animassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset3 > staticassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset3 > effectassetarr_;
  ::pb::PbVector3_Int* rootposition_;
  ::pb::PbVector3_Int* rootdirection_;
  ::pb::PbVector2_Int* lenandwid_;
  ::google::protobuf::RepeatedPtrField< ::pb::Destructable > destructablearr_;
  ::google::protobuf::int32 standardlineposx_;
  bool needsynctimeline_;
  ::std::string* cutscenecameratrackname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > positionlineposx_;
  ::google::protobuf::RepeatedPtrField< ::pb::PathTrack > pathtrackarr_;
  ::pb::BlockLineFastFilter* filter_;
  ::google::protobuf::RepeatedPtrField< ::pb::TDSpawnMapping > spawnmapping_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static FieldConf3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SceneConf3d</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf3d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SceneConf3d : public ::google::protobuf::Message {
 public:
  SceneConf3d();
  virtual ~SceneConf3d();

  SceneConf3d(const SceneConf3d& from);

  inline SceneConf3d& operator=(const SceneConf3d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneConf3d& default_instance();

  void Swap(SceneConf3d* other);

  // implements Message ----------------------------------------------

  SceneConf3d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneConf3d& from);
  void MergeFrom(const SceneConf3d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string ConfName = 2;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // required string ArtScenePath = 3;
  inline bool has_artscenepath() const;
  inline void clear_artscenepath();
  static const int kArtScenePathFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& artscenepath() const;
  inline void set_artscenepath(const ::std::string& value);
  inline void set_artscenepath(const char* value);
  inline void set_artscenepath(const char* value, size_t size);
  inline ::std::string* mutable_artscenepath();
  inline ::std::string* release_artscenepath();
  inline void set_allocated_artscenepath(::std::string* artscenepath);

  // repeated .pb.FieldConf3 FieldConfArr = 4;
  inline int fieldconfarr_size() const;
  inline void clear_fieldconfarr();
  static const int kFieldConfArrFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>fieldconfarr</name>
  		<replaceName>FieldConfArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_fieldconfarr</name>
  		<replaceName>FieldConfArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_fieldconfarr</name>
  		<replaceName>FieldConfArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fieldconfarr</name>
  		<replaceName>FieldConfArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>fieldconfarr_size</name>
  		<replaceName>FieldConfArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::FieldConf3& fieldconfarr(int index) const;
  inline ::pb::FieldConf3* mutable_fieldconfarr(int index);
  inline ::pb::FieldConf3* add_fieldconfarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::FieldConf3 >&
      fieldconfarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::FieldConf3 >*
      mutable_fieldconfarr();

  // repeated .pb.LeapTrack LeapTrackArr = 5;
  inline int leaptrackarr_size() const;
  inline void clear_leaptrackarr();
  static const int kLeapTrackArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>leaptrackarr</name>
  		<replaceName>LeapTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_leaptrackarr</name>
  		<replaceName>LeapTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_leaptrackarr</name>
  		<replaceName>LeapTrackArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_leaptrackarr</name>
  		<replaceName>LeapTrackArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>leaptrackarr_size</name>
  		<replaceName>LeapTrackArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::LeapTrack& leaptrackarr(int index) const;
  inline ::pb::LeapTrack* mutable_leaptrackarr(int index);
  inline ::pb::LeapTrack* add_leaptrackarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::LeapTrack >&
      leaptrackarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::LeapTrack >*
      mutable_leaptrackarr();

  // optional string GridDataPath = 6;
  inline bool has_griddatapath() const;
  inline void clear_griddatapath();
  static const int kGridDataPathFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>griddatapath</name>
  		<replaceName>GridDataPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_griddatapath</name>
  		<replaceName>GridDataPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_griddatapath</name>
  		<replaceName>GridDataPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& griddatapath() const;
  inline void set_griddatapath(const ::std::string& value);
  inline void set_griddatapath(const char* value);
  inline void set_griddatapath(const char* value, size_t size);
  inline ::std::string* mutable_griddatapath();
  inline ::std::string* release_griddatapath();
  inline void set_allocated_griddatapath(::std::string* griddatapath);

  // repeated .pb.CameraTrack CameraTrackArr = 7;
  inline int cameratrackarr_size() const;
  inline void clear_cameratrackarr();
  static const int kCameraTrackArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>cameratrackarr</name>
  		<replaceName>CameraTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_cameratrackarr</name>
  		<replaceName>CameraTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_cameratrackarr</name>
  		<replaceName>CameraTrackArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cameratrackarr</name>
  		<replaceName>CameraTrackArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>cameratrackarr_size</name>
  		<replaceName>CameraTrackArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CameraTrack& cameratrackarr(int index) const;
  inline ::pb::CameraTrack* mutable_cameratrackarr(int index);
  inline ::pb::CameraTrack* add_cameratrackarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraTrack >&
      cameratrackarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CameraTrack >*
      mutable_cameratrackarr();

  // repeated .pb.CurveTrack CurveTrackArr = 8;
  inline int curvetrackarr_size() const;
  inline void clear_curvetrackarr();
  static const int kCurveTrackArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>curvetrackarr</name>
  		<replaceName>CurveTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_curvetrackarr</name>
  		<replaceName>CurveTrackArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_curvetrackarr</name>
  		<replaceName>CurveTrackArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_curvetrackarr</name>
  		<replaceName>CurveTrackArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>curvetrackarr_size</name>
  		<replaceName>CurveTrackArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CurveTrack& curvetrackarr(int index) const;
  inline ::pb::CurveTrack* mutable_curvetrackarr(int index);
  inline ::pb::CurveTrack* add_curvetrackarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CurveTrack >&
      curvetrackarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CurveTrack >*
      mutable_curvetrackarr();

  // optional .pb.Camera3 SceneCamera = 9;
  inline bool has_scenecamera() const;
  inline void clear_scenecamera();
  static const int kSceneCameraFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>SceneConf3d</name>
  	<Function>
  		<name>scenecamera</name>
  		<replaceName>SceneCamera</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scenecamera</name>
  		<replaceName>SceneCamera</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scenecamera</name>
  		<replaceName>SceneCamera</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scenecamera</name>
  		<replaceName>SceneCamera</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::Camera3& scenecamera() const;
  inline ::pb::Camera3* mutable_scenecamera();
  inline ::pb::Camera3* release_scenecamera();
  inline void set_allocated_scenecamera(::pb::Camera3* scenecamera);

  // @@protoc_insertion_point(class_scope:pb.SceneConf3d)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_artscenepath();
  inline void clear_has_artscenepath();
  inline void set_has_griddatapath();
  inline void clear_has_griddatapath();
  inline void set_has_scenecamera();
  inline void clear_has_scenecamera();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* confname_;
  ::std::string* artscenepath_;
  ::google::protobuf::RepeatedPtrField< ::pb::FieldConf3 > fieldconfarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::LeapTrack > leaptrackarr_;
  ::std::string* griddatapath_;
  ::google::protobuf::RepeatedPtrField< ::pb::CameraTrack > cameratrackarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::CurveTrack > curvetrackarr_;
  ::pb::Camera3* scenecamera_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf3d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf3d_2eproto();

  void InitAsDefaultInstance();
  static SceneConf3d* default_instance_;
};
// ===================================================================


// ===================================================================

// PointElement3

// required .pb.ESceneElementType ElementType = 1;
inline bool PointElement3::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointElement3::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointElement3::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointElement3::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType PointElement3::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.PointElement3.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void PointElement3::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.PointElement3.ElementType)
}

// required string Name = 2;
inline bool PointElement3::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointElement3::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointElement3::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointElement3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PointElement3::name() const {
  // @@protoc_insertion_point(field_get:pb.PointElement3.Name)
  return *name_;
}
inline void PointElement3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PointElement3.Name)
}
inline void PointElement3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PointElement3.Name)
}
inline void PointElement3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PointElement3.Name)
}
inline ::std::string* PointElement3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PointElement3.Name)
  return name_;
}
inline ::std::string* PointElement3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PointElement3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement3.Name)
}

// required .pb.PbVector3_Int Position = 3;
inline bool PointElement3::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointElement3::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointElement3::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointElement3::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& PointElement3::position() const {
  // @@protoc_insertion_point(field_get:pb.PointElement3.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* PointElement3::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.PointElement3.Position)
  return position_;
}
inline ::pb::PbVector3_Int* PointElement3::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PointElement3::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement3.Position)
}

// optional .pb.PbVector3_Int Direction = 4;
inline bool PointElement3::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointElement3::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointElement3::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointElement3::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector3_Int::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector3_Int& PointElement3::direction() const {
  // @@protoc_insertion_point(field_get:pb.PointElement3.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector3_Int* PointElement3::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.PointElement3.Direction)
  return direction_;
}
inline ::pb::PbVector3_Int* PointElement3::release_direction() {
  clear_has_direction();
  ::pb::PbVector3_Int* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void PointElement3::set_allocated_direction(::pb::PbVector3_Int* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement3.Direction)
}

// repeated string JumpTrackNameArr = 5;
inline int PointElement3::jumptracknamearr_size() const {
  return jumptracknamearr_.size();
}
inline void PointElement3::clear_jumptracknamearr() {
  jumptracknamearr_.Clear();
}
inline const ::std::string& PointElement3::jumptracknamearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.PointElement3.JumpTrackNameArr)
  return jumptracknamearr_.Get(index);
}
inline ::std::string* PointElement3::mutable_jumptracknamearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PointElement3.JumpTrackNameArr)
  return jumptracknamearr_.Mutable(index);
}
inline void PointElement3::set_jumptracknamearr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.PointElement3.JumpTrackNameArr)
  jumptracknamearr_.Mutable(index)->assign(value);
}
inline void PointElement3::set_jumptracknamearr(int index, const char* value) {
  jumptracknamearr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PointElement3.JumpTrackNameArr)
}
inline void PointElement3::set_jumptracknamearr(int index, const char* value, size_t size) {
  jumptracknamearr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PointElement3.JumpTrackNameArr)
}
inline ::std::string* PointElement3::add_jumptracknamearr() {
  return jumptracknamearr_.Add();
}
inline void PointElement3::add_jumptracknamearr(const ::std::string& value) {
  jumptracknamearr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PointElement3.JumpTrackNameArr)
}
inline void PointElement3::add_jumptracknamearr(const char* value) {
  jumptracknamearr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PointElement3.JumpTrackNameArr)
}
inline void PointElement3::add_jumptracknamearr(const char* value, size_t size) {
  jumptracknamearr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PointElement3.JumpTrackNameArr)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PointElement3::jumptracknamearr() const {
  // @@protoc_insertion_point(field_list:pb.PointElement3.JumpTrackNameArr)
  return jumptracknamearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PointElement3::mutable_jumptracknamearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.PointElement3.JumpTrackNameArr)
  return &jumptracknamearr_;
}

// optional int32 PathTrackIndex = 6;
inline bool PointElement3::has_pathtrackindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PointElement3::set_has_pathtrackindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PointElement3::clear_has_pathtrackindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PointElement3::clear_pathtrackindex() {
  pathtrackindex_ = 0;
  clear_has_pathtrackindex();
}
inline ::google::protobuf::int32 PointElement3::pathtrackindex() const {
  // @@protoc_insertion_point(field_get:pb.PointElement3.PathTrackIndex)
  return pathtrackindex_;
}
inline void PointElement3::set_pathtrackindex(::google::protobuf::int32 value) {
  set_has_pathtrackindex();
  pathtrackindex_ = value;
  // @@protoc_insertion_point(field_set:pb.PointElement3.PathTrackIndex)
}

// -------------------------------------------------------------------

// RectArea3

// required .pb.ESceneElementType ElementType = 1;
inline bool RectArea3::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RectArea3::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RectArea3::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RectArea3::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType RectArea3::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.RectArea3.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void RectArea3::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.RectArea3.ElementType)
}

// required string Name = 2;
inline bool RectArea3::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RectArea3::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RectArea3::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RectArea3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RectArea3::name() const {
  // @@protoc_insertion_point(field_get:pb.RectArea3.Name)
  return *name_;
}
inline void RectArea3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.RectArea3.Name)
}
inline void RectArea3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.RectArea3.Name)
}
inline void RectArea3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.RectArea3.Name)
}
inline ::std::string* RectArea3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.RectArea3.Name)
  return name_;
}
inline ::std::string* RectArea3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RectArea3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea3.Name)
}

// required .pb.PbRect_Int RectInfo = 3;
inline bool RectArea3::has_rectinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RectArea3::set_has_rectinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RectArea3::clear_has_rectinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RectArea3::clear_rectinfo() {
  if (rectinfo_ != NULL) rectinfo_->::pb::PbRect_Int::Clear();
  clear_has_rectinfo();
}
inline const ::pb::PbRect_Int& RectArea3::rectinfo() const {
  // @@protoc_insertion_point(field_get:pb.RectArea3.RectInfo)
  return rectinfo_ != NULL ? *rectinfo_ : *default_instance_->rectinfo_;
}
inline ::pb::PbRect_Int* RectArea3::mutable_rectinfo() {
  set_has_rectinfo();
  if (rectinfo_ == NULL) rectinfo_ = new ::pb::PbRect_Int;
  // @@protoc_insertion_point(field_mutable:pb.RectArea3.RectInfo)
  return rectinfo_;
}
inline ::pb::PbRect_Int* RectArea3::release_rectinfo() {
  clear_has_rectinfo();
  ::pb::PbRect_Int* temp = rectinfo_;
  rectinfo_ = NULL;
  return temp;
}
inline void RectArea3::set_allocated_rectinfo(::pb::PbRect_Int* rectinfo) {
  delete rectinfo_;
  rectinfo_ = rectinfo;
  if (rectinfo) {
    set_has_rectinfo();
  } else {
    clear_has_rectinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea3.RectInfo)
}

// required .pb.PbVector3_Int CenterPosition = 4;
inline bool RectArea3::has_centerposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RectArea3::set_has_centerposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RectArea3::clear_has_centerposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RectArea3::clear_centerposition() {
  if (centerposition_ != NULL) centerposition_->::pb::PbVector3_Int::Clear();
  clear_has_centerposition();
}
inline const ::pb::PbVector3_Int& RectArea3::centerposition() const {
  // @@protoc_insertion_point(field_get:pb.RectArea3.CenterPosition)
  return centerposition_ != NULL ? *centerposition_ : *default_instance_->centerposition_;
}
inline ::pb::PbVector3_Int* RectArea3::mutable_centerposition() {
  set_has_centerposition();
  if (centerposition_ == NULL) centerposition_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.RectArea3.CenterPosition)
  return centerposition_;
}
inline ::pb::PbVector3_Int* RectArea3::release_centerposition() {
  clear_has_centerposition();
  ::pb::PbVector3_Int* temp = centerposition_;
  centerposition_ = NULL;
  return temp;
}
inline void RectArea3::set_allocated_centerposition(::pb::PbVector3_Int* centerposition) {
  delete centerposition_;
  centerposition_ = centerposition;
  if (centerposition) {
    set_has_centerposition();
  } else {
    clear_has_centerposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea3.CenterPosition)
}

// required bool Visible = 5;
inline bool RectArea3::has_visible() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RectArea3::set_has_visible() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RectArea3::clear_has_visible() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RectArea3::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool RectArea3::visible() const {
  // @@protoc_insertion_point(field_get:pb.RectArea3.Visible)
  return visible_;
}
inline void RectArea3::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.RectArea3.Visible)
}

// -------------------------------------------------------------------

// Destructable

// optional string Name = 1;
inline bool Destructable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Destructable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Destructable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Destructable::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Destructable::name() const {
  // @@protoc_insertion_point(field_get:pb.Destructable.Name)
  return *name_;
}
inline void Destructable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Destructable.Name)
}
inline void Destructable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Destructable.Name)
}
inline void Destructable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Destructable.Name)
}
inline ::std::string* Destructable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Destructable.Name)
  return name_;
}
inline ::std::string* Destructable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Destructable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Destructable.Name)
}

// optional string ArtObjectName = 2;
inline bool Destructable::has_artobjectname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Destructable::set_has_artobjectname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Destructable::clear_has_artobjectname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Destructable::clear_artobjectname() {
  if (artobjectname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artobjectname_->clear();
  }
  clear_has_artobjectname();
}
inline const ::std::string& Destructable::artobjectname() const {
  // @@protoc_insertion_point(field_get:pb.Destructable.ArtObjectName)
  return *artobjectname_;
}
inline void Destructable::set_artobjectname(const ::std::string& value) {
  set_has_artobjectname();
  if (artobjectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artobjectname_ = new ::std::string;
  }
  artobjectname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Destructable.ArtObjectName)
}
inline void Destructable::set_artobjectname(const char* value) {
  set_has_artobjectname();
  if (artobjectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artobjectname_ = new ::std::string;
  }
  artobjectname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Destructable.ArtObjectName)
}
inline void Destructable::set_artobjectname(const char* value, size_t size) {
  set_has_artobjectname();
  if (artobjectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artobjectname_ = new ::std::string;
  }
  artobjectname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Destructable.ArtObjectName)
}
inline ::std::string* Destructable::mutable_artobjectname() {
  set_has_artobjectname();
  if (artobjectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artobjectname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Destructable.ArtObjectName)
  return artobjectname_;
}
inline ::std::string* Destructable::release_artobjectname() {
  clear_has_artobjectname();
  if (artobjectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = artobjectname_;
    artobjectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Destructable::set_allocated_artobjectname(::std::string* artobjectname) {
  if (artobjectname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete artobjectname_;
  }
  if (artobjectname) {
    set_has_artobjectname();
    artobjectname_ = artobjectname;
  } else {
    clear_has_artobjectname();
    artobjectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Destructable.ArtObjectName)
}

// optional .pb.PbVector3_Int ArtObjectPosition = 3;
inline bool Destructable::has_artobjectposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Destructable::set_has_artobjectposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Destructable::clear_has_artobjectposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Destructable::clear_artobjectposition() {
  if (artobjectposition_ != NULL) artobjectposition_->::pb::PbVector3_Int::Clear();
  clear_has_artobjectposition();
}
inline const ::pb::PbVector3_Int& Destructable::artobjectposition() const {
  // @@protoc_insertion_point(field_get:pb.Destructable.ArtObjectPosition)
  return artobjectposition_ != NULL ? *artobjectposition_ : *default_instance_->artobjectposition_;
}
inline ::pb::PbVector3_Int* Destructable::mutable_artobjectposition() {
  set_has_artobjectposition();
  if (artobjectposition_ == NULL) artobjectposition_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.Destructable.ArtObjectPosition)
  return artobjectposition_;
}
inline ::pb::PbVector3_Int* Destructable::release_artobjectposition() {
  clear_has_artobjectposition();
  ::pb::PbVector3_Int* temp = artobjectposition_;
  artobjectposition_ = NULL;
  return temp;
}
inline void Destructable::set_allocated_artobjectposition(::pb::PbVector3_Int* artobjectposition) {
  delete artobjectposition_;
  artobjectposition_ = artobjectposition;
  if (artobjectposition) {
    set_has_artobjectposition();
  } else {
    clear_has_artobjectposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Destructable.ArtObjectPosition)
}

// optional string DestructableEffectPath = 4;
inline bool Destructable::has_destructableeffectpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Destructable::set_has_destructableeffectpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Destructable::clear_has_destructableeffectpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Destructable::clear_destructableeffectpath() {
  if (destructableeffectpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destructableeffectpath_->clear();
  }
  clear_has_destructableeffectpath();
}
inline const ::std::string& Destructable::destructableeffectpath() const {
  // @@protoc_insertion_point(field_get:pb.Destructable.DestructableEffectPath)
  return *destructableeffectpath_;
}
inline void Destructable::set_destructableeffectpath(const ::std::string& value) {
  set_has_destructableeffectpath();
  if (destructableeffectpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destructableeffectpath_ = new ::std::string;
  }
  destructableeffectpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Destructable.DestructableEffectPath)
}
inline void Destructable::set_destructableeffectpath(const char* value) {
  set_has_destructableeffectpath();
  if (destructableeffectpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destructableeffectpath_ = new ::std::string;
  }
  destructableeffectpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Destructable.DestructableEffectPath)
}
inline void Destructable::set_destructableeffectpath(const char* value, size_t size) {
  set_has_destructableeffectpath();
  if (destructableeffectpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destructableeffectpath_ = new ::std::string;
  }
  destructableeffectpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Destructable.DestructableEffectPath)
}
inline ::std::string* Destructable::mutable_destructableeffectpath() {
  set_has_destructableeffectpath();
  if (destructableeffectpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destructableeffectpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Destructable.DestructableEffectPath)
  return destructableeffectpath_;
}
inline ::std::string* Destructable::release_destructableeffectpath() {
  clear_has_destructableeffectpath();
  if (destructableeffectpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = destructableeffectpath_;
    destructableeffectpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Destructable::set_allocated_destructableeffectpath(::std::string* destructableeffectpath) {
  if (destructableeffectpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete destructableeffectpath_;
  }
  if (destructableeffectpath) {
    set_has_destructableeffectpath();
    destructableeffectpath_ = destructableeffectpath;
  } else {
    clear_has_destructableeffectpath();
    destructableeffectpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Destructable.DestructableEffectPath)
}

// optional uint32 Tid = 5;
inline bool Destructable::has_tid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Destructable::set_has_tid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Destructable::clear_has_tid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Destructable::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 Destructable::tid() const {
  // @@protoc_insertion_point(field_get:pb.Destructable.Tid)
  return tid_;
}
inline void Destructable::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
  // @@protoc_insertion_point(field_set:pb.Destructable.Tid)
}

// optional .pb.PbRect_Int RectInfo = 6;
inline bool Destructable::has_rectinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Destructable::set_has_rectinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Destructable::clear_has_rectinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Destructable::clear_rectinfo() {
  if (rectinfo_ != NULL) rectinfo_->::pb::PbRect_Int::Clear();
  clear_has_rectinfo();
}
inline const ::pb::PbRect_Int& Destructable::rectinfo() const {
  // @@protoc_insertion_point(field_get:pb.Destructable.RectInfo)
  return rectinfo_ != NULL ? *rectinfo_ : *default_instance_->rectinfo_;
}
inline ::pb::PbRect_Int* Destructable::mutable_rectinfo() {
  set_has_rectinfo();
  if (rectinfo_ == NULL) rectinfo_ = new ::pb::PbRect_Int;
  // @@protoc_insertion_point(field_mutable:pb.Destructable.RectInfo)
  return rectinfo_;
}
inline ::pb::PbRect_Int* Destructable::release_rectinfo() {
  clear_has_rectinfo();
  ::pb::PbRect_Int* temp = rectinfo_;
  rectinfo_ = NULL;
  return temp;
}
inline void Destructable::set_allocated_rectinfo(::pb::PbRect_Int* rectinfo) {
  delete rectinfo_;
  rectinfo_ = rectinfo;
  if (rectinfo) {
    set_has_rectinfo();
  } else {
    clear_has_rectinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Destructable.RectInfo)
}

// -------------------------------------------------------------------

// Camera3

// required string Name = 1;
inline bool Camera3::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Camera3::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Camera3::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Camera3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Camera3::name() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.Name)
  return *name_;
}
inline void Camera3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Camera3.Name)
}
inline void Camera3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Camera3.Name)
}
inline void Camera3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Camera3.Name)
}
inline ::std::string* Camera3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Camera3.Name)
  return name_;
}
inline ::std::string* Camera3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Camera3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Camera3.Name)
}

// required float Fov = 2;
inline bool Camera3::has_fov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Camera3::set_has_fov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Camera3::clear_has_fov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Camera3::clear_fov() {
  fov_ = 0;
  clear_has_fov();
}
inline float Camera3::fov() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.Fov)
  return fov_;
}
inline void Camera3::set_fov(float value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:pb.Camera3.Fov)
}

// required .pb.PbVector3_Int Position = 3;
inline bool Camera3::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Camera3::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Camera3::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Camera3::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& Camera3::position() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* Camera3::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.Camera3.Position)
  return position_;
}
inline ::pb::PbVector3_Int* Camera3::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Camera3::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Camera3.Position)
}

// required .pb.PbVector3_Int Direction = 4;
inline bool Camera3::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Camera3::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Camera3::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Camera3::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector3_Int::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector3_Int& Camera3::direction() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector3_Int* Camera3::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.Camera3.Direction)
  return direction_;
}
inline ::pb::PbVector3_Int* Camera3::release_direction() {
  clear_has_direction();
  ::pb::PbVector3_Int* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void Camera3::set_allocated_direction(::pb::PbVector3_Int* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Camera3.Direction)
}

// required string FollowTargetName = 5;
inline bool Camera3::has_followtargetname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Camera3::set_has_followtargetname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Camera3::clear_has_followtargetname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Camera3::clear_followtargetname() {
  if (followtargetname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    followtargetname_->clear();
  }
  clear_has_followtargetname();
}
inline const ::std::string& Camera3::followtargetname() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.FollowTargetName)
  return *followtargetname_;
}
inline void Camera3::set_followtargetname(const ::std::string& value) {
  set_has_followtargetname();
  if (followtargetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    followtargetname_ = new ::std::string;
  }
  followtargetname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Camera3.FollowTargetName)
}
inline void Camera3::set_followtargetname(const char* value) {
  set_has_followtargetname();
  if (followtargetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    followtargetname_ = new ::std::string;
  }
  followtargetname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Camera3.FollowTargetName)
}
inline void Camera3::set_followtargetname(const char* value, size_t size) {
  set_has_followtargetname();
  if (followtargetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    followtargetname_ = new ::std::string;
  }
  followtargetname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Camera3.FollowTargetName)
}
inline ::std::string* Camera3::mutable_followtargetname() {
  set_has_followtargetname();
  if (followtargetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    followtargetname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Camera3.FollowTargetName)
  return followtargetname_;
}
inline ::std::string* Camera3::release_followtargetname() {
  clear_has_followtargetname();
  if (followtargetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = followtargetname_;
    followtargetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Camera3::set_allocated_followtargetname(::std::string* followtargetname) {
  if (followtargetname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete followtargetname_;
  }
  if (followtargetname) {
    set_has_followtargetname();
    followtargetname_ = followtargetname;
  } else {
    clear_has_followtargetname();
    followtargetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Camera3.FollowTargetName)
}

// optional .pb.ESceneElementType ElementType = 6;
inline bool Camera3::has_elementtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Camera3::set_has_elementtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Camera3::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Camera3::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType Camera3::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void Camera3::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.Camera3.ElementType)
}

// optional .pb.PbQuaternion LocalRotation = 7;
inline bool Camera3::has_localrotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Camera3::set_has_localrotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Camera3::clear_has_localrotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Camera3::clear_localrotation() {
  if (localrotation_ != NULL) localrotation_->::pb::PbQuaternion::Clear();
  clear_has_localrotation();
}
inline const ::pb::PbQuaternion& Camera3::localrotation() const {
  // @@protoc_insertion_point(field_get:pb.Camera3.LocalRotation)
  return localrotation_ != NULL ? *localrotation_ : *default_instance_->localrotation_;
}
inline ::pb::PbQuaternion* Camera3::mutable_localrotation() {
  set_has_localrotation();
  if (localrotation_ == NULL) localrotation_ = new ::pb::PbQuaternion;
  // @@protoc_insertion_point(field_mutable:pb.Camera3.LocalRotation)
  return localrotation_;
}
inline ::pb::PbQuaternion* Camera3::release_localrotation() {
  clear_has_localrotation();
  ::pb::PbQuaternion* temp = localrotation_;
  localrotation_ = NULL;
  return temp;
}
inline void Camera3::set_allocated_localrotation(::pb::PbQuaternion* localrotation) {
  delete localrotation_;
  localrotation_ = localrotation;
  if (localrotation) {
    set_has_localrotation();
  } else {
    clear_has_localrotation();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Camera3.LocalRotation)
}

// -------------------------------------------------------------------

// CustomArea3

// required .pb.ESceneElementType ElementType = 1;
inline bool CustomArea3::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomArea3::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomArea3::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomArea3::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType CustomArea3::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea3.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void CustomArea3::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.CustomArea3.ElementType)
}

// required string Name = 2;
inline bool CustomArea3::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomArea3::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomArea3::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomArea3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CustomArea3::name() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea3.Name)
  return *name_;
}
inline void CustomArea3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CustomArea3.Name)
}
inline void CustomArea3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CustomArea3.Name)
}
inline void CustomArea3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CustomArea3.Name)
}
inline ::std::string* CustomArea3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CustomArea3.Name)
  return name_;
}
inline ::std::string* CustomArea3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CustomArea3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CustomArea3.Name)
}

// repeated .pb.PbVector3_Int PointArr = 3;
inline int CustomArea3::pointarr_size() const {
  return pointarr_.size();
}
inline void CustomArea3::clear_pointarr() {
  pointarr_.Clear();
}
inline const ::pb::PbVector3_Int& CustomArea3::pointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.CustomArea3.PointArr)
  return pointarr_.Get(index);
}
inline ::pb::PbVector3_Int* CustomArea3::mutable_pointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.CustomArea3.PointArr)
  return pointarr_.Mutable(index);
}
inline ::pb::PbVector3_Int* CustomArea3::add_pointarr() {
  // @@protoc_insertion_point(field_add:pb.CustomArea3.PointArr)
  return pointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >&
CustomArea3::pointarr() const {
  // @@protoc_insertion_point(field_list:pb.CustomArea3.PointArr)
  return pointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >*
CustomArea3::mutable_pointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.CustomArea3.PointArr)
  return &pointarr_;
}

// required bool Visible = 4;
inline bool CustomArea3::has_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CustomArea3::set_has_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CustomArea3::clear_has_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CustomArea3::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CustomArea3::visible() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea3.Visible)
  return visible_;
}
inline void CustomArea3::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.CustomArea3.Visible)
}

// optional int32 Index = 5;
inline bool CustomArea3::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CustomArea3::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CustomArea3::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CustomArea3::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CustomArea3::index() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea3.Index)
  return index_;
}
inline void CustomArea3::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.CustomArea3.Index)
}

// -------------------------------------------------------------------

// BlockLineFastFilter

// optional int32 StripWidth = 1;
inline bool BlockLineFastFilter::has_stripwidth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockLineFastFilter::set_has_stripwidth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockLineFastFilter::clear_has_stripwidth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockLineFastFilter::clear_stripwidth() {
  stripwidth_ = 0;
  clear_has_stripwidth();
}
inline ::google::protobuf::int32 BlockLineFastFilter::stripwidth() const {
  // @@protoc_insertion_point(field_get:pb.BlockLineFastFilter.StripWidth)
  return stripwidth_;
}
inline void BlockLineFastFilter::set_stripwidth(::google::protobuf::int32 value) {
  set_has_stripwidth();
  stripwidth_ = value;
  // @@protoc_insertion_point(field_set:pb.BlockLineFastFilter.StripWidth)
}

// repeated .pb.StripInfo ColStrips = 2;
inline int BlockLineFastFilter::colstrips_size() const {
  return colstrips_.size();
}
inline void BlockLineFastFilter::clear_colstrips() {
  colstrips_.Clear();
}
inline const ::pb::StripInfo& BlockLineFastFilter::colstrips(int index) const {
  // @@protoc_insertion_point(field_get:pb.BlockLineFastFilter.ColStrips)
  return colstrips_.Get(index);
}
inline ::pb::StripInfo* BlockLineFastFilter::mutable_colstrips(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BlockLineFastFilter.ColStrips)
  return colstrips_.Mutable(index);
}
inline ::pb::StripInfo* BlockLineFastFilter::add_colstrips() {
  // @@protoc_insertion_point(field_add:pb.BlockLineFastFilter.ColStrips)
  return colstrips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >&
BlockLineFastFilter::colstrips() const {
  // @@protoc_insertion_point(field_list:pb.BlockLineFastFilter.ColStrips)
  return colstrips_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >*
BlockLineFastFilter::mutable_colstrips() {
  // @@protoc_insertion_point(field_mutable_list:pb.BlockLineFastFilter.ColStrips)
  return &colstrips_;
}

// repeated .pb.StripInfo RowStrips = 3;
inline int BlockLineFastFilter::rowstrips_size() const {
  return rowstrips_.size();
}
inline void BlockLineFastFilter::clear_rowstrips() {
  rowstrips_.Clear();
}
inline const ::pb::StripInfo& BlockLineFastFilter::rowstrips(int index) const {
  // @@protoc_insertion_point(field_get:pb.BlockLineFastFilter.RowStrips)
  return rowstrips_.Get(index);
}
inline ::pb::StripInfo* BlockLineFastFilter::mutable_rowstrips(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BlockLineFastFilter.RowStrips)
  return rowstrips_.Mutable(index);
}
inline ::pb::StripInfo* BlockLineFastFilter::add_rowstrips() {
  // @@protoc_insertion_point(field_add:pb.BlockLineFastFilter.RowStrips)
  return rowstrips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >&
BlockLineFastFilter::rowstrips() const {
  // @@protoc_insertion_point(field_list:pb.BlockLineFastFilter.RowStrips)
  return rowstrips_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StripInfo >*
BlockLineFastFilter::mutable_rowstrips() {
  // @@protoc_insertion_point(field_mutable_list:pb.BlockLineFastFilter.RowStrips)
  return &rowstrips_;
}

// -------------------------------------------------------------------

// TDSpawnMapping

// optional int32 PlatIndex = 1;
inline bool TDSpawnMapping::has_platindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDSpawnMapping::set_has_platindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TDSpawnMapping::clear_has_platindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TDSpawnMapping::clear_platindex() {
  platindex_ = 0;
  clear_has_platindex();
}
inline ::google::protobuf::int32 TDSpawnMapping::platindex() const {
  // @@protoc_insertion_point(field_get:pb.TDSpawnMapping.PlatIndex)
  return platindex_;
}
inline void TDSpawnMapping::set_platindex(::google::protobuf::int32 value) {
  set_has_platindex();
  platindex_ = value;
  // @@protoc_insertion_point(field_set:pb.TDSpawnMapping.PlatIndex)
}

// optional int32 MeleeIndex = 2;
inline bool TDSpawnMapping::has_meleeindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDSpawnMapping::set_has_meleeindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TDSpawnMapping::clear_has_meleeindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TDSpawnMapping::clear_meleeindex() {
  meleeindex_ = 0;
  clear_has_meleeindex();
}
inline ::google::protobuf::int32 TDSpawnMapping::meleeindex() const {
  // @@protoc_insertion_point(field_get:pb.TDSpawnMapping.MeleeIndex)
  return meleeindex_;
}
inline void TDSpawnMapping::set_meleeindex(::google::protobuf::int32 value) {
  set_has_meleeindex();
  meleeindex_ = value;
  // @@protoc_insertion_point(field_set:pb.TDSpawnMapping.MeleeIndex)
}

// optional int32 PlatWidth = 3;
inline bool TDSpawnMapping::has_platwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDSpawnMapping::set_has_platwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TDSpawnMapping::clear_has_platwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TDSpawnMapping::clear_platwidth() {
  platwidth_ = 0;
  clear_has_platwidth();
}
inline ::google::protobuf::int32 TDSpawnMapping::platwidth() const {
  // @@protoc_insertion_point(field_get:pb.TDSpawnMapping.PlatWidth)
  return platwidth_;
}
inline void TDSpawnMapping::set_platwidth(::google::protobuf::int32 value) {
  set_has_platwidth();
  platwidth_ = value;
  // @@protoc_insertion_point(field_set:pb.TDSpawnMapping.PlatWidth)
}

// -------------------------------------------------------------------

// StripInfo

// optional int32 Index = 1;
inline bool StripInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StripInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StripInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StripInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 StripInfo::index() const {
  // @@protoc_insertion_point(field_get:pb.StripInfo.Index)
  return index_;
}
inline void StripInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.StripInfo.Index)
}

// repeated int32 BlockLineArr = 2;
inline int StripInfo::blocklinearr_size() const {
  return blocklinearr_.size();
}
inline void StripInfo::clear_blocklinearr() {
  blocklinearr_.Clear();
}
inline ::google::protobuf::int32 StripInfo::blocklinearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.StripInfo.BlockLineArr)
  return blocklinearr_.Get(index);
}
inline void StripInfo::set_blocklinearr(int index, ::google::protobuf::int32 value) {
  blocklinearr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.StripInfo.BlockLineArr)
}
inline void StripInfo::add_blocklinearr(::google::protobuf::int32 value) {
  blocklinearr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.StripInfo.BlockLineArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
StripInfo::blocklinearr() const {
  // @@protoc_insertion_point(field_list:pb.StripInfo.BlockLineArr)
  return blocklinearr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
StripInfo::mutable_blocklinearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.StripInfo.BlockLineArr)
  return &blocklinearr_;
}

// -------------------------------------------------------------------

// AnimAsset3

// required string Name = 1;
inline bool AnimAsset3::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimAsset3::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimAsset3::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimAsset3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AnimAsset3::name() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.Name)
  return *name_;
}
inline void AnimAsset3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset3.Name)
}
inline void AnimAsset3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset3.Name)
}
inline void AnimAsset3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset3.Name)
}
inline ::std::string* AnimAsset3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset3.Name)
  return name_;
}
inline ::std::string* AnimAsset3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset3.Name)
}

// required .pb.PbVector3_Int Position = 2;
inline bool AnimAsset3::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimAsset3::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimAsset3::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimAsset3::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& AnimAsset3::position() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* AnimAsset3::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset3.Position)
  return position_;
}
inline ::pb::PbVector3_Int* AnimAsset3::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void AnimAsset3::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset3.Position)
}

// required .pb.PbVector3_Int Direction = 3;
inline bool AnimAsset3::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimAsset3::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimAsset3::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimAsset3::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector3_Int::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector3_Int& AnimAsset3::direction() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector3_Int* AnimAsset3::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset3.Direction)
  return direction_;
}
inline ::pb::PbVector3_Int* AnimAsset3::release_direction() {
  clear_has_direction();
  ::pb::PbVector3_Int* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void AnimAsset3::set_allocated_direction(::pb::PbVector3_Int* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset3.Direction)
}

// required .pb.PbVector3_Int Scale = 4;
inline bool AnimAsset3::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimAsset3::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimAsset3::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimAsset3::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector3_Int::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector3_Int& AnimAsset3::scale() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector3_Int* AnimAsset3::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset3.Scale)
  return scale_;
}
inline ::pb::PbVector3_Int* AnimAsset3::release_scale() {
  clear_has_scale();
  ::pb::PbVector3_Int* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void AnimAsset3::set_allocated_scale(::pb::PbVector3_Int* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset3.Scale)
}

// required string AssetPath = 5;
inline bool AnimAsset3::has_assetpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnimAsset3::set_has_assetpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnimAsset3::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnimAsset3::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& AnimAsset3::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.AssetPath)
  return *assetpath_;
}
inline void AnimAsset3::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset3.AssetPath)
}
inline void AnimAsset3::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset3.AssetPath)
}
inline void AnimAsset3::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset3.AssetPath)
}
inline ::std::string* AnimAsset3::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset3.AssetPath)
  return assetpath_;
}
inline ::std::string* AnimAsset3::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset3::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset3.AssetPath)
}

// optional string DefaultAnim = 6;
inline bool AnimAsset3::has_defaultanim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnimAsset3::set_has_defaultanim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnimAsset3::clear_has_defaultanim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnimAsset3::clear_defaultanim() {
  if (defaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_->clear();
  }
  clear_has_defaultanim();
}
inline const ::std::string& AnimAsset3::defaultanim() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.DefaultAnim)
  return *defaultanim_;
}
inline void AnimAsset3::set_defaultanim(const ::std::string& value) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset3.DefaultAnim)
}
inline void AnimAsset3::set_defaultanim(const char* value) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset3.DefaultAnim)
}
inline void AnimAsset3::set_defaultanim(const char* value, size_t size) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset3.DefaultAnim)
}
inline ::std::string* AnimAsset3::mutable_defaultanim() {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset3.DefaultAnim)
  return defaultanim_;
}
inline ::std::string* AnimAsset3::release_defaultanim() {
  clear_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = defaultanim_;
    defaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset3::set_allocated_defaultanim(::std::string* defaultanim) {
  if (defaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete defaultanim_;
  }
  if (defaultanim) {
    set_has_defaultanim();
    defaultanim_ = defaultanim;
  } else {
    clear_has_defaultanim();
    defaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset3.DefaultAnim)
}

// required bool Visible = 7;
inline bool AnimAsset3::has_visible() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnimAsset3::set_has_visible() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnimAsset3::clear_has_visible() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnimAsset3::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool AnimAsset3::visible() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset3.Visible)
  return visible_;
}
inline void AnimAsset3::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimAsset3.Visible)
}

// -------------------------------------------------------------------

// StaticAsset3

// required string Name = 1;
inline bool StaticAsset3::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StaticAsset3::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StaticAsset3::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StaticAsset3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StaticAsset3::name() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset3.Name)
  return *name_;
}
inline void StaticAsset3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.StaticAsset3.Name)
}
inline void StaticAsset3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StaticAsset3.Name)
}
inline void StaticAsset3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StaticAsset3.Name)
}
inline ::std::string* StaticAsset3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset3.Name)
  return name_;
}
inline ::std::string* StaticAsset3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StaticAsset3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset3.Name)
}

// required .pb.PbVector3_Int Position = 2;
inline bool StaticAsset3::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StaticAsset3::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StaticAsset3::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StaticAsset3::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& StaticAsset3::position() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset3.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* StaticAsset3::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset3.Position)
  return position_;
}
inline ::pb::PbVector3_Int* StaticAsset3::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void StaticAsset3::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset3.Position)
}

// required .pb.PbVector3_Int Direction = 3;
inline bool StaticAsset3::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StaticAsset3::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StaticAsset3::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StaticAsset3::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector3_Int::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector3_Int& StaticAsset3::direction() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset3.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector3_Int* StaticAsset3::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset3.Direction)
  return direction_;
}
inline ::pb::PbVector3_Int* StaticAsset3::release_direction() {
  clear_has_direction();
  ::pb::PbVector3_Int* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void StaticAsset3::set_allocated_direction(::pb::PbVector3_Int* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset3.Direction)
}

// required .pb.PbVector3_Int Scale = 4;
inline bool StaticAsset3::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StaticAsset3::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StaticAsset3::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StaticAsset3::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector3_Int::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector3_Int& StaticAsset3::scale() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset3.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector3_Int* StaticAsset3::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset3.Scale)
  return scale_;
}
inline ::pb::PbVector3_Int* StaticAsset3::release_scale() {
  clear_has_scale();
  ::pb::PbVector3_Int* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void StaticAsset3::set_allocated_scale(::pb::PbVector3_Int* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset3.Scale)
}

// required string AssetPath = 5;
inline bool StaticAsset3::has_assetpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StaticAsset3::set_has_assetpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StaticAsset3::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StaticAsset3::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& StaticAsset3::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset3.AssetPath)
  return *assetpath_;
}
inline void StaticAsset3::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.StaticAsset3.AssetPath)
}
inline void StaticAsset3::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StaticAsset3.AssetPath)
}
inline void StaticAsset3::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StaticAsset3.AssetPath)
}
inline ::std::string* StaticAsset3::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset3.AssetPath)
  return assetpath_;
}
inline ::std::string* StaticAsset3::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StaticAsset3::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset3.AssetPath)
}

// required bool Visible = 6;
inline bool StaticAsset3::has_visible() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StaticAsset3::set_has_visible() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StaticAsset3::clear_has_visible() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StaticAsset3::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool StaticAsset3::visible() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset3.Visible)
  return visible_;
}
inline void StaticAsset3::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.StaticAsset3.Visible)
}

// -------------------------------------------------------------------

// EffectAsset3

// required string Name = 1;
inline bool EffectAsset3::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectAsset3::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectAsset3::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectAsset3::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EffectAsset3::name() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset3.Name)
  return *name_;
}
inline void EffectAsset3::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectAsset3.Name)
}
inline void EffectAsset3::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectAsset3.Name)
}
inline void EffectAsset3::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectAsset3.Name)
}
inline ::std::string* EffectAsset3::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset3.Name)
  return name_;
}
inline ::std::string* EffectAsset3::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectAsset3::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset3.Name)
}

// required .pb.PbVector3_Int Position = 2;
inline bool EffectAsset3::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectAsset3::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectAsset3::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectAsset3::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& EffectAsset3::position() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset3.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* EffectAsset3::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset3.Position)
  return position_;
}
inline ::pb::PbVector3_Int* EffectAsset3::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void EffectAsset3::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset3.Position)
}

// required string AssetPath = 3;
inline bool EffectAsset3::has_assetpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectAsset3::set_has_assetpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EffectAsset3::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EffectAsset3::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& EffectAsset3::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset3.AssetPath)
  return *assetpath_;
}
inline void EffectAsset3::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectAsset3.AssetPath)
}
inline void EffectAsset3::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectAsset3.AssetPath)
}
inline void EffectAsset3::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectAsset3.AssetPath)
}
inline ::std::string* EffectAsset3::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset3.AssetPath)
  return assetpath_;
}
inline ::std::string* EffectAsset3::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectAsset3::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset3.AssetPath)
}

// required bool Visible = 4;
inline bool EffectAsset3::has_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EffectAsset3::set_has_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EffectAsset3::clear_has_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EffectAsset3::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool EffectAsset3::visible() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset3.Visible)
  return visible_;
}
inline void EffectAsset3::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectAsset3.Visible)
}

// optional .pb.PbVector3_Int Direction = 5;
inline bool EffectAsset3::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EffectAsset3::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EffectAsset3::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EffectAsset3::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector3_Int::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector3_Int& EffectAsset3::direction() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset3.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector3_Int* EffectAsset3::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset3.Direction)
  return direction_;
}
inline ::pb::PbVector3_Int* EffectAsset3::release_direction() {
  clear_has_direction();
  ::pb::PbVector3_Int* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void EffectAsset3::set_allocated_direction(::pb::PbVector3_Int* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset3.Direction)
}

// optional .pb.PbVector3_Int Scale = 6;
inline bool EffectAsset3::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EffectAsset3::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EffectAsset3::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EffectAsset3::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector3_Int::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector3_Int& EffectAsset3::scale() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset3.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector3_Int* EffectAsset3::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset3.Scale)
  return scale_;
}
inline ::pb::PbVector3_Int* EffectAsset3::release_scale() {
  clear_has_scale();
  ::pb::PbVector3_Int* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void EffectAsset3::set_allocated_scale(::pb::PbVector3_Int* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset3.Scale)
}

// -------------------------------------------------------------------

// LeapTrackPoint

// optional .pb.PbVector3_Int Position = 1;
inline bool LeapTrackPoint::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeapTrackPoint::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeapTrackPoint::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeapTrackPoint::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& LeapTrackPoint::position() const {
  // @@protoc_insertion_point(field_get:pb.LeapTrackPoint.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* LeapTrackPoint::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.LeapTrackPoint.Position)
  return position_;
}
inline ::pb::PbVector3_Int* LeapTrackPoint::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void LeapTrackPoint::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.LeapTrackPoint.Position)
}

// optional float ToNextTrackPointTime = 2;
inline bool LeapTrackPoint::has_tonexttrackpointtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeapTrackPoint::set_has_tonexttrackpointtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeapTrackPoint::clear_has_tonexttrackpointtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeapTrackPoint::clear_tonexttrackpointtime() {
  tonexttrackpointtime_ = 0;
  clear_has_tonexttrackpointtime();
}
inline float LeapTrackPoint::tonexttrackpointtime() const {
  // @@protoc_insertion_point(field_get:pb.LeapTrackPoint.ToNextTrackPointTime)
  return tonexttrackpointtime_;
}
inline void LeapTrackPoint::set_tonexttrackpointtime(float value) {
  set_has_tonexttrackpointtime();
  tonexttrackpointtime_ = value;
  // @@protoc_insertion_point(field_set:pb.LeapTrackPoint.ToNextTrackPointTime)
}

// -------------------------------------------------------------------

// LeapTrack

// optional string Name = 1;
inline bool LeapTrack::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeapTrack::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeapTrack::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeapTrack::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LeapTrack::name() const {
  // @@protoc_insertion_point(field_get:pb.LeapTrack.Name)
  return *name_;
}
inline void LeapTrack::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.LeapTrack.Name)
}
inline void LeapTrack::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.LeapTrack.Name)
}
inline void LeapTrack::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.LeapTrack.Name)
}
inline ::std::string* LeapTrack::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.LeapTrack.Name)
  return name_;
}
inline ::std::string* LeapTrack::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LeapTrack::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.LeapTrack.Name)
}

// repeated .pb.LeapTrackPoint PointArr = 2;
inline int LeapTrack::pointarr_size() const {
  return pointarr_.size();
}
inline void LeapTrack::clear_pointarr() {
  pointarr_.Clear();
}
inline const ::pb::LeapTrackPoint& LeapTrack::pointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.LeapTrack.PointArr)
  return pointarr_.Get(index);
}
inline ::pb::LeapTrackPoint* LeapTrack::mutable_pointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.LeapTrack.PointArr)
  return pointarr_.Mutable(index);
}
inline ::pb::LeapTrackPoint* LeapTrack::add_pointarr() {
  // @@protoc_insertion_point(field_add:pb.LeapTrack.PointArr)
  return pointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::LeapTrackPoint >&
LeapTrack::pointarr() const {
  // @@protoc_insertion_point(field_list:pb.LeapTrack.PointArr)
  return pointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::LeapTrackPoint >*
LeapTrack::mutable_pointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.LeapTrack.PointArr)
  return &pointarr_;
}

// optional float DropTime = 3;
inline bool LeapTrack::has_droptime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeapTrack::set_has_droptime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeapTrack::clear_has_droptime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeapTrack::clear_droptime() {
  droptime_ = 0;
  clear_has_droptime();
}
inline float LeapTrack::droptime() const {
  // @@protoc_insertion_point(field_get:pb.LeapTrack.DropTime)
  return droptime_;
}
inline void LeapTrack::set_droptime(float value) {
  set_has_droptime();
  droptime_ = value;
  // @@protoc_insertion_point(field_set:pb.LeapTrack.DropTime)
}

// -------------------------------------------------------------------

// CurveTrack

// optional string Name = 1;
inline bool CurveTrack::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurveTrack::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurveTrack::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurveTrack::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CurveTrack::name() const {
  // @@protoc_insertion_point(field_get:pb.CurveTrack.Name)
  return *name_;
}
inline void CurveTrack::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CurveTrack.Name)
}
inline void CurveTrack::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CurveTrack.Name)
}
inline void CurveTrack::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CurveTrack.Name)
}
inline ::std::string* CurveTrack::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CurveTrack.Name)
  return name_;
}
inline ::std::string* CurveTrack::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurveTrack::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CurveTrack.Name)
}

// repeated .pb.PbVector3_Int PointPositionArr = 2;
inline int CurveTrack::pointpositionarr_size() const {
  return pointpositionarr_.size();
}
inline void CurveTrack::clear_pointpositionarr() {
  pointpositionarr_.Clear();
}
inline const ::pb::PbVector3_Int& CurveTrack::pointpositionarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.CurveTrack.PointPositionArr)
  return pointpositionarr_.Get(index);
}
inline ::pb::PbVector3_Int* CurveTrack::mutable_pointpositionarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.CurveTrack.PointPositionArr)
  return pointpositionarr_.Mutable(index);
}
inline ::pb::PbVector3_Int* CurveTrack::add_pointpositionarr() {
  // @@protoc_insertion_point(field_add:pb.CurveTrack.PointPositionArr)
  return pointpositionarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >&
CurveTrack::pointpositionarr() const {
  // @@protoc_insertion_point(field_list:pb.CurveTrack.PointPositionArr)
  return pointpositionarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector3_Int >*
CurveTrack::mutable_pointpositionarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.CurveTrack.PointPositionArr)
  return &pointpositionarr_;
}

// -------------------------------------------------------------------

// PathPoint

// optional int32 PointEvent = 1;
inline bool PathPoint::has_pointevent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathPoint::set_has_pointevent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathPoint::clear_has_pointevent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathPoint::clear_pointevent() {
  pointevent_ = 0;
  clear_has_pointevent();
}
inline ::google::protobuf::int32 PathPoint::pointevent() const {
  // @@protoc_insertion_point(field_get:pb.PathPoint.PointEvent)
  return pointevent_;
}
inline void PathPoint::set_pointevent(::google::protobuf::int32 value) {
  set_has_pointevent();
  pointevent_ = value;
  // @@protoc_insertion_point(field_set:pb.PathPoint.PointEvent)
}

// optional .pb.PbVector3_Int Point = 2;
inline bool PathPoint::has_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathPoint::set_has_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathPoint::clear_has_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathPoint::clear_point() {
  if (point_ != NULL) point_->::pb::PbVector3_Int::Clear();
  clear_has_point();
}
inline const ::pb::PbVector3_Int& PathPoint::point() const {
  // @@protoc_insertion_point(field_get:pb.PathPoint.Point)
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::pb::PbVector3_Int* PathPoint::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.PathPoint.Point)
  return point_;
}
inline ::pb::PbVector3_Int* PathPoint::release_point() {
  clear_has_point();
  ::pb::PbVector3_Int* temp = point_;
  point_ = NULL;
  return temp;
}
inline void PathPoint::set_allocated_point(::pb::PbVector3_Int* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PathPoint.Point)
}

// -------------------------------------------------------------------

// PathTrack

// optional string Name = 1;
inline bool PathTrack::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathTrack::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathTrack::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathTrack::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PathTrack::name() const {
  // @@protoc_insertion_point(field_get:pb.PathTrack.Name)
  return *name_;
}
inline void PathTrack::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PathTrack.Name)
}
inline void PathTrack::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PathTrack.Name)
}
inline void PathTrack::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PathTrack.Name)
}
inline ::std::string* PathTrack::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PathTrack.Name)
  return name_;
}
inline ::std::string* PathTrack::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PathTrack::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PathTrack.Name)
}

// optional int32 Index = 2;
inline bool PathTrack::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathTrack::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathTrack::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathTrack::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 PathTrack::index() const {
  // @@protoc_insertion_point(field_get:pb.PathTrack.Index)
  return index_;
}
inline void PathTrack::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.PathTrack.Index)
}

// repeated .pb.PathPoint PointArr = 3;
inline int PathTrack::pointarr_size() const {
  return pointarr_.size();
}
inline void PathTrack::clear_pointarr() {
  pointarr_.Clear();
}
inline const ::pb::PathPoint& PathTrack::pointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.PathTrack.PointArr)
  return pointarr_.Get(index);
}
inline ::pb::PathPoint* PathTrack::mutable_pointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PathTrack.PointArr)
  return pointarr_.Mutable(index);
}
inline ::pb::PathPoint* PathTrack::add_pointarr() {
  // @@protoc_insertion_point(field_add:pb.PathTrack.PointArr)
  return pointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PathPoint >&
PathTrack::pointarr() const {
  // @@protoc_insertion_point(field_list:pb.PathTrack.PointArr)
  return pointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PathPoint >*
PathTrack::mutable_pointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.PathTrack.PointArr)
  return &pointarr_;
}

// -------------------------------------------------------------------

// CameraTrackPoint

// optional .pb.PbVector3_Int Position = 1;
inline bool CameraTrackPoint::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraTrackPoint::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraTrackPoint::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraTrackPoint::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& CameraTrackPoint::position() const {
  // @@protoc_insertion_point(field_get:pb.CameraTrackPoint.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* CameraTrackPoint::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.CameraTrackPoint.Position)
  return position_;
}
inline ::pb::PbVector3_Int* CameraTrackPoint::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CameraTrackPoint::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraTrackPoint.Position)
}

// optional .pb.PbQuaternion Rotation = 2;
inline bool CameraTrackPoint::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraTrackPoint::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraTrackPoint::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraTrackPoint::clear_rotation() {
  if (rotation_ != NULL) rotation_->::pb::PbQuaternion::Clear();
  clear_has_rotation();
}
inline const ::pb::PbQuaternion& CameraTrackPoint::rotation() const {
  // @@protoc_insertion_point(field_get:pb.CameraTrackPoint.Rotation)
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::pb::PbQuaternion* CameraTrackPoint::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::pb::PbQuaternion;
  // @@protoc_insertion_point(field_mutable:pb.CameraTrackPoint.Rotation)
  return rotation_;
}
inline ::pb::PbQuaternion* CameraTrackPoint::release_rotation() {
  clear_has_rotation();
  ::pb::PbQuaternion* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void CameraTrackPoint::set_allocated_rotation(::pb::PbQuaternion* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraTrackPoint.Rotation)
}

// optional float StartTime = 3;
inline bool CameraTrackPoint::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraTrackPoint::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraTrackPoint::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraTrackPoint::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float CameraTrackPoint::starttime() const {
  // @@protoc_insertion_point(field_get:pb.CameraTrackPoint.StartTime)
  return starttime_;
}
inline void CameraTrackPoint::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pb.CameraTrackPoint.StartTime)
}

// -------------------------------------------------------------------

// CameraTrack

// optional string Name = 1;
inline bool CameraTrack::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraTrack::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraTrack::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraTrack::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CameraTrack::name() const {
  // @@protoc_insertion_point(field_get:pb.CameraTrack.Name)
  return *name_;
}
inline void CameraTrack::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CameraTrack.Name)
}
inline void CameraTrack::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CameraTrack.Name)
}
inline void CameraTrack::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CameraTrack.Name)
}
inline ::std::string* CameraTrack::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CameraTrack.Name)
  return name_;
}
inline ::std::string* CameraTrack::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CameraTrack::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraTrack.Name)
}

// optional string AnimResPath = 2;
inline bool CameraTrack::has_animrespath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraTrack::set_has_animrespath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraTrack::clear_has_animrespath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraTrack::clear_animrespath() {
  if (animrespath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animrespath_->clear();
  }
  clear_has_animrespath();
}
inline const ::std::string& CameraTrack::animrespath() const {
  // @@protoc_insertion_point(field_get:pb.CameraTrack.AnimResPath)
  return *animrespath_;
}
inline void CameraTrack::set_animrespath(const ::std::string& value) {
  set_has_animrespath();
  if (animrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animrespath_ = new ::std::string;
  }
  animrespath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CameraTrack.AnimResPath)
}
inline void CameraTrack::set_animrespath(const char* value) {
  set_has_animrespath();
  if (animrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animrespath_ = new ::std::string;
  }
  animrespath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CameraTrack.AnimResPath)
}
inline void CameraTrack::set_animrespath(const char* value, size_t size) {
  set_has_animrespath();
  if (animrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animrespath_ = new ::std::string;
  }
  animrespath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CameraTrack.AnimResPath)
}
inline ::std::string* CameraTrack::mutable_animrespath() {
  set_has_animrespath();
  if (animrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animrespath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CameraTrack.AnimResPath)
  return animrespath_;
}
inline ::std::string* CameraTrack::release_animrespath() {
  clear_has_animrespath();
  if (animrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = animrespath_;
    animrespath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CameraTrack::set_allocated_animrespath(::std::string* animrespath) {
  if (animrespath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete animrespath_;
  }
  if (animrespath) {
    set_has_animrespath();
    animrespath_ = animrespath;
  } else {
    clear_has_animrespath();
    animrespath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraTrack.AnimResPath)
}

// repeated .pb.CameraTrackPoint PointArr = 3;
inline int CameraTrack::pointarr_size() const {
  return pointarr_.size();
}
inline void CameraTrack::clear_pointarr() {
  pointarr_.Clear();
}
inline const ::pb::CameraTrackPoint& CameraTrack::pointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.CameraTrack.PointArr)
  return pointarr_.Get(index);
}
inline ::pb::CameraTrackPoint* CameraTrack::mutable_pointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.CameraTrack.PointArr)
  return pointarr_.Mutable(index);
}
inline ::pb::CameraTrackPoint* CameraTrack::add_pointarr() {
  // @@protoc_insertion_point(field_add:pb.CameraTrack.PointArr)
  return pointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraTrackPoint >&
CameraTrack::pointarr() const {
  // @@protoc_insertion_point(field_list:pb.CameraTrack.PointArr)
  return pointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CameraTrackPoint >*
CameraTrack::mutable_pointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.CameraTrack.PointArr)
  return &pointarr_;
}

// optional float Length = 4;
inline bool CameraTrack::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraTrack::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraTrack::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraTrack::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float CameraTrack::length() const {
  // @@protoc_insertion_point(field_get:pb.CameraTrack.Length)
  return length_;
}
inline void CameraTrack::set_length(float value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:pb.CameraTrack.Length)
}

// -------------------------------------------------------------------

// FieldConf3

// required string FieldConfName = 1;
inline bool FieldConf3::has_fieldconfname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldConf3::set_has_fieldconfname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldConf3::clear_has_fieldconfname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldConf3::clear_fieldconfname() {
  if (fieldconfname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fieldconfname_->clear();
  }
  clear_has_fieldconfname();
}
inline const ::std::string& FieldConf3::fieldconfname() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.FieldConfName)
  return *fieldconfname_;
}
inline void FieldConf3::set_fieldconfname(const ::std::string& value) {
  set_has_fieldconfname();
  if (fieldconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fieldconfname_ = new ::std::string;
  }
  fieldconfname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.FieldConf3.FieldConfName)
}
inline void FieldConf3::set_fieldconfname(const char* value) {
  set_has_fieldconfname();
  if (fieldconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fieldconfname_ = new ::std::string;
  }
  fieldconfname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.FieldConf3.FieldConfName)
}
inline void FieldConf3::set_fieldconfname(const char* value, size_t size) {
  set_has_fieldconfname();
  if (fieldconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fieldconfname_ = new ::std::string;
  }
  fieldconfname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.FieldConf3.FieldConfName)
}
inline ::std::string* FieldConf3::mutable_fieldconfname() {
  set_has_fieldconfname();
  if (fieldconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fieldconfname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.FieldConfName)
  return fieldconfname_;
}
inline ::std::string* FieldConf3::release_fieldconfname() {
  clear_has_fieldconfname();
  if (fieldconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fieldconfname_;
    fieldconfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FieldConf3::set_allocated_fieldconfname(::std::string* fieldconfname) {
  if (fieldconfname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fieldconfname_;
  }
  if (fieldconfname) {
    set_has_fieldconfname();
    fieldconfname_ = fieldconfname;
  } else {
    clear_has_fieldconfname();
    fieldconfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FieldConf3.FieldConfName)
}

// repeated .pb.PointElement3 PointElementArr = 2;
inline int FieldConf3::pointelementarr_size() const {
  return pointelementarr_.size();
}
inline void FieldConf3::clear_pointelementarr() {
  pointelementarr_.Clear();
}
inline const ::pb::PointElement3& FieldConf3::pointelementarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.PointElementArr)
  return pointelementarr_.Get(index);
}
inline ::pb::PointElement3* FieldConf3::mutable_pointelementarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.PointElementArr)
  return pointelementarr_.Mutable(index);
}
inline ::pb::PointElement3* FieldConf3::add_pointelementarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.PointElementArr)
  return pointelementarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement3 >&
FieldConf3::pointelementarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.PointElementArr)
  return pointelementarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement3 >*
FieldConf3::mutable_pointelementarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.PointElementArr)
  return &pointelementarr_;
}

// repeated .pb.RectArea3 RectAreaArr = 3;
inline int FieldConf3::rectareaarr_size() const {
  return rectareaarr_.size();
}
inline void FieldConf3::clear_rectareaarr() {
  rectareaarr_.Clear();
}
inline const ::pb::RectArea3& FieldConf3::rectareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.RectAreaArr)
  return rectareaarr_.Get(index);
}
inline ::pb::RectArea3* FieldConf3::mutable_rectareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.RectAreaArr)
  return rectareaarr_.Mutable(index);
}
inline ::pb::RectArea3* FieldConf3::add_rectareaarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.RectAreaArr)
  return rectareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea3 >&
FieldConf3::rectareaarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.RectAreaArr)
  return rectareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea3 >*
FieldConf3::mutable_rectareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.RectAreaArr)
  return &rectareaarr_;
}

// repeated .pb.Camera3 CameraInfoArr = 4;
inline int FieldConf3::camerainfoarr_size() const {
  return camerainfoarr_.size();
}
inline void FieldConf3::clear_camerainfoarr() {
  camerainfoarr_.Clear();
}
inline const ::pb::Camera3& FieldConf3::camerainfoarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.CameraInfoArr)
  return camerainfoarr_.Get(index);
}
inline ::pb::Camera3* FieldConf3::mutable_camerainfoarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.CameraInfoArr)
  return camerainfoarr_.Mutable(index);
}
inline ::pb::Camera3* FieldConf3::add_camerainfoarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.CameraInfoArr)
  return camerainfoarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Camera3 >&
FieldConf3::camerainfoarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.CameraInfoArr)
  return camerainfoarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Camera3 >*
FieldConf3::mutable_camerainfoarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.CameraInfoArr)
  return &camerainfoarr_;
}

// repeated .pb.CustomArea3 CustomAreaArr = 5;
inline int FieldConf3::customareaarr_size() const {
  return customareaarr_.size();
}
inline void FieldConf3::clear_customareaarr() {
  customareaarr_.Clear();
}
inline const ::pb::CustomArea3& FieldConf3::customareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.CustomAreaArr)
  return customareaarr_.Get(index);
}
inline ::pb::CustomArea3* FieldConf3::mutable_customareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.CustomAreaArr)
  return customareaarr_.Mutable(index);
}
inline ::pb::CustomArea3* FieldConf3::add_customareaarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.CustomAreaArr)
  return customareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea3 >&
FieldConf3::customareaarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.CustomAreaArr)
  return customareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea3 >*
FieldConf3::mutable_customareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.CustomAreaArr)
  return &customareaarr_;
}

// repeated .pb.AnimAsset3 AnimAssetArr = 6;
inline int FieldConf3::animassetarr_size() const {
  return animassetarr_.size();
}
inline void FieldConf3::clear_animassetarr() {
  animassetarr_.Clear();
}
inline const ::pb::AnimAsset3& FieldConf3::animassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.AnimAssetArr)
  return animassetarr_.Get(index);
}
inline ::pb::AnimAsset3* FieldConf3::mutable_animassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.AnimAssetArr)
  return animassetarr_.Mutable(index);
}
inline ::pb::AnimAsset3* FieldConf3::add_animassetarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.AnimAssetArr)
  return animassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset3 >&
FieldConf3::animassetarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.AnimAssetArr)
  return animassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset3 >*
FieldConf3::mutable_animassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.AnimAssetArr)
  return &animassetarr_;
}

// repeated .pb.StaticAsset3 StaticAssetArr = 7;
inline int FieldConf3::staticassetarr_size() const {
  return staticassetarr_.size();
}
inline void FieldConf3::clear_staticassetarr() {
  staticassetarr_.Clear();
}
inline const ::pb::StaticAsset3& FieldConf3::staticassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.StaticAssetArr)
  return staticassetarr_.Get(index);
}
inline ::pb::StaticAsset3* FieldConf3::mutable_staticassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.StaticAssetArr)
  return staticassetarr_.Mutable(index);
}
inline ::pb::StaticAsset3* FieldConf3::add_staticassetarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.StaticAssetArr)
  return staticassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset3 >&
FieldConf3::staticassetarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.StaticAssetArr)
  return staticassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset3 >*
FieldConf3::mutable_staticassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.StaticAssetArr)
  return &staticassetarr_;
}

// repeated .pb.EffectAsset3 EffectAssetArr = 8;
inline int FieldConf3::effectassetarr_size() const {
  return effectassetarr_.size();
}
inline void FieldConf3::clear_effectassetarr() {
  effectassetarr_.Clear();
}
inline const ::pb::EffectAsset3& FieldConf3::effectassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.EffectAssetArr)
  return effectassetarr_.Get(index);
}
inline ::pb::EffectAsset3* FieldConf3::mutable_effectassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.EffectAssetArr)
  return effectassetarr_.Mutable(index);
}
inline ::pb::EffectAsset3* FieldConf3::add_effectassetarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.EffectAssetArr)
  return effectassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset3 >&
FieldConf3::effectassetarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.EffectAssetArr)
  return effectassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset3 >*
FieldConf3::mutable_effectassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.EffectAssetArr)
  return &effectassetarr_;
}

// optional .pb.PbVector3_Int RootPosition = 9;
inline bool FieldConf3::has_rootposition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FieldConf3::set_has_rootposition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FieldConf3::clear_has_rootposition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FieldConf3::clear_rootposition() {
  if (rootposition_ != NULL) rootposition_->::pb::PbVector3_Int::Clear();
  clear_has_rootposition();
}
inline const ::pb::PbVector3_Int& FieldConf3::rootposition() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.RootPosition)
  return rootposition_ != NULL ? *rootposition_ : *default_instance_->rootposition_;
}
inline ::pb::PbVector3_Int* FieldConf3::mutable_rootposition() {
  set_has_rootposition();
  if (rootposition_ == NULL) rootposition_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.RootPosition)
  return rootposition_;
}
inline ::pb::PbVector3_Int* FieldConf3::release_rootposition() {
  clear_has_rootposition();
  ::pb::PbVector3_Int* temp = rootposition_;
  rootposition_ = NULL;
  return temp;
}
inline void FieldConf3::set_allocated_rootposition(::pb::PbVector3_Int* rootposition) {
  delete rootposition_;
  rootposition_ = rootposition;
  if (rootposition) {
    set_has_rootposition();
  } else {
    clear_has_rootposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FieldConf3.RootPosition)
}

// optional .pb.PbVector3_Int RootDirection = 10;
inline bool FieldConf3::has_rootdirection() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FieldConf3::set_has_rootdirection() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FieldConf3::clear_has_rootdirection() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FieldConf3::clear_rootdirection() {
  if (rootdirection_ != NULL) rootdirection_->::pb::PbVector3_Int::Clear();
  clear_has_rootdirection();
}
inline const ::pb::PbVector3_Int& FieldConf3::rootdirection() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.RootDirection)
  return rootdirection_ != NULL ? *rootdirection_ : *default_instance_->rootdirection_;
}
inline ::pb::PbVector3_Int* FieldConf3::mutable_rootdirection() {
  set_has_rootdirection();
  if (rootdirection_ == NULL) rootdirection_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.RootDirection)
  return rootdirection_;
}
inline ::pb::PbVector3_Int* FieldConf3::release_rootdirection() {
  clear_has_rootdirection();
  ::pb::PbVector3_Int* temp = rootdirection_;
  rootdirection_ = NULL;
  return temp;
}
inline void FieldConf3::set_allocated_rootdirection(::pb::PbVector3_Int* rootdirection) {
  delete rootdirection_;
  rootdirection_ = rootdirection;
  if (rootdirection) {
    set_has_rootdirection();
  } else {
    clear_has_rootdirection();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FieldConf3.RootDirection)
}

// optional int32 StandardlinePosX = 11;
inline bool FieldConf3::has_standardlineposx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FieldConf3::set_has_standardlineposx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FieldConf3::clear_has_standardlineposx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FieldConf3::clear_standardlineposx() {
  standardlineposx_ = 0;
  clear_has_standardlineposx();
}
inline ::google::protobuf::int32 FieldConf3::standardlineposx() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.StandardlinePosX)
  return standardlineposx_;
}
inline void FieldConf3::set_standardlineposx(::google::protobuf::int32 value) {
  set_has_standardlineposx();
  standardlineposx_ = value;
  // @@protoc_insertion_point(field_set:pb.FieldConf3.StandardlinePosX)
}

// optional .pb.PbVector2_Int LenAndWid = 12;
inline bool FieldConf3::has_lenandwid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FieldConf3::set_has_lenandwid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FieldConf3::clear_has_lenandwid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FieldConf3::clear_lenandwid() {
  if (lenandwid_ != NULL) lenandwid_->::pb::PbVector2_Int::Clear();
  clear_has_lenandwid();
}
inline const ::pb::PbVector2_Int& FieldConf3::lenandwid() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.LenAndWid)
  return lenandwid_ != NULL ? *lenandwid_ : *default_instance_->lenandwid_;
}
inline ::pb::PbVector2_Int* FieldConf3::mutable_lenandwid() {
  set_has_lenandwid();
  if (lenandwid_ == NULL) lenandwid_ = new ::pb::PbVector2_Int;
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.LenAndWid)
  return lenandwid_;
}
inline ::pb::PbVector2_Int* FieldConf3::release_lenandwid() {
  clear_has_lenandwid();
  ::pb::PbVector2_Int* temp = lenandwid_;
  lenandwid_ = NULL;
  return temp;
}
inline void FieldConf3::set_allocated_lenandwid(::pb::PbVector2_Int* lenandwid) {
  delete lenandwid_;
  lenandwid_ = lenandwid;
  if (lenandwid) {
    set_has_lenandwid();
  } else {
    clear_has_lenandwid();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FieldConf3.LenAndWid)
}

// repeated .pb.Destructable DestructableArr = 13;
inline int FieldConf3::destructablearr_size() const {
  return destructablearr_.size();
}
inline void FieldConf3::clear_destructablearr() {
  destructablearr_.Clear();
}
inline const ::pb::Destructable& FieldConf3::destructablearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.DestructableArr)
  return destructablearr_.Get(index);
}
inline ::pb::Destructable* FieldConf3::mutable_destructablearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.DestructableArr)
  return destructablearr_.Mutable(index);
}
inline ::pb::Destructable* FieldConf3::add_destructablearr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.DestructableArr)
  return destructablearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Destructable >&
FieldConf3::destructablearr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.DestructableArr)
  return destructablearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Destructable >*
FieldConf3::mutable_destructablearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.DestructableArr)
  return &destructablearr_;
}

// optional string CutSceneCameraTrackName = 14;
inline bool FieldConf3::has_cutscenecameratrackname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FieldConf3::set_has_cutscenecameratrackname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FieldConf3::clear_has_cutscenecameratrackname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FieldConf3::clear_cutscenecameratrackname() {
  if (cutscenecameratrackname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cutscenecameratrackname_->clear();
  }
  clear_has_cutscenecameratrackname();
}
inline const ::std::string& FieldConf3::cutscenecameratrackname() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.CutSceneCameraTrackName)
  return *cutscenecameratrackname_;
}
inline void FieldConf3::set_cutscenecameratrackname(const ::std::string& value) {
  set_has_cutscenecameratrackname();
  if (cutscenecameratrackname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cutscenecameratrackname_ = new ::std::string;
  }
  cutscenecameratrackname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.FieldConf3.CutSceneCameraTrackName)
}
inline void FieldConf3::set_cutscenecameratrackname(const char* value) {
  set_has_cutscenecameratrackname();
  if (cutscenecameratrackname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cutscenecameratrackname_ = new ::std::string;
  }
  cutscenecameratrackname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.FieldConf3.CutSceneCameraTrackName)
}
inline void FieldConf3::set_cutscenecameratrackname(const char* value, size_t size) {
  set_has_cutscenecameratrackname();
  if (cutscenecameratrackname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cutscenecameratrackname_ = new ::std::string;
  }
  cutscenecameratrackname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.FieldConf3.CutSceneCameraTrackName)
}
inline ::std::string* FieldConf3::mutable_cutscenecameratrackname() {
  set_has_cutscenecameratrackname();
  if (cutscenecameratrackname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cutscenecameratrackname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.CutSceneCameraTrackName)
  return cutscenecameratrackname_;
}
inline ::std::string* FieldConf3::release_cutscenecameratrackname() {
  clear_has_cutscenecameratrackname();
  if (cutscenecameratrackname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cutscenecameratrackname_;
    cutscenecameratrackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FieldConf3::set_allocated_cutscenecameratrackname(::std::string* cutscenecameratrackname) {
  if (cutscenecameratrackname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cutscenecameratrackname_;
  }
  if (cutscenecameratrackname) {
    set_has_cutscenecameratrackname();
    cutscenecameratrackname_ = cutscenecameratrackname;
  } else {
    clear_has_cutscenecameratrackname();
    cutscenecameratrackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FieldConf3.CutSceneCameraTrackName)
}

// repeated int32 PositionlinePosX = 15;
inline int FieldConf3::positionlineposx_size() const {
  return positionlineposx_.size();
}
inline void FieldConf3::clear_positionlineposx() {
  positionlineposx_.Clear();
}
inline ::google::protobuf::int32 FieldConf3::positionlineposx(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.PositionlinePosX)
  return positionlineposx_.Get(index);
}
inline void FieldConf3::set_positionlineposx(int index, ::google::protobuf::int32 value) {
  positionlineposx_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.FieldConf3.PositionlinePosX)
}
inline void FieldConf3::add_positionlineposx(::google::protobuf::int32 value) {
  positionlineposx_.Add(value);
  // @@protoc_insertion_point(field_add:pb.FieldConf3.PositionlinePosX)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FieldConf3::positionlineposx() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.PositionlinePosX)
  return positionlineposx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FieldConf3::mutable_positionlineposx() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.PositionlinePosX)
  return &positionlineposx_;
}

// optional bool NeedSyncTimeline = 16;
inline bool FieldConf3::has_needsynctimeline() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FieldConf3::set_has_needsynctimeline() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FieldConf3::clear_has_needsynctimeline() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FieldConf3::clear_needsynctimeline() {
  needsynctimeline_ = false;
  clear_has_needsynctimeline();
}
inline bool FieldConf3::needsynctimeline() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.NeedSyncTimeline)
  return needsynctimeline_;
}
inline void FieldConf3::set_needsynctimeline(bool value) {
  set_has_needsynctimeline();
  needsynctimeline_ = value;
  // @@protoc_insertion_point(field_set:pb.FieldConf3.NeedSyncTimeline)
}

// repeated .pb.PathTrack PathTrackArr = 17;
inline int FieldConf3::pathtrackarr_size() const {
  return pathtrackarr_.size();
}
inline void FieldConf3::clear_pathtrackarr() {
  pathtrackarr_.Clear();
}
inline const ::pb::PathTrack& FieldConf3::pathtrackarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.PathTrackArr)
  return pathtrackarr_.Get(index);
}
inline ::pb::PathTrack* FieldConf3::mutable_pathtrackarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.PathTrackArr)
  return pathtrackarr_.Mutable(index);
}
inline ::pb::PathTrack* FieldConf3::add_pathtrackarr() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.PathTrackArr)
  return pathtrackarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PathTrack >&
FieldConf3::pathtrackarr() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.PathTrackArr)
  return pathtrackarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PathTrack >*
FieldConf3::mutable_pathtrackarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.PathTrackArr)
  return &pathtrackarr_;
}

// optional .pb.BlockLineFastFilter Filter = 18;
inline bool FieldConf3::has_filter() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FieldConf3::set_has_filter() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FieldConf3::clear_has_filter() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FieldConf3::clear_filter() {
  if (filter_ != NULL) filter_->::pb::BlockLineFastFilter::Clear();
  clear_has_filter();
}
inline const ::pb::BlockLineFastFilter& FieldConf3::filter() const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.Filter)
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::pb::BlockLineFastFilter* FieldConf3::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::pb::BlockLineFastFilter;
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.Filter)
  return filter_;
}
inline ::pb::BlockLineFastFilter* FieldConf3::release_filter() {
  clear_has_filter();
  ::pb::BlockLineFastFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void FieldConf3::set_allocated_filter(::pb::BlockLineFastFilter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FieldConf3.Filter)
}

// repeated .pb.TDSpawnMapping SpawnMapping = 19;
inline int FieldConf3::spawnmapping_size() const {
  return spawnmapping_.size();
}
inline void FieldConf3::clear_spawnmapping() {
  spawnmapping_.Clear();
}
inline const ::pb::TDSpawnMapping& FieldConf3::spawnmapping(int index) const {
  // @@protoc_insertion_point(field_get:pb.FieldConf3.SpawnMapping)
  return spawnmapping_.Get(index);
}
inline ::pb::TDSpawnMapping* FieldConf3::mutable_spawnmapping(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FieldConf3.SpawnMapping)
  return spawnmapping_.Mutable(index);
}
inline ::pb::TDSpawnMapping* FieldConf3::add_spawnmapping() {
  // @@protoc_insertion_point(field_add:pb.FieldConf3.SpawnMapping)
  return spawnmapping_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TDSpawnMapping >&
FieldConf3::spawnmapping() const {
  // @@protoc_insertion_point(field_list:pb.FieldConf3.SpawnMapping)
  return spawnmapping_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TDSpawnMapping >*
FieldConf3::mutable_spawnmapping() {
  // @@protoc_insertion_point(field_mutable_list:pb.FieldConf3.SpawnMapping)
  return &spawnmapping_;
}

// -------------------------------------------------------------------

// SceneConf3d

// required int32 Id = 1;
inline bool SceneConf3d::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneConf3d::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneConf3d::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneConf3d::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SceneConf3d::id() const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.Id)
  return id_;
}
inline void SceneConf3d::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.SceneConf3d.Id)
}

// required string ConfName = 2;
inline bool SceneConf3d::has_confname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneConf3d::set_has_confname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneConf3d::clear_has_confname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneConf3d::clear_confname() {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& SceneConf3d::confname() const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.ConfName)
  return *confname_;
}
inline void SceneConf3d::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConf3d.ConfName)
}
inline void SceneConf3d::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConf3d.ConfName)
}
inline void SceneConf3d::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConf3d.ConfName)
}
inline ::std::string* SceneConf3d::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.ConfName)
  return confname_;
}
inline ::std::string* SceneConf3d::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConf3d::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConf3d.ConfName)
}

// required string ArtScenePath = 3;
inline bool SceneConf3d::has_artscenepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneConf3d::set_has_artscenepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneConf3d::clear_has_artscenepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneConf3d::clear_artscenepath() {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_->clear();
  }
  clear_has_artscenepath();
}
inline const ::std::string& SceneConf3d::artscenepath() const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.ArtScenePath)
  return *artscenepath_;
}
inline void SceneConf3d::set_artscenepath(const ::std::string& value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConf3d.ArtScenePath)
}
inline void SceneConf3d::set_artscenepath(const char* value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConf3d.ArtScenePath)
}
inline void SceneConf3d::set_artscenepath(const char* value, size_t size) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConf3d.ArtScenePath)
}
inline ::std::string* SceneConf3d::mutable_artscenepath() {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.ArtScenePath)
  return artscenepath_;
}
inline ::std::string* SceneConf3d::release_artscenepath() {
  clear_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = artscenepath_;
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConf3d::set_allocated_artscenepath(::std::string* artscenepath) {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete artscenepath_;
  }
  if (artscenepath) {
    set_has_artscenepath();
    artscenepath_ = artscenepath;
  } else {
    clear_has_artscenepath();
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConf3d.ArtScenePath)
}

// repeated .pb.FieldConf3 FieldConfArr = 4;
inline int SceneConf3d::fieldconfarr_size() const {
  return fieldconfarr_.size();
}
inline void SceneConf3d::clear_fieldconfarr() {
  fieldconfarr_.Clear();
}
inline const ::pb::FieldConf3& SceneConf3d::fieldconfarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.FieldConfArr)
  return fieldconfarr_.Get(index);
}
inline ::pb::FieldConf3* SceneConf3d::mutable_fieldconfarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.FieldConfArr)
  return fieldconfarr_.Mutable(index);
}
inline ::pb::FieldConf3* SceneConf3d::add_fieldconfarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConf3d.FieldConfArr)
  return fieldconfarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::FieldConf3 >&
SceneConf3d::fieldconfarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConf3d.FieldConfArr)
  return fieldconfarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::FieldConf3 >*
SceneConf3d::mutable_fieldconfarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConf3d.FieldConfArr)
  return &fieldconfarr_;
}

// repeated .pb.LeapTrack LeapTrackArr = 5;
inline int SceneConf3d::leaptrackarr_size() const {
  return leaptrackarr_.size();
}
inline void SceneConf3d::clear_leaptrackarr() {
  leaptrackarr_.Clear();
}
inline const ::pb::LeapTrack& SceneConf3d::leaptrackarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.LeapTrackArr)
  return leaptrackarr_.Get(index);
}
inline ::pb::LeapTrack* SceneConf3d::mutable_leaptrackarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.LeapTrackArr)
  return leaptrackarr_.Mutable(index);
}
inline ::pb::LeapTrack* SceneConf3d::add_leaptrackarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConf3d.LeapTrackArr)
  return leaptrackarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::LeapTrack >&
SceneConf3d::leaptrackarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConf3d.LeapTrackArr)
  return leaptrackarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::LeapTrack >*
SceneConf3d::mutable_leaptrackarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConf3d.LeapTrackArr)
  return &leaptrackarr_;
}

// optional string GridDataPath = 6;
inline bool SceneConf3d::has_griddatapath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SceneConf3d::set_has_griddatapath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SceneConf3d::clear_has_griddatapath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SceneConf3d::clear_griddatapath() {
  if (griddatapath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    griddatapath_->clear();
  }
  clear_has_griddatapath();
}
inline const ::std::string& SceneConf3d::griddatapath() const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.GridDataPath)
  return *griddatapath_;
}
inline void SceneConf3d::set_griddatapath(const ::std::string& value) {
  set_has_griddatapath();
  if (griddatapath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    griddatapath_ = new ::std::string;
  }
  griddatapath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConf3d.GridDataPath)
}
inline void SceneConf3d::set_griddatapath(const char* value) {
  set_has_griddatapath();
  if (griddatapath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    griddatapath_ = new ::std::string;
  }
  griddatapath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConf3d.GridDataPath)
}
inline void SceneConf3d::set_griddatapath(const char* value, size_t size) {
  set_has_griddatapath();
  if (griddatapath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    griddatapath_ = new ::std::string;
  }
  griddatapath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConf3d.GridDataPath)
}
inline ::std::string* SceneConf3d::mutable_griddatapath() {
  set_has_griddatapath();
  if (griddatapath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    griddatapath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.GridDataPath)
  return griddatapath_;
}
inline ::std::string* SceneConf3d::release_griddatapath() {
  clear_has_griddatapath();
  if (griddatapath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = griddatapath_;
    griddatapath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConf3d::set_allocated_griddatapath(::std::string* griddatapath) {
  if (griddatapath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete griddatapath_;
  }
  if (griddatapath) {
    set_has_griddatapath();
    griddatapath_ = griddatapath;
  } else {
    clear_has_griddatapath();
    griddatapath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConf3d.GridDataPath)
}

// repeated .pb.CameraTrack CameraTrackArr = 7;
inline int SceneConf3d::cameratrackarr_size() const {
  return cameratrackarr_.size();
}
inline void SceneConf3d::clear_cameratrackarr() {
  cameratrackarr_.Clear();
}
inline const ::pb::CameraTrack& SceneConf3d::cameratrackarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.CameraTrackArr)
  return cameratrackarr_.Get(index);
}
inline ::pb::CameraTrack* SceneConf3d::mutable_cameratrackarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.CameraTrackArr)
  return cameratrackarr_.Mutable(index);
}
inline ::pb::CameraTrack* SceneConf3d::add_cameratrackarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConf3d.CameraTrackArr)
  return cameratrackarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraTrack >&
SceneConf3d::cameratrackarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConf3d.CameraTrackArr)
  return cameratrackarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CameraTrack >*
SceneConf3d::mutable_cameratrackarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConf3d.CameraTrackArr)
  return &cameratrackarr_;
}

// repeated .pb.CurveTrack CurveTrackArr = 8;
inline int SceneConf3d::curvetrackarr_size() const {
  return curvetrackarr_.size();
}
inline void SceneConf3d::clear_curvetrackarr() {
  curvetrackarr_.Clear();
}
inline const ::pb::CurveTrack& SceneConf3d::curvetrackarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.CurveTrackArr)
  return curvetrackarr_.Get(index);
}
inline ::pb::CurveTrack* SceneConf3d::mutable_curvetrackarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.CurveTrackArr)
  return curvetrackarr_.Mutable(index);
}
inline ::pb::CurveTrack* SceneConf3d::add_curvetrackarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConf3d.CurveTrackArr)
  return curvetrackarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CurveTrack >&
SceneConf3d::curvetrackarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConf3d.CurveTrackArr)
  return curvetrackarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CurveTrack >*
SceneConf3d::mutable_curvetrackarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConf3d.CurveTrackArr)
  return &curvetrackarr_;
}

// optional .pb.Camera3 SceneCamera = 9;
inline bool SceneConf3d::has_scenecamera() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SceneConf3d::set_has_scenecamera() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SceneConf3d::clear_has_scenecamera() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SceneConf3d::clear_scenecamera() {
  if (scenecamera_ != NULL) scenecamera_->::pb::Camera3::Clear();
  clear_has_scenecamera();
}
inline const ::pb::Camera3& SceneConf3d::scenecamera() const {
  // @@protoc_insertion_point(field_get:pb.SceneConf3d.SceneCamera)
  return scenecamera_ != NULL ? *scenecamera_ : *default_instance_->scenecamera_;
}
inline ::pb::Camera3* SceneConf3d::mutable_scenecamera() {
  set_has_scenecamera();
  if (scenecamera_ == NULL) scenecamera_ = new ::pb::Camera3;
  // @@protoc_insertion_point(field_mutable:pb.SceneConf3d.SceneCamera)
  return scenecamera_;
}
inline ::pb::Camera3* SceneConf3d::release_scenecamera() {
  clear_has_scenecamera();
  ::pb::Camera3* temp = scenecamera_;
  scenecamera_ = NULL;
  return temp;
}
inline void SceneConf3d::set_allocated_scenecamera(::pb::Camera3* scenecamera) {
  delete scenecamera_;
  scenecamera_ = scenecamera;
  if (scenecamera) {
    set_has_scenecamera();
  } else {
    clear_has_scenecamera();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConf3d.SceneCamera)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fSceneConf3d_2eproto__INCLUDED
