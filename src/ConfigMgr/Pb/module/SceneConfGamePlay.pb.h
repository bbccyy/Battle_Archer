// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/SceneConfGamePlay.proto

#ifndef PROTOBUF_module_2fSceneConfGamePlay_2eproto__INCLUDED
#define PROTOBUF_module_2fSceneConfGamePlay_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
#include "module/SceneConf2d.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fSceneConfGamePlay_2eproto();
void protobuf_AssignDesc_module_2fSceneConfGamePlay_2eproto();
void protobuf_ShutdownFile_module_2fSceneConfGamePlay_2eproto();

class SpawnArea;
class EventArea;
class SceneConfGamePlay;

// ===================================================================

/*FOR2LUA
<Record>
	<name>SpawnArea</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfGamePlay.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SpawnArea : public ::google::protobuf::Message {
 public:
  SpawnArea();
  virtual ~SpawnArea();

  SpawnArea(const SpawnArea& from);

  inline SpawnArea& operator=(const SpawnArea& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpawnArea& default_instance();

  void Swap(SpawnArea* other);

  // implements Message ----------------------------------------------

  SpawnArea* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpawnArea& from);
  void MergeFrom(const SpawnArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SpawnArea</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.PbVector2 ChunkIndexArr = 2;
  inline int chunkindexarr_size() const;
  inline void clear_chunkindexarr();
  static const int kChunkIndexArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SpawnArea</name>
  	<Function>
  		<name>chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>chunkindexarr_size</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& chunkindexarr(int index) const;
  inline ::pb::PbVector2* mutable_chunkindexarr(int index);
  inline ::pb::PbVector2* add_chunkindexarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >&
      chunkindexarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >*
      mutable_chunkindexarr();

  // @@protoc_insertion_point(class_scope:pb.SpawnArea)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 > chunkindexarr_;
  friend void  protobuf_AddDesc_module_2fSceneConfGamePlay_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfGamePlay_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfGamePlay_2eproto();

  void InitAsDefaultInstance();
  static SpawnArea* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>EventArea</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfGamePlay.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class EventArea : public ::google::protobuf::Message {
 public:
  EventArea();
  virtual ~EventArea();

  EventArea(const EventArea& from);

  inline EventArea& operator=(const EventArea& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventArea& default_instance();

  void Swap(EventArea* other);

  // implements Message ----------------------------------------------

  EventArea* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventArea& from);
  void MergeFrom(const EventArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>EventArea</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pb.PbVector2 SpawnPoint = 2;
  inline bool has_spawnpoint() const;
  inline void clear_spawnpoint();
  static const int kSpawnPointFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>EventArea</name>
  	<Function>
  		<name>spawnpoint</name>
  		<replaceName>SpawnPoint</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_spawnpoint</name>
  		<replaceName>SpawnPoint</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_spawnpoint</name>
  		<replaceName>SpawnPoint</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_spawnpoint</name>
  		<replaceName>SpawnPoint</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& spawnpoint() const;
  inline ::pb::PbVector2* mutable_spawnpoint();
  inline ::pb::PbVector2* release_spawnpoint();
  inline void set_allocated_spawnpoint(::pb::PbVector2* spawnpoint);

  // repeated .pb.PbVector2 ChunkIndexArr = 3;
  inline int chunkindexarr_size() const;
  inline void clear_chunkindexarr();
  static const int kChunkIndexArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>EventArea</name>
  	<Function>
  		<name>chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>chunkindexarr_size</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& chunkindexarr(int index) const;
  inline ::pb::PbVector2* mutable_chunkindexarr(int index);
  inline ::pb::PbVector2* add_chunkindexarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >&
      chunkindexarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >*
      mutable_chunkindexarr();

  // @@protoc_insertion_point(class_scope:pb.EventArea)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_spawnpoint();
  inline void clear_has_spawnpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* spawnpoint_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 > chunkindexarr_;
  friend void  protobuf_AddDesc_module_2fSceneConfGamePlay_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfGamePlay_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfGamePlay_2eproto();

  void InitAsDefaultInstance();
  static EventArea* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SceneConfGamePlay</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfGamePlay.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SceneConfGamePlay : public ::google::protobuf::Message {
 public:
  SceneConfGamePlay();
  virtual ~SceneConfGamePlay();

  SceneConfGamePlay(const SceneConfGamePlay& from);

  inline SceneConfGamePlay& operator=(const SceneConfGamePlay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneConfGamePlay& default_instance();

  void Swap(SceneConfGamePlay* other);

  // implements Message ----------------------------------------------

  SceneConfGamePlay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneConfGamePlay& from);
  void MergeFrom(const SceneConfGamePlay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string ConfName = 2;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // required string ArtScenePath = 3;
  inline bool has_artscenepath() const;
  inline void clear_artscenepath();
  static const int kArtScenePathFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& artscenepath() const;
  inline void set_artscenepath(const ::std::string& value);
  inline void set_artscenepath(const char* value);
  inline void set_artscenepath(const char* value, size_t size);
  inline ::std::string* mutable_artscenepath();
  inline ::std::string* release_artscenepath();
  inline void set_allocated_artscenepath(::std::string* artscenepath);

  // optional .pb.PbRect CameraMoveArea = 4;
  inline bool has_cameramovearea() const;
  inline void clear_cameramovearea();
  static const int kCameraMoveAreaFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& cameramovearea() const;
  inline ::pb::PbRect* mutable_cameramovearea();
  inline ::pb::PbRect* release_cameramovearea();
  inline void set_allocated_cameramovearea(::pb::PbRect* cameramovearea);

  // repeated .pb.PointElement2 PointElementArr = 5;
  inline int pointelementarr_size() const;
  inline void clear_pointelementarr();
  static const int kPointElementArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointelementarr_size</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PointElement2& pointelementarr(int index) const;
  inline ::pb::PointElement2* mutable_pointelementarr(int index);
  inline ::pb::PointElement2* add_pointelementarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >&
      pointelementarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >*
      mutable_pointelementarr();

  // repeated .pb.FeatureEntrance FeatureEntranceArr = 6;
  inline int featureentrancearr_size() const;
  inline void clear_featureentrancearr();
  static const int kFeatureEntranceArrFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>featureentrancearr_size</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::FeatureEntrance& featureentrancearr(int index) const;
  inline ::pb::FeatureEntrance* mutable_featureentrancearr(int index);
  inline ::pb::FeatureEntrance* add_featureentrancearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >&
      featureentrancearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >*
      mutable_featureentrancearr();

  // repeated .pb.AssetGroup AssetGrpArr = 7;
  inline int assetgrparr_size() const;
  inline void clear_assetgrparr();
  static const int kAssetGrpArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>assetgrparr</name>
  		<replaceName>AssetGrpArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_assetgrparr</name>
  		<replaceName>AssetGrpArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_assetgrparr</name>
  		<replaceName>AssetGrpArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetgrparr</name>
  		<replaceName>AssetGrpArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>assetgrparr_size</name>
  		<replaceName>AssetGrpArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AssetGroup& assetgrparr(int index) const;
  inline ::pb::AssetGroup* mutable_assetgrparr(int index);
  inline ::pb::AssetGroup* add_assetgrparr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AssetGroup >&
      assetgrparr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AssetGroup >*
      mutable_assetgrparr();

  // repeated .pb.EffectAsset2 EffectAssetArr = 8;
  inline int effectassetarr_size() const;
  inline void clear_effectassetarr();
  static const int kEffectAssetArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectassetarr_size</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectAsset2& effectassetarr(int index) const;
  inline ::pb::EffectAsset2* mutable_effectassetarr(int index);
  inline ::pb::EffectAsset2* add_effectassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
      effectassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
      mutable_effectassetarr();

  // repeated .pb.AnimAsset2 AnimAssetArr = 9;
  inline int animassetarr_size() const;
  inline void clear_animassetarr();
  static const int kAnimAssetArrFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>animassetarr_size</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AnimAsset2& animassetarr(int index) const;
  inline ::pb::AnimAsset2* mutable_animassetarr(int index);
  inline ::pb::AnimAsset2* add_animassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
      animassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
      mutable_animassetarr();

  // repeated .pb.StaticAsset2 StaticAssetArr = 10;
  inline int staticassetarr_size() const;
  inline void clear_staticassetarr();
  static const int kStaticAssetArrFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>staticassetarr_size</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StaticAsset2& staticassetarr(int index) const;
  inline ::pb::StaticAsset2* mutable_staticassetarr(int index);
  inline ::pb::StaticAsset2* add_staticassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
      staticassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
      mutable_staticassetarr();

  // repeated .pb.PatrolPath2 PatrolPathArr = 11;
  inline int patrolpatharr_size() const;
  inline void clear_patrolpatharr();
  static const int kPatrolPathArrFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>patrolpatharr_size</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PatrolPath2& patrolpatharr(int index) const;
  inline ::pb::PatrolPath2* mutable_patrolpatharr(int index);
  inline ::pb::PatrolPath2* add_patrolpatharr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >&
      patrolpatharr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >*
      mutable_patrolpatharr();

  // repeated .pb.PatrolPathConf PatrolPathConfArr = 12;
  inline int patrolpathconfarr_size() const;
  inline void clear_patrolpathconfarr();
  static const int kPatrolPathConfArrFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>patrolpathconfarr</name>
  		<replaceName>PatrolPathConfArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_patrolpathconfarr</name>
  		<replaceName>PatrolPathConfArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_patrolpathconfarr</name>
  		<replaceName>PatrolPathConfArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patrolpathconfarr</name>
  		<replaceName>PatrolPathConfArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>patrolpathconfarr_size</name>
  		<replaceName>PatrolPathConfArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PatrolPathConf& patrolpathconfarr(int index) const;
  inline ::pb::PatrolPathConf* mutable_patrolpathconfarr(int index);
  inline ::pb::PatrolPathConf* add_patrolpathconfarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathConf >&
      patrolpathconfarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathConf >*
      mutable_patrolpathconfarr();

  // optional .pb.SpawnArea SpawnArea = 13;
  inline bool has_spawnarea() const;
  inline void clear_spawnarea();
  static const int kSpawnAreaFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>spawnarea</name>
  		<replaceName>SpawnArea</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_spawnarea</name>
  		<replaceName>SpawnArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_spawnarea</name>
  		<replaceName>SpawnArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_spawnarea</name>
  		<replaceName>SpawnArea</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SpawnArea& spawnarea() const;
  inline ::pb::SpawnArea* mutable_spawnarea();
  inline ::pb::SpawnArea* release_spawnarea();
  inline void set_allocated_spawnarea(::pb::SpawnArea* spawnarea);

  // repeated .pb.EventArea EventAreaArr = 14;
  inline int eventareaarr_size() const;
  inline void clear_eventareaarr();
  static const int kEventAreaArrFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>eventareaarr</name>
  		<replaceName>EventAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_eventareaarr</name>
  		<replaceName>EventAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_eventareaarr</name>
  		<replaceName>EventAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventareaarr</name>
  		<replaceName>EventAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>eventareaarr_size</name>
  		<replaceName>EventAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EventArea& eventareaarr(int index) const;
  inline ::pb::EventArea* mutable_eventareaarr(int index);
  inline ::pb::EventArea* add_eventareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EventArea >&
      eventareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EventArea >*
      mutable_eventareaarr();

  // optional .pb.SceneChunkInfo ChunkInfo = 15;
  inline bool has_chunkinfo() const;
  inline void clear_chunkinfo();
  static const int kChunkInfoFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SceneChunkInfo& chunkinfo() const;
  inline ::pb::SceneChunkInfo* mutable_chunkinfo();
  inline ::pb::SceneChunkInfo* release_chunkinfo();
  inline void set_allocated_chunkinfo(::pb::SceneChunkInfo* chunkinfo);

  // repeated .pb.RectArea2 RectAreaArr = 16;
  inline int rectareaarr_size() const;
  inline void clear_rectareaarr();
  static const int kRectAreaArrFieldNumber = 16;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rectareaarr_size</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::RectArea2& rectareaarr(int index) const;
  inline ::pb::RectArea2* mutable_rectareaarr(int index);
  inline ::pb::RectArea2* add_rectareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >&
      rectareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >*
      mutable_rectareaarr();

  // repeated .pb.CustomArea2 CustomAreaArr = 17;
  inline int customareaarr_size() const;
  inline void clear_customareaarr();
  static const int kCustomAreaArrFieldNumber = 17;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGamePlay</name>
  	<Function>
  		<name>customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>customareaarr_size</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CustomArea2& customareaarr(int index) const;
  inline ::pb::CustomArea2* mutable_customareaarr(int index);
  inline ::pb::CustomArea2* add_customareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >&
      customareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >*
      mutable_customareaarr();

  // @@protoc_insertion_point(class_scope:pb.SceneConfGamePlay)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_artscenepath();
  inline void clear_has_artscenepath();
  inline void set_has_cameramovearea();
  inline void clear_has_cameramovearea();
  inline void set_has_spawnarea();
  inline void clear_has_spawnarea();
  inline void set_has_chunkinfo();
  inline void clear_has_chunkinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* confname_;
  ::std::string* artscenepath_;
  ::pb::PbRect* cameramovearea_;
  ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 > pointelementarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance > featureentrancearr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AssetGroup > assetgrparr_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 > effectassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 > animassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 > staticassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 > patrolpatharr_;
  ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathConf > patrolpathconfarr_;
  ::pb::SpawnArea* spawnarea_;
  ::google::protobuf::RepeatedPtrField< ::pb::EventArea > eventareaarr_;
  ::pb::SceneChunkInfo* chunkinfo_;
  ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 > rectareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 > customareaarr_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fSceneConfGamePlay_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfGamePlay_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfGamePlay_2eproto();

  void InitAsDefaultInstance();
  static SceneConfGamePlay* default_instance_;
};
// ===================================================================


// ===================================================================

// SpawnArea

// optional string Name = 1;
inline bool SpawnArea::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpawnArea::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpawnArea::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpawnArea::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SpawnArea::name() const {
  // @@protoc_insertion_point(field_get:pb.SpawnArea.Name)
  return *name_;
}
inline void SpawnArea::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SpawnArea.Name)
}
inline void SpawnArea::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SpawnArea.Name)
}
inline void SpawnArea::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SpawnArea.Name)
}
inline ::std::string* SpawnArea::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SpawnArea.Name)
  return name_;
}
inline ::std::string* SpawnArea::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SpawnArea::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SpawnArea.Name)
}

// repeated .pb.PbVector2 ChunkIndexArr = 2;
inline int SpawnArea::chunkindexarr_size() const {
  return chunkindexarr_.size();
}
inline void SpawnArea::clear_chunkindexarr() {
  chunkindexarr_.Clear();
}
inline const ::pb::PbVector2& SpawnArea::chunkindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SpawnArea.ChunkIndexArr)
  return chunkindexarr_.Get(index);
}
inline ::pb::PbVector2* SpawnArea::mutable_chunkindexarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SpawnArea.ChunkIndexArr)
  return chunkindexarr_.Mutable(index);
}
inline ::pb::PbVector2* SpawnArea::add_chunkindexarr() {
  // @@protoc_insertion_point(field_add:pb.SpawnArea.ChunkIndexArr)
  return chunkindexarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >&
SpawnArea::chunkindexarr() const {
  // @@protoc_insertion_point(field_list:pb.SpawnArea.ChunkIndexArr)
  return chunkindexarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >*
SpawnArea::mutable_chunkindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SpawnArea.ChunkIndexArr)
  return &chunkindexarr_;
}

// -------------------------------------------------------------------

// EventArea

// optional string Name = 1;
inline bool EventArea::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventArea::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventArea::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventArea::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EventArea::name() const {
  // @@protoc_insertion_point(field_get:pb.EventArea.Name)
  return *name_;
}
inline void EventArea::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EventArea.Name)
}
inline void EventArea::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EventArea.Name)
}
inline void EventArea::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EventArea.Name)
}
inline ::std::string* EventArea::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EventArea.Name)
  return name_;
}
inline ::std::string* EventArea::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EventArea::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EventArea.Name)
}

// optional .pb.PbVector2 SpawnPoint = 2;
inline bool EventArea::has_spawnpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventArea::set_has_spawnpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventArea::clear_has_spawnpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventArea::clear_spawnpoint() {
  if (spawnpoint_ != NULL) spawnpoint_->::pb::PbVector2::Clear();
  clear_has_spawnpoint();
}
inline const ::pb::PbVector2& EventArea::spawnpoint() const {
  // @@protoc_insertion_point(field_get:pb.EventArea.SpawnPoint)
  return spawnpoint_ != NULL ? *spawnpoint_ : *default_instance_->spawnpoint_;
}
inline ::pb::PbVector2* EventArea::mutable_spawnpoint() {
  set_has_spawnpoint();
  if (spawnpoint_ == NULL) spawnpoint_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.EventArea.SpawnPoint)
  return spawnpoint_;
}
inline ::pb::PbVector2* EventArea::release_spawnpoint() {
  clear_has_spawnpoint();
  ::pb::PbVector2* temp = spawnpoint_;
  spawnpoint_ = NULL;
  return temp;
}
inline void EventArea::set_allocated_spawnpoint(::pb::PbVector2* spawnpoint) {
  delete spawnpoint_;
  spawnpoint_ = spawnpoint;
  if (spawnpoint) {
    set_has_spawnpoint();
  } else {
    clear_has_spawnpoint();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EventArea.SpawnPoint)
}

// repeated .pb.PbVector2 ChunkIndexArr = 3;
inline int EventArea::chunkindexarr_size() const {
  return chunkindexarr_.size();
}
inline void EventArea::clear_chunkindexarr() {
  chunkindexarr_.Clear();
}
inline const ::pb::PbVector2& EventArea::chunkindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.EventArea.ChunkIndexArr)
  return chunkindexarr_.Get(index);
}
inline ::pb::PbVector2* EventArea::mutable_chunkindexarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EventArea.ChunkIndexArr)
  return chunkindexarr_.Mutable(index);
}
inline ::pb::PbVector2* EventArea::add_chunkindexarr() {
  // @@protoc_insertion_point(field_add:pb.EventArea.ChunkIndexArr)
  return chunkindexarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >&
EventArea::chunkindexarr() const {
  // @@protoc_insertion_point(field_list:pb.EventArea.ChunkIndexArr)
  return chunkindexarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >*
EventArea::mutable_chunkindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.EventArea.ChunkIndexArr)
  return &chunkindexarr_;
}

// -------------------------------------------------------------------

// SceneConfGamePlay

// required int32 Id = 1;
inline bool SceneConfGamePlay::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneConfGamePlay::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneConfGamePlay::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneConfGamePlay::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SceneConfGamePlay::id() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.Id)
  return id_;
}
inline void SceneConfGamePlay::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.SceneConfGamePlay.Id)
}

// required string ConfName = 2;
inline bool SceneConfGamePlay::has_confname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneConfGamePlay::set_has_confname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneConfGamePlay::clear_has_confname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneConfGamePlay::clear_confname() {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& SceneConfGamePlay::confname() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.ConfName)
  return *confname_;
}
inline void SceneConfGamePlay::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConfGamePlay.ConfName)
}
inline void SceneConfGamePlay::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfGamePlay.ConfName)
}
inline void SceneConfGamePlay::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfGamePlay.ConfName)
}
inline ::std::string* SceneConfGamePlay::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.ConfName)
  return confname_;
}
inline ::std::string* SceneConfGamePlay::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConfGamePlay::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGamePlay.ConfName)
}

// required string ArtScenePath = 3;
inline bool SceneConfGamePlay::has_artscenepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneConfGamePlay::set_has_artscenepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneConfGamePlay::clear_has_artscenepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneConfGamePlay::clear_artscenepath() {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_->clear();
  }
  clear_has_artscenepath();
}
inline const ::std::string& SceneConfGamePlay::artscenepath() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.ArtScenePath)
  return *artscenepath_;
}
inline void SceneConfGamePlay::set_artscenepath(const ::std::string& value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConfGamePlay.ArtScenePath)
}
inline void SceneConfGamePlay::set_artscenepath(const char* value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfGamePlay.ArtScenePath)
}
inline void SceneConfGamePlay::set_artscenepath(const char* value, size_t size) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfGamePlay.ArtScenePath)
}
inline ::std::string* SceneConfGamePlay::mutable_artscenepath() {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.ArtScenePath)
  return artscenepath_;
}
inline ::std::string* SceneConfGamePlay::release_artscenepath() {
  clear_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = artscenepath_;
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConfGamePlay::set_allocated_artscenepath(::std::string* artscenepath) {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete artscenepath_;
  }
  if (artscenepath) {
    set_has_artscenepath();
    artscenepath_ = artscenepath;
  } else {
    clear_has_artscenepath();
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGamePlay.ArtScenePath)
}

// optional .pb.PbRect CameraMoveArea = 4;
inline bool SceneConfGamePlay::has_cameramovearea() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneConfGamePlay::set_has_cameramovearea() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneConfGamePlay::clear_has_cameramovearea() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneConfGamePlay::clear_cameramovearea() {
  if (cameramovearea_ != NULL) cameramovearea_->::pb::PbRect::Clear();
  clear_has_cameramovearea();
}
inline const ::pb::PbRect& SceneConfGamePlay::cameramovearea() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.CameraMoveArea)
  return cameramovearea_ != NULL ? *cameramovearea_ : *default_instance_->cameramovearea_;
}
inline ::pb::PbRect* SceneConfGamePlay::mutable_cameramovearea() {
  set_has_cameramovearea();
  if (cameramovearea_ == NULL) cameramovearea_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.CameraMoveArea)
  return cameramovearea_;
}
inline ::pb::PbRect* SceneConfGamePlay::release_cameramovearea() {
  clear_has_cameramovearea();
  ::pb::PbRect* temp = cameramovearea_;
  cameramovearea_ = NULL;
  return temp;
}
inline void SceneConfGamePlay::set_allocated_cameramovearea(::pb::PbRect* cameramovearea) {
  delete cameramovearea_;
  cameramovearea_ = cameramovearea;
  if (cameramovearea) {
    set_has_cameramovearea();
  } else {
    clear_has_cameramovearea();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGamePlay.CameraMoveArea)
}

// repeated .pb.PointElement2 PointElementArr = 5;
inline int SceneConfGamePlay::pointelementarr_size() const {
  return pointelementarr_.size();
}
inline void SceneConfGamePlay::clear_pointelementarr() {
  pointelementarr_.Clear();
}
inline const ::pb::PointElement2& SceneConfGamePlay::pointelementarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.PointElementArr)
  return pointelementarr_.Get(index);
}
inline ::pb::PointElement2* SceneConfGamePlay::mutable_pointelementarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.PointElementArr)
  return pointelementarr_.Mutable(index);
}
inline ::pb::PointElement2* SceneConfGamePlay::add_pointelementarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.PointElementArr)
  return pointelementarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >&
SceneConfGamePlay::pointelementarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.PointElementArr)
  return pointelementarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >*
SceneConfGamePlay::mutable_pointelementarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.PointElementArr)
  return &pointelementarr_;
}

// repeated .pb.FeatureEntrance FeatureEntranceArr = 6;
inline int SceneConfGamePlay::featureentrancearr_size() const {
  return featureentrancearr_.size();
}
inline void SceneConfGamePlay::clear_featureentrancearr() {
  featureentrancearr_.Clear();
}
inline const ::pb::FeatureEntrance& SceneConfGamePlay::featureentrancearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.FeatureEntranceArr)
  return featureentrancearr_.Get(index);
}
inline ::pb::FeatureEntrance* SceneConfGamePlay::mutable_featureentrancearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.FeatureEntranceArr)
  return featureentrancearr_.Mutable(index);
}
inline ::pb::FeatureEntrance* SceneConfGamePlay::add_featureentrancearr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.FeatureEntranceArr)
  return featureentrancearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >&
SceneConfGamePlay::featureentrancearr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.FeatureEntranceArr)
  return featureentrancearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >*
SceneConfGamePlay::mutable_featureentrancearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.FeatureEntranceArr)
  return &featureentrancearr_;
}

// repeated .pb.AssetGroup AssetGrpArr = 7;
inline int SceneConfGamePlay::assetgrparr_size() const {
  return assetgrparr_.size();
}
inline void SceneConfGamePlay::clear_assetgrparr() {
  assetgrparr_.Clear();
}
inline const ::pb::AssetGroup& SceneConfGamePlay::assetgrparr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.AssetGrpArr)
  return assetgrparr_.Get(index);
}
inline ::pb::AssetGroup* SceneConfGamePlay::mutable_assetgrparr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.AssetGrpArr)
  return assetgrparr_.Mutable(index);
}
inline ::pb::AssetGroup* SceneConfGamePlay::add_assetgrparr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.AssetGrpArr)
  return assetgrparr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AssetGroup >&
SceneConfGamePlay::assetgrparr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.AssetGrpArr)
  return assetgrparr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AssetGroup >*
SceneConfGamePlay::mutable_assetgrparr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.AssetGrpArr)
  return &assetgrparr_;
}

// repeated .pb.EffectAsset2 EffectAssetArr = 8;
inline int SceneConfGamePlay::effectassetarr_size() const {
  return effectassetarr_.size();
}
inline void SceneConfGamePlay::clear_effectassetarr() {
  effectassetarr_.Clear();
}
inline const ::pb::EffectAsset2& SceneConfGamePlay::effectassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.EffectAssetArr)
  return effectassetarr_.Get(index);
}
inline ::pb::EffectAsset2* SceneConfGamePlay::mutable_effectassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.EffectAssetArr)
  return effectassetarr_.Mutable(index);
}
inline ::pb::EffectAsset2* SceneConfGamePlay::add_effectassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.EffectAssetArr)
  return effectassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
SceneConfGamePlay::effectassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.EffectAssetArr)
  return effectassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
SceneConfGamePlay::mutable_effectassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.EffectAssetArr)
  return &effectassetarr_;
}

// repeated .pb.AnimAsset2 AnimAssetArr = 9;
inline int SceneConfGamePlay::animassetarr_size() const {
  return animassetarr_.size();
}
inline void SceneConfGamePlay::clear_animassetarr() {
  animassetarr_.Clear();
}
inline const ::pb::AnimAsset2& SceneConfGamePlay::animassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.AnimAssetArr)
  return animassetarr_.Get(index);
}
inline ::pb::AnimAsset2* SceneConfGamePlay::mutable_animassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.AnimAssetArr)
  return animassetarr_.Mutable(index);
}
inline ::pb::AnimAsset2* SceneConfGamePlay::add_animassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.AnimAssetArr)
  return animassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
SceneConfGamePlay::animassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.AnimAssetArr)
  return animassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
SceneConfGamePlay::mutable_animassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.AnimAssetArr)
  return &animassetarr_;
}

// repeated .pb.StaticAsset2 StaticAssetArr = 10;
inline int SceneConfGamePlay::staticassetarr_size() const {
  return staticassetarr_.size();
}
inline void SceneConfGamePlay::clear_staticassetarr() {
  staticassetarr_.Clear();
}
inline const ::pb::StaticAsset2& SceneConfGamePlay::staticassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.StaticAssetArr)
  return staticassetarr_.Get(index);
}
inline ::pb::StaticAsset2* SceneConfGamePlay::mutable_staticassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.StaticAssetArr)
  return staticassetarr_.Mutable(index);
}
inline ::pb::StaticAsset2* SceneConfGamePlay::add_staticassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.StaticAssetArr)
  return staticassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
SceneConfGamePlay::staticassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.StaticAssetArr)
  return staticassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
SceneConfGamePlay::mutable_staticassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.StaticAssetArr)
  return &staticassetarr_;
}

// repeated .pb.PatrolPath2 PatrolPathArr = 11;
inline int SceneConfGamePlay::patrolpatharr_size() const {
  return patrolpatharr_.size();
}
inline void SceneConfGamePlay::clear_patrolpatharr() {
  patrolpatharr_.Clear();
}
inline const ::pb::PatrolPath2& SceneConfGamePlay::patrolpatharr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.PatrolPathArr)
  return patrolpatharr_.Get(index);
}
inline ::pb::PatrolPath2* SceneConfGamePlay::mutable_patrolpatharr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.PatrolPathArr)
  return patrolpatharr_.Mutable(index);
}
inline ::pb::PatrolPath2* SceneConfGamePlay::add_patrolpatharr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.PatrolPathArr)
  return patrolpatharr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >&
SceneConfGamePlay::patrolpatharr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.PatrolPathArr)
  return patrolpatharr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >*
SceneConfGamePlay::mutable_patrolpatharr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.PatrolPathArr)
  return &patrolpatharr_;
}

// repeated .pb.PatrolPathConf PatrolPathConfArr = 12;
inline int SceneConfGamePlay::patrolpathconfarr_size() const {
  return patrolpathconfarr_.size();
}
inline void SceneConfGamePlay::clear_patrolpathconfarr() {
  patrolpathconfarr_.Clear();
}
inline const ::pb::PatrolPathConf& SceneConfGamePlay::patrolpathconfarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.PatrolPathConfArr)
  return patrolpathconfarr_.Get(index);
}
inline ::pb::PatrolPathConf* SceneConfGamePlay::mutable_patrolpathconfarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.PatrolPathConfArr)
  return patrolpathconfarr_.Mutable(index);
}
inline ::pb::PatrolPathConf* SceneConfGamePlay::add_patrolpathconfarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.PatrolPathConfArr)
  return patrolpathconfarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathConf >&
SceneConfGamePlay::patrolpathconfarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.PatrolPathConfArr)
  return patrolpathconfarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathConf >*
SceneConfGamePlay::mutable_patrolpathconfarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.PatrolPathConfArr)
  return &patrolpathconfarr_;
}

// optional .pb.SpawnArea SpawnArea = 13;
inline bool SceneConfGamePlay::has_spawnarea() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SceneConfGamePlay::set_has_spawnarea() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SceneConfGamePlay::clear_has_spawnarea() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SceneConfGamePlay::clear_spawnarea() {
  if (spawnarea_ != NULL) spawnarea_->::pb::SpawnArea::Clear();
  clear_has_spawnarea();
}
inline const ::pb::SpawnArea& SceneConfGamePlay::spawnarea() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.SpawnArea)
  return spawnarea_ != NULL ? *spawnarea_ : *default_instance_->spawnarea_;
}
inline ::pb::SpawnArea* SceneConfGamePlay::mutable_spawnarea() {
  set_has_spawnarea();
  if (spawnarea_ == NULL) spawnarea_ = new ::pb::SpawnArea;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.SpawnArea)
  return spawnarea_;
}
inline ::pb::SpawnArea* SceneConfGamePlay::release_spawnarea() {
  clear_has_spawnarea();
  ::pb::SpawnArea* temp = spawnarea_;
  spawnarea_ = NULL;
  return temp;
}
inline void SceneConfGamePlay::set_allocated_spawnarea(::pb::SpawnArea* spawnarea) {
  delete spawnarea_;
  spawnarea_ = spawnarea;
  if (spawnarea) {
    set_has_spawnarea();
  } else {
    clear_has_spawnarea();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGamePlay.SpawnArea)
}

// repeated .pb.EventArea EventAreaArr = 14;
inline int SceneConfGamePlay::eventareaarr_size() const {
  return eventareaarr_.size();
}
inline void SceneConfGamePlay::clear_eventareaarr() {
  eventareaarr_.Clear();
}
inline const ::pb::EventArea& SceneConfGamePlay::eventareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.EventAreaArr)
  return eventareaarr_.Get(index);
}
inline ::pb::EventArea* SceneConfGamePlay::mutable_eventareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.EventAreaArr)
  return eventareaarr_.Mutable(index);
}
inline ::pb::EventArea* SceneConfGamePlay::add_eventareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.EventAreaArr)
  return eventareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EventArea >&
SceneConfGamePlay::eventareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.EventAreaArr)
  return eventareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EventArea >*
SceneConfGamePlay::mutable_eventareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.EventAreaArr)
  return &eventareaarr_;
}

// optional .pb.SceneChunkInfo ChunkInfo = 15;
inline bool SceneConfGamePlay::has_chunkinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SceneConfGamePlay::set_has_chunkinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SceneConfGamePlay::clear_has_chunkinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SceneConfGamePlay::clear_chunkinfo() {
  if (chunkinfo_ != NULL) chunkinfo_->::pb::SceneChunkInfo::Clear();
  clear_has_chunkinfo();
}
inline const ::pb::SceneChunkInfo& SceneConfGamePlay::chunkinfo() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.ChunkInfo)
  return chunkinfo_ != NULL ? *chunkinfo_ : *default_instance_->chunkinfo_;
}
inline ::pb::SceneChunkInfo* SceneConfGamePlay::mutable_chunkinfo() {
  set_has_chunkinfo();
  if (chunkinfo_ == NULL) chunkinfo_ = new ::pb::SceneChunkInfo;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.ChunkInfo)
  return chunkinfo_;
}
inline ::pb::SceneChunkInfo* SceneConfGamePlay::release_chunkinfo() {
  clear_has_chunkinfo();
  ::pb::SceneChunkInfo* temp = chunkinfo_;
  chunkinfo_ = NULL;
  return temp;
}
inline void SceneConfGamePlay::set_allocated_chunkinfo(::pb::SceneChunkInfo* chunkinfo) {
  delete chunkinfo_;
  chunkinfo_ = chunkinfo;
  if (chunkinfo) {
    set_has_chunkinfo();
  } else {
    clear_has_chunkinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGamePlay.ChunkInfo)
}

// repeated .pb.RectArea2 RectAreaArr = 16;
inline int SceneConfGamePlay::rectareaarr_size() const {
  return rectareaarr_.size();
}
inline void SceneConfGamePlay::clear_rectareaarr() {
  rectareaarr_.Clear();
}
inline const ::pb::RectArea2& SceneConfGamePlay::rectareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.RectAreaArr)
  return rectareaarr_.Get(index);
}
inline ::pb::RectArea2* SceneConfGamePlay::mutable_rectareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.RectAreaArr)
  return rectareaarr_.Mutable(index);
}
inline ::pb::RectArea2* SceneConfGamePlay::add_rectareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.RectAreaArr)
  return rectareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >&
SceneConfGamePlay::rectareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.RectAreaArr)
  return rectareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >*
SceneConfGamePlay::mutable_rectareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.RectAreaArr)
  return &rectareaarr_;
}

// repeated .pb.CustomArea2 CustomAreaArr = 17;
inline int SceneConfGamePlay::customareaarr_size() const {
  return customareaarr_.size();
}
inline void SceneConfGamePlay::clear_customareaarr() {
  customareaarr_.Clear();
}
inline const ::pb::CustomArea2& SceneConfGamePlay::customareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGamePlay.CustomAreaArr)
  return customareaarr_.Get(index);
}
inline ::pb::CustomArea2* SceneConfGamePlay::mutable_customareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGamePlay.CustomAreaArr)
  return customareaarr_.Mutable(index);
}
inline ::pb::CustomArea2* SceneConfGamePlay::add_customareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGamePlay.CustomAreaArr)
  return customareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >&
SceneConfGamePlay::customareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGamePlay.CustomAreaArr)
  return customareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >*
SceneConfGamePlay::mutable_customareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGamePlay.CustomAreaArr)
  return &customareaarr_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fSceneConfGamePlay_2eproto__INCLUDED
