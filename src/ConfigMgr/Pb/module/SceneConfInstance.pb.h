// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/SceneConfInstance.proto

#ifndef PROTOBUF_module_2fSceneConfInstance_2eproto__INCLUDED
#define PROTOBUF_module_2fSceneConfInstance_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
#include "module/SceneConf2d.pb.h"
#include "module/SceneElementDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

class TreasureBox;
class InteracteSceneUI;
class WarMisty;
class WarMistyArea;
class TaskNpc;
class MapInfo;
class SceneConfInstance;

// ===================================================================

/*FOR2LUA
<Record>
	<name>TreasureBox</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TreasureBox : public ::google::protobuf::Message {
 public:
  TreasureBox();
  virtual ~TreasureBox();

  TreasureBox(const TreasureBox& from);

  inline TreasureBox& operator=(const TreasureBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TreasureBox& default_instance();

  void Swap(TreasureBox* other);

  // implements Message ----------------------------------------------

  TreasureBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreasureBox& from);
  void MergeFrom(const TreasureBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // required .pb.PbRect RectInfo = 3;
  inline bool has_rectinfo() const;
  inline void clear_rectinfo();
  static const int kRectInfoFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& rectinfo() const;
  inline ::pb::PbRect* mutable_rectinfo();
  inline ::pb::PbRect* release_rectinfo();
  inline void set_allocated_rectinfo(::pb::PbRect* rectinfo);

  // required bool Visible = 4;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional string NormalAssetPath = 5;
  inline bool has_normalassetpath() const;
  inline void clear_normalassetpath();
  static const int kNormalAssetPathFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>normalassetpath</name>
  		<replaceName>NormalAssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_normalassetpath</name>
  		<replaceName>NormalAssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_normalassetpath</name>
  		<replaceName>NormalAssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& normalassetpath() const;
  inline void set_normalassetpath(const ::std::string& value);
  inline void set_normalassetpath(const char* value);
  inline void set_normalassetpath(const char* value, size_t size);
  inline ::std::string* mutable_normalassetpath();
  inline ::std::string* release_normalassetpath();
  inline void set_allocated_normalassetpath(::std::string* normalassetpath);

  // optional bool NormalAssetIsAnim = 6;
  inline bool has_normalassetisanim() const;
  inline void clear_normalassetisanim();
  static const int kNormalAssetIsAnimFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>normalassetisanim</name>
  		<replaceName>NormalAssetIsAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_normalassetisanim</name>
  		<replaceName>NormalAssetIsAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_normalassetisanim</name>
  		<replaceName>NormalAssetIsAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool normalassetisanim() const;
  inline void set_normalassetisanim(bool value);

  // optional string NormalDefaultAnim = 7;
  inline bool has_normaldefaultanim() const;
  inline void clear_normaldefaultanim();
  static const int kNormalDefaultAnimFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>normaldefaultanim</name>
  		<replaceName>NormalDefaultAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_normaldefaultanim</name>
  		<replaceName>NormalDefaultAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_normaldefaultanim</name>
  		<replaceName>NormalDefaultAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& normaldefaultanim() const;
  inline void set_normaldefaultanim(const ::std::string& value);
  inline void set_normaldefaultanim(const char* value);
  inline void set_normaldefaultanim(const char* value, size_t size);
  inline ::std::string* mutable_normaldefaultanim();
  inline ::std::string* release_normaldefaultanim();
  inline void set_allocated_normaldefaultanim(::std::string* normaldefaultanim);

  // optional string TriggeredAssetPath = 8;
  inline bool has_triggeredassetpath() const;
  inline void clear_triggeredassetpath();
  static const int kTriggeredAssetPathFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>triggeredassetpath</name>
  		<replaceName>TriggeredAssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggeredassetpath</name>
  		<replaceName>TriggeredAssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggeredassetpath</name>
  		<replaceName>TriggeredAssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& triggeredassetpath() const;
  inline void set_triggeredassetpath(const ::std::string& value);
  inline void set_triggeredassetpath(const char* value);
  inline void set_triggeredassetpath(const char* value, size_t size);
  inline ::std::string* mutable_triggeredassetpath();
  inline ::std::string* release_triggeredassetpath();
  inline void set_allocated_triggeredassetpath(::std::string* triggeredassetpath);

  // optional bool TriggeredAssetIsAnim = 9;
  inline bool has_triggeredassetisanim() const;
  inline void clear_triggeredassetisanim();
  static const int kTriggeredAssetIsAnimFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>triggeredassetisanim</name>
  		<replaceName>TriggeredAssetIsAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggeredassetisanim</name>
  		<replaceName>TriggeredAssetIsAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggeredassetisanim</name>
  		<replaceName>TriggeredAssetIsAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool triggeredassetisanim() const;
  inline void set_triggeredassetisanim(bool value);

  // optional string TriggeredDefaultAnim = 10;
  inline bool has_triggereddefaultanim() const;
  inline void clear_triggereddefaultanim();
  static const int kTriggeredDefaultAnimFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>triggereddefaultanim</name>
  		<replaceName>TriggeredDefaultAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggereddefaultanim</name>
  		<replaceName>TriggeredDefaultAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggereddefaultanim</name>
  		<replaceName>TriggeredDefaultAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& triggereddefaultanim() const;
  inline void set_triggereddefaultanim(const ::std::string& value);
  inline void set_triggereddefaultanim(const char* value);
  inline void set_triggereddefaultanim(const char* value, size_t size);
  inline ::std::string* mutable_triggereddefaultanim();
  inline ::std::string* release_triggereddefaultanim();
  inline void set_allocated_triggereddefaultanim(::std::string* triggereddefaultanim);

  // optional string SortingLayer = 11;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional int32 SortingOrder = 12;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::int32 value);

  // optional bool DelAfterReceive = 13;
  inline bool has_delafterreceive() const;
  inline void clear_delafterreceive();
  static const int kDelAfterReceiveFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>TreasureBox</name>
  	<Function>
  		<name>delafterreceive</name>
  		<replaceName>DelAfterReceive</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delafterreceive</name>
  		<replaceName>DelAfterReceive</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delafterreceive</name>
  		<replaceName>DelAfterReceive</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool delafterreceive() const;
  inline void set_delafterreceive(bool value);

  // @@protoc_insertion_point(class_scope:pb.TreasureBox)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_rectinfo();
  inline void clear_has_rectinfo();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_normalassetpath();
  inline void clear_has_normalassetpath();
  inline void set_has_normalassetisanim();
  inline void clear_has_normalassetisanim();
  inline void set_has_normaldefaultanim();
  inline void clear_has_normaldefaultanim();
  inline void set_has_triggeredassetpath();
  inline void clear_has_triggeredassetpath();
  inline void set_has_triggeredassetisanim();
  inline void clear_has_triggeredassetisanim();
  inline void set_has_triggereddefaultanim();
  inline void clear_has_triggereddefaultanim();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();
  inline void set_has_delafterreceive();
  inline void clear_has_delafterreceive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::pb::PbRect* rectinfo_;
  ::std::string* normalassetpath_;
  ::std::string* normaldefaultanim_;
  ::std::string* triggeredassetpath_;
  bool visible_;
  bool normalassetisanim_;
  bool triggeredassetisanim_;
  bool delafterreceive_;
  ::google::protobuf::int32 sortingorder_;
  ::std::string* triggereddefaultanim_;
  ::std::string* sortinglayer_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static TreasureBox* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>InteracteSceneUI</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class InteracteSceneUI : public ::google::protobuf::Message {
 public:
  InteracteSceneUI();
  virtual ~InteracteSceneUI();

  InteracteSceneUI(const InteracteSceneUI& from);

  inline InteracteSceneUI& operator=(const InteracteSceneUI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InteracteSceneUI& default_instance();

  void Swap(InteracteSceneUI* other);

  // implements Message ----------------------------------------------

  InteracteSceneUI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InteracteSceneUI& from);
  void MergeFrom(const InteracteSceneUI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>InteracteSceneUI</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>InteracteSceneUI</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional .pb.PbVector2 Scale = 3;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>InteracteSceneUI</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& scale() const;
  inline ::pb::PbVector2* mutable_scale();
  inline ::pb::PbVector2* release_scale();
  inline void set_allocated_scale(::pb::PbVector2* scale);

  // optional string AssetPath = 4;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>InteracteSceneUI</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // optional .pb.PbRect RectInfo = 5;
  inline bool has_rectinfo() const;
  inline void clear_rectinfo();
  static const int kRectInfoFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>InteracteSceneUI</name>
  	<Function>
  		<name>rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& rectinfo() const;
  inline ::pb::PbRect* mutable_rectinfo();
  inline ::pb::PbRect* release_rectinfo();
  inline void set_allocated_rectinfo(::pb::PbRect* rectinfo);

  // @@protoc_insertion_point(class_scope:pb.InteracteSceneUI)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_rectinfo();
  inline void clear_has_rectinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::pb::PbVector2* scale_;
  ::std::string* assetpath_;
  ::pb::PbRect* rectinfo_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static InteracteSceneUI* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>WarMisty</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class WarMisty : public ::google::protobuf::Message {
 public:
  WarMisty();
  virtual ~WarMisty();

  WarMisty(const WarMisty& from);

  inline WarMisty& operator=(const WarMisty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WarMisty& default_instance();

  void Swap(WarMisty* other);

  // implements Message ----------------------------------------------

  WarMisty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WarMisty& from);
  void MergeFrom(const WarMisty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float UniformScale = 1;
  inline bool has_uniformscale() const;
  inline void clear_uniformscale();
  static const int kUniformScaleFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>WarMisty</name>
  	<Function>
  		<name>uniformscale</name>
  		<replaceName>UniformScale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_uniformscale</name>
  		<replaceName>UniformScale</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_uniformscale</name>
  		<replaceName>UniformScale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float uniformscale() const;
  inline void set_uniformscale(float value);

  // optional .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>WarMisty</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional uint32 AssetPathIndex = 3;
  inline bool has_assetpathindex() const;
  inline void clear_assetpathindex();
  static const int kAssetPathIndexFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>WarMisty</name>
  	<Function>
  		<name>assetpathindex</name>
  		<replaceName>AssetPathIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpathindex</name>
  		<replaceName>AssetPathIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpathindex</name>
  		<replaceName>AssetPathIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 assetpathindex() const;
  inline void set_assetpathindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.WarMisty)
 private:
  inline void set_has_uniformscale();
  inline void clear_has_uniformscale();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_assetpathindex();
  inline void clear_has_assetpathindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector2* position_;
  float uniformscale_;
  ::google::protobuf::uint32 assetpathindex_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static WarMisty* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>WarMistyArea</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class WarMistyArea : public ::google::protobuf::Message {
 public:
  WarMistyArea();
  virtual ~WarMistyArea();

  WarMistyArea(const WarMistyArea& from);

  inline WarMistyArea& operator=(const WarMistyArea& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WarMistyArea& default_instance();

  void Swap(WarMistyArea* other);

  // implements Message ----------------------------------------------

  WarMistyArea* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WarMistyArea& from);
  void MergeFrom(const WarMistyArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>WarMistyArea</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.WarMisty WarMistyArr = 2;
  inline int warmistyarr_size() const;
  inline void clear_warmistyarr();
  static const int kWarMistyArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>WarMistyArea</name>
  	<Function>
  		<name>warmistyarr</name>
  		<replaceName>WarMistyArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_warmistyarr</name>
  		<replaceName>WarMistyArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_warmistyarr</name>
  		<replaceName>WarMistyArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_warmistyarr</name>
  		<replaceName>WarMistyArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>warmistyarr_size</name>
  		<replaceName>WarMistyArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::WarMisty& warmistyarr(int index) const;
  inline ::pb::WarMisty* mutable_warmistyarr(int index);
  inline ::pb::WarMisty* add_warmistyarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::WarMisty >&
      warmistyarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::WarMisty >*
      mutable_warmistyarr();

  // optional bool Visible = 3;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>WarMistyArea</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional string SortingLayer = 4;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>WarMistyArea</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional int32 SortingOrder = 5;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>WarMistyArea</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.WarMistyArea)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::WarMisty > warmistyarr_;
  ::std::string* sortinglayer_;
  bool visible_;
  ::google::protobuf::int32 sortingorder_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static WarMistyArea* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TaskNpc</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TaskNpc : public ::google::protobuf::Message {
 public:
  TaskNpc();
  virtual ~TaskNpc();

  TaskNpc(const TaskNpc& from);

  inline TaskNpc& operator=(const TaskNpc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskNpc& default_instance();

  void Swap(TaskNpc* other);

  // implements Message ----------------------------------------------

  TaskNpc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskNpc& from);
  void MergeFrom(const TaskNpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TaskNpc</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TaskNpc</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional .pb.PbRect RectInfo = 3;
  inline bool has_rectinfo() const;
  inline void clear_rectinfo();
  static const int kRectInfoFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TaskNpc</name>
  	<Function>
  		<name>rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& rectinfo() const;
  inline ::pb::PbRect* mutable_rectinfo();
  inline ::pb::PbRect* release_rectinfo();
  inline void set_allocated_rectinfo(::pb::PbRect* rectinfo);

  // optional string ViewElementName = 4;
  inline bool has_viewelementname() const;
  inline void clear_viewelementname();
  static const int kViewElementNameFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TaskNpc</name>
  	<Function>
  		<name>viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& viewelementname() const;
  inline void set_viewelementname(const ::std::string& value);
  inline void set_viewelementname(const char* value);
  inline void set_viewelementname(const char* value, size_t size);
  inline ::std::string* mutable_viewelementname();
  inline ::std::string* release_viewelementname();
  inline void set_allocated_viewelementname(::std::string* viewelementname);

  // optional .pb.ESceneElementType ViewElementType = 5;
  inline bool has_viewelementtype() const;
  inline void clear_viewelementtype();
  static const int kViewElementTypeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>TaskNpc</name>
  	<Function>
  		<name>viewelementtype</name>
  		<replaceName>ViewElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_viewelementtype</name>
  		<replaceName>ViewElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_viewelementtype</name>
  		<replaceName>ViewElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType viewelementtype() const;
  inline void set_viewelementtype(::pb::ESceneElementType value);

  // @@protoc_insertion_point(class_scope:pb.TaskNpc)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_rectinfo();
  inline void clear_has_rectinfo();
  inline void set_has_viewelementname();
  inline void clear_has_viewelementname();
  inline void set_has_viewelementtype();
  inline void clear_has_viewelementtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::pb::PbRect* rectinfo_;
  ::std::string* viewelementname_;
  int viewelementtype_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static TaskNpc* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>MapInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class MapInfo : public ::google::protobuf::Message {
 public:
  MapInfo();
  virtual ~MapInfo();

  MapInfo(const MapInfo& from);

  inline MapInfo& operator=(const MapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapInfo& default_instance();

  void Swap(MapInfo* other);

  // implements Message ----------------------------------------------

  MapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapInfo& from);
  void MergeFrom(const MapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 MapSceneType = 1;
  inline bool has_mapscenetype() const;
  inline void clear_mapscenetype();
  static const int kMapSceneTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>MapInfo</name>
  	<Function>
  		<name>mapscenetype</name>
  		<replaceName>MapSceneType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mapscenetype</name>
  		<replaceName>MapSceneType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mapscenetype</name>
  		<replaceName>MapSceneType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 mapscenetype() const;
  inline void set_mapscenetype(::google::protobuf::int32 value);

  // optional string MapSceneName = 2;
  inline bool has_mapscenename() const;
  inline void clear_mapscenename();
  static const int kMapSceneNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>MapInfo</name>
  	<Function>
  		<name>mapscenename</name>
  		<replaceName>MapSceneName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mapscenename</name>
  		<replaceName>MapSceneName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mapscenename</name>
  		<replaceName>MapSceneName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& mapscenename() const;
  inline void set_mapscenename(const ::std::string& value);
  inline void set_mapscenename(const char* value);
  inline void set_mapscenename(const char* value, size_t size);
  inline ::std::string* mutable_mapscenename();
  inline ::std::string* release_mapscenename();
  inline void set_allocated_mapscenename(::std::string* mapscenename);

  // @@protoc_insertion_point(class_scope:pb.MapInfo)
 private:
  inline void set_has_mapscenetype();
  inline void clear_has_mapscenetype();
  inline void set_has_mapscenename();
  inline void clear_has_mapscenename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapscenename_;
  ::google::protobuf::int32 mapscenetype_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static MapInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SceneConfInstance</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfInstance.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SceneConfInstance : public ::google::protobuf::Message {
 public:
  SceneConfInstance();
  virtual ~SceneConfInstance();

  SceneConfInstance(const SceneConfInstance& from);

  inline SceneConfInstance& operator=(const SceneConfInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneConfInstance& default_instance();

  void Swap(SceneConfInstance* other);

  // implements Message ----------------------------------------------

  SceneConfInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneConfInstance& from);
  void MergeFrom(const SceneConfInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string ConfName = 2;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // optional .pb.MapInfo MapInfo = 3;
  inline bool has_mapinfo() const;
  inline void clear_mapinfo();
  static const int kMapInfoFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>mapinfo</name>
  		<replaceName>MapInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mapinfo</name>
  		<replaceName>MapInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_mapinfo</name>
  		<replaceName>MapInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mapinfo</name>
  		<replaceName>MapInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::MapInfo& mapinfo() const;
  inline ::pb::MapInfo* mutable_mapinfo();
  inline ::pb::MapInfo* release_mapinfo();
  inline void set_allocated_mapinfo(::pb::MapInfo* mapinfo);

  // required .pb.SceneChunkInfo ChunkInfo = 4;
  inline bool has_chunkinfo() const;
  inline void clear_chunkinfo();
  static const int kChunkInfoFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SceneChunkInfo& chunkinfo() const;
  inline ::pb::SceneChunkInfo* mutable_chunkinfo();
  inline ::pb::SceneChunkInfo* release_chunkinfo();
  inline void set_allocated_chunkinfo(::pb::SceneChunkInfo* chunkinfo);

  // repeated .pb.PointElement2 PointElementArr = 5;
  inline int pointelementarr_size() const;
  inline void clear_pointelementarr();
  static const int kPointElementArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointelementarr_size</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PointElement2& pointelementarr(int index) const;
  inline ::pb::PointElement2* mutable_pointelementarr(int index);
  inline ::pb::PointElement2* add_pointelementarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >&
      pointelementarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >*
      mutable_pointelementarr();

  // required .pb.PbRect CameraMoveArea = 6;
  inline bool has_cameramovearea() const;
  inline void clear_cameramovearea();
  static const int kCameraMoveAreaFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& cameramovearea() const;
  inline ::pb::PbRect* mutable_cameramovearea();
  inline ::pb::PbRect* release_cameramovearea();
  inline void set_allocated_cameramovearea(::pb::PbRect* cameramovearea);

  // repeated .pb.RectArea2 RectAreaArr = 7;
  inline int rectareaarr_size() const;
  inline void clear_rectareaarr();
  static const int kRectAreaArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rectareaarr_size</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::RectArea2& rectareaarr(int index) const;
  inline ::pb::RectArea2* mutable_rectareaarr(int index);
  inline ::pb::RectArea2* add_rectareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >&
      rectareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >*
      mutable_rectareaarr();

  // repeated .pb.CustomArea2 CustomAreaArr = 8;
  inline int customareaarr_size() const;
  inline void clear_customareaarr();
  static const int kCustomAreaArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>customareaarr_size</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CustomArea2& customareaarr(int index) const;
  inline ::pb::CustomArea2* mutable_customareaarr(int index);
  inline ::pb::CustomArea2* add_customareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >&
      customareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >*
      mutable_customareaarr();

  // repeated .pb.AnimAsset2 AnimAssetArr = 9;
  inline int animassetarr_size() const;
  inline void clear_animassetarr();
  static const int kAnimAssetArrFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>animassetarr_size</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AnimAsset2& animassetarr(int index) const;
  inline ::pb::AnimAsset2* mutable_animassetarr(int index);
  inline ::pb::AnimAsset2* add_animassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
      animassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
      mutable_animassetarr();

  // repeated .pb.StaticAsset2 StaticAssetArr = 10;
  inline int staticassetarr_size() const;
  inline void clear_staticassetarr();
  static const int kStaticAssetArrFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>staticassetarr_size</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StaticAsset2& staticassetarr(int index) const;
  inline ::pb::StaticAsset2* mutable_staticassetarr(int index);
  inline ::pb::StaticAsset2* add_staticassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
      staticassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
      mutable_staticassetarr();

  // repeated .pb.EffectAsset2 EffectAssetArr = 11;
  inline int effectassetarr_size() const;
  inline void clear_effectassetarr();
  static const int kEffectAssetArrFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectassetarr_size</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectAsset2& effectassetarr(int index) const;
  inline ::pb::EffectAsset2* mutable_effectassetarr(int index);
  inline ::pb::EffectAsset2* add_effectassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
      effectassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
      mutable_effectassetarr();

  // repeated .pb.TreasureBox TreasureBoxArr = 12;
  inline int treasureboxarr_size() const;
  inline void clear_treasureboxarr();
  static const int kTreasureBoxArrFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>treasureboxarr</name>
  		<replaceName>TreasureBoxArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_treasureboxarr</name>
  		<replaceName>TreasureBoxArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_treasureboxarr</name>
  		<replaceName>TreasureBoxArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_treasureboxarr</name>
  		<replaceName>TreasureBoxArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>treasureboxarr_size</name>
  		<replaceName>TreasureBoxArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TreasureBox& treasureboxarr(int index) const;
  inline ::pb::TreasureBox* mutable_treasureboxarr(int index);
  inline ::pb::TreasureBox* add_treasureboxarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TreasureBox >&
      treasureboxarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TreasureBox >*
      mutable_treasureboxarr();

  // repeated .pb.WarMistyArea WarMistyAreaArr = 13;
  inline int warmistyareaarr_size() const;
  inline void clear_warmistyareaarr();
  static const int kWarMistyAreaArrFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>warmistyareaarr</name>
  		<replaceName>WarMistyAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_warmistyareaarr</name>
  		<replaceName>WarMistyAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_warmistyareaarr</name>
  		<replaceName>WarMistyAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_warmistyareaarr</name>
  		<replaceName>WarMistyAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>warmistyareaarr_size</name>
  		<replaceName>WarMistyAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::WarMistyArea& warmistyareaarr(int index) const;
  inline ::pb::WarMistyArea* mutable_warmistyareaarr(int index);
  inline ::pb::WarMistyArea* add_warmistyareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::WarMistyArea >&
      warmistyareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::WarMistyArea >*
      mutable_warmistyareaarr();

  // repeated .pb.InteracteSceneUI InteracteSceneUIArr = 14;
  inline int interactesceneuiarr_size() const;
  inline void clear_interactesceneuiarr();
  static const int kInteracteSceneUIArrFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>interactesceneuiarr</name>
  		<replaceName>InteracteSceneUIArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_interactesceneuiarr</name>
  		<replaceName>InteracteSceneUIArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_interactesceneuiarr</name>
  		<replaceName>InteracteSceneUIArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_interactesceneuiarr</name>
  		<replaceName>InteracteSceneUIArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>interactesceneuiarr_size</name>
  		<replaceName>InteracteSceneUIArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::InteracteSceneUI& interactesceneuiarr(int index) const;
  inline ::pb::InteracteSceneUI* mutable_interactesceneuiarr(int index);
  inline ::pb::InteracteSceneUI* add_interactesceneuiarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::InteracteSceneUI >&
      interactesceneuiarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::InteracteSceneUI >*
      mutable_interactesceneuiarr();

  // repeated .pb.PatrolPath2 PatrolPathArr = 15;
  inline int patrolpatharr_size() const;
  inline void clear_patrolpatharr();
  static const int kPatrolPathArrFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patrolpatharr</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>patrolpatharr_size</name>
  		<replaceName>PatrolPathArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PatrolPath2& patrolpatharr(int index) const;
  inline ::pb::PatrolPath2* mutable_patrolpatharr(int index);
  inline ::pb::PatrolPath2* add_patrolpatharr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >&
      patrolpatharr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >*
      mutable_patrolpatharr();

  // repeated .pb.CarrierEnt2 CarrierEntArr = 16;
  inline int carrierentarr_size() const;
  inline void clear_carrierentarr();
  static const int kCarrierEntArrFieldNumber = 16;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>carrierentarr</name>
  		<replaceName>CarrierEntArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_carrierentarr</name>
  		<replaceName>CarrierEntArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_carrierentarr</name>
  		<replaceName>CarrierEntArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_carrierentarr</name>
  		<replaceName>CarrierEntArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>carrierentarr_size</name>
  		<replaceName>CarrierEntArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CarrierEnt2& carrierentarr(int index) const;
  inline ::pb::CarrierEnt2* mutable_carrierentarr(int index);
  inline ::pb::CarrierEnt2* add_carrierentarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CarrierEnt2 >&
      carrierentarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CarrierEnt2 >*
      mutable_carrierentarr();

  // repeated .pb.Obstacle ObstacleArr = 17;
  inline int obstaclearr_size() const;
  inline void clear_obstaclearr();
  static const int kObstacleArrFieldNumber = 17;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>obstaclearr_size</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::Obstacle& obstaclearr(int index) const;
  inline ::pb::Obstacle* mutable_obstaclearr(int index);
  inline ::pb::Obstacle* add_obstaclearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >&
      obstaclearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >*
      mutable_obstaclearr();

  // repeated string MistyAssetPathArr = 18;
  inline int mistyassetpatharr_size() const;
  inline void clear_mistyassetpatharr();
  static const int kMistyAssetPathArrFieldNumber = 18;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>mistyassetpatharr</name>
  		<replaceName>MistyAssetPathArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_mistyassetpatharr</name>
  		<replaceName>MistyAssetPathArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_mistyassetpatharr</name>
  		<replaceName>MistyAssetPathArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mistyassetpatharr</name>
  		<replaceName>MistyAssetPathArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mistyassetpatharr_size</name>
  		<replaceName>MistyAssetPathArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& mistyassetpatharr(int index) const;
  inline ::std::string* mutable_mistyassetpatharr(int index);
  inline void set_mistyassetpatharr(int index, const ::std::string& value);
  inline void set_mistyassetpatharr(int index, const char* value);
  inline void set_mistyassetpatharr(int index, const char* value, size_t size);
  inline ::std::string* add_mistyassetpatharr();
  inline void add_mistyassetpatharr(const ::std::string& value);
  inline void add_mistyassetpatharr(const char* value);
  inline void add_mistyassetpatharr(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mistyassetpatharr() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mistyassetpatharr();

  // repeated .pb.TaskNpc TaskNpcArr = 19;
  inline int tasknpcarr_size() const;
  inline void clear_tasknpcarr();
  static const int kTaskNpcArrFieldNumber = 19;
  /*FOR2LUA
  <Record>
  	<name>SceneConfInstance</name>
  	<Function>
  		<name>tasknpcarr</name>
  		<replaceName>TaskNpcArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_tasknpcarr</name>
  		<replaceName>TaskNpcArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_tasknpcarr</name>
  		<replaceName>TaskNpcArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_tasknpcarr</name>
  		<replaceName>TaskNpcArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>tasknpcarr_size</name>
  		<replaceName>TaskNpcArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TaskNpc& tasknpcarr(int index) const;
  inline ::pb::TaskNpc* mutable_tasknpcarr(int index);
  inline ::pb::TaskNpc* add_tasknpcarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskNpc >&
      tasknpcarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TaskNpc >*
      mutable_tasknpcarr();

  // @@protoc_insertion_point(class_scope:pb.SceneConfInstance)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_mapinfo();
  inline void clear_has_mapinfo();
  inline void set_has_chunkinfo();
  inline void clear_has_chunkinfo();
  inline void set_has_cameramovearea();
  inline void clear_has_cameramovearea();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* confname_;
  ::pb::MapInfo* mapinfo_;
  ::pb::SceneChunkInfo* chunkinfo_;
  ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 > pointelementarr_;
  ::pb::PbRect* cameramovearea_;
  ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 > rectareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 > customareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 > animassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 > staticassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 > effectassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::TreasureBox > treasureboxarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::WarMistyArea > warmistyareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::InteracteSceneUI > interactesceneuiarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 > patrolpatharr_;
  ::google::protobuf::RepeatedPtrField< ::pb::CarrierEnt2 > carrierentarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::Obstacle > obstaclearr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mistyassetpatharr_;
  ::google::protobuf::RepeatedPtrField< ::pb::TaskNpc > tasknpcarr_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfInstance_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfInstance_2eproto();

  void InitAsDefaultInstance();
  static SceneConfInstance* default_instance_;
};
// ===================================================================


// ===================================================================

// TreasureBox

// required string Name = 1;
inline bool TreasureBox::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreasureBox::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TreasureBox::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TreasureBox::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TreasureBox::name() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.Name)
  return *name_;
}
inline void TreasureBox::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TreasureBox.Name)
}
inline void TreasureBox::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TreasureBox.Name)
}
inline void TreasureBox::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TreasureBox.Name)
}
inline ::std::string* TreasureBox::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.Name)
  return name_;
}
inline ::std::string* TreasureBox::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TreasureBox::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.Name)
}

// required .pb.PbVector2 Position = 2;
inline bool TreasureBox::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreasureBox::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TreasureBox::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TreasureBox::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& TreasureBox::position() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* TreasureBox::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.Position)
  return position_;
}
inline ::pb::PbVector2* TreasureBox::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void TreasureBox::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.Position)
}

// required .pb.PbRect RectInfo = 3;
inline bool TreasureBox::has_rectinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreasureBox::set_has_rectinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TreasureBox::clear_has_rectinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TreasureBox::clear_rectinfo() {
  if (rectinfo_ != NULL) rectinfo_->::pb::PbRect::Clear();
  clear_has_rectinfo();
}
inline const ::pb::PbRect& TreasureBox::rectinfo() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.RectInfo)
  return rectinfo_ != NULL ? *rectinfo_ : *default_instance_->rectinfo_;
}
inline ::pb::PbRect* TreasureBox::mutable_rectinfo() {
  set_has_rectinfo();
  if (rectinfo_ == NULL) rectinfo_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.RectInfo)
  return rectinfo_;
}
inline ::pb::PbRect* TreasureBox::release_rectinfo() {
  clear_has_rectinfo();
  ::pb::PbRect* temp = rectinfo_;
  rectinfo_ = NULL;
  return temp;
}
inline void TreasureBox::set_allocated_rectinfo(::pb::PbRect* rectinfo) {
  delete rectinfo_;
  rectinfo_ = rectinfo;
  if (rectinfo) {
    set_has_rectinfo();
  } else {
    clear_has_rectinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.RectInfo)
}

// required bool Visible = 4;
inline bool TreasureBox::has_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TreasureBox::set_has_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TreasureBox::clear_has_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TreasureBox::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool TreasureBox::visible() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.Visible)
  return visible_;
}
inline void TreasureBox::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.TreasureBox.Visible)
}

// optional string NormalAssetPath = 5;
inline bool TreasureBox::has_normalassetpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreasureBox::set_has_normalassetpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TreasureBox::clear_has_normalassetpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TreasureBox::clear_normalassetpath() {
  if (normalassetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normalassetpath_->clear();
  }
  clear_has_normalassetpath();
}
inline const ::std::string& TreasureBox::normalassetpath() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.NormalAssetPath)
  return *normalassetpath_;
}
inline void TreasureBox::set_normalassetpath(const ::std::string& value) {
  set_has_normalassetpath();
  if (normalassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normalassetpath_ = new ::std::string;
  }
  normalassetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TreasureBox.NormalAssetPath)
}
inline void TreasureBox::set_normalassetpath(const char* value) {
  set_has_normalassetpath();
  if (normalassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normalassetpath_ = new ::std::string;
  }
  normalassetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TreasureBox.NormalAssetPath)
}
inline void TreasureBox::set_normalassetpath(const char* value, size_t size) {
  set_has_normalassetpath();
  if (normalassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normalassetpath_ = new ::std::string;
  }
  normalassetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TreasureBox.NormalAssetPath)
}
inline ::std::string* TreasureBox::mutable_normalassetpath() {
  set_has_normalassetpath();
  if (normalassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normalassetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.NormalAssetPath)
  return normalassetpath_;
}
inline ::std::string* TreasureBox::release_normalassetpath() {
  clear_has_normalassetpath();
  if (normalassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = normalassetpath_;
    normalassetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TreasureBox::set_allocated_normalassetpath(::std::string* normalassetpath) {
  if (normalassetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete normalassetpath_;
  }
  if (normalassetpath) {
    set_has_normalassetpath();
    normalassetpath_ = normalassetpath;
  } else {
    clear_has_normalassetpath();
    normalassetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.NormalAssetPath)
}

// optional bool NormalAssetIsAnim = 6;
inline bool TreasureBox::has_normalassetisanim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TreasureBox::set_has_normalassetisanim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TreasureBox::clear_has_normalassetisanim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TreasureBox::clear_normalassetisanim() {
  normalassetisanim_ = false;
  clear_has_normalassetisanim();
}
inline bool TreasureBox::normalassetisanim() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.NormalAssetIsAnim)
  return normalassetisanim_;
}
inline void TreasureBox::set_normalassetisanim(bool value) {
  set_has_normalassetisanim();
  normalassetisanim_ = value;
  // @@protoc_insertion_point(field_set:pb.TreasureBox.NormalAssetIsAnim)
}

// optional string NormalDefaultAnim = 7;
inline bool TreasureBox::has_normaldefaultanim() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TreasureBox::set_has_normaldefaultanim() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TreasureBox::clear_has_normaldefaultanim() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TreasureBox::clear_normaldefaultanim() {
  if (normaldefaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normaldefaultanim_->clear();
  }
  clear_has_normaldefaultanim();
}
inline const ::std::string& TreasureBox::normaldefaultanim() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.NormalDefaultAnim)
  return *normaldefaultanim_;
}
inline void TreasureBox::set_normaldefaultanim(const ::std::string& value) {
  set_has_normaldefaultanim();
  if (normaldefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normaldefaultanim_ = new ::std::string;
  }
  normaldefaultanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TreasureBox.NormalDefaultAnim)
}
inline void TreasureBox::set_normaldefaultanim(const char* value) {
  set_has_normaldefaultanim();
  if (normaldefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normaldefaultanim_ = new ::std::string;
  }
  normaldefaultanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TreasureBox.NormalDefaultAnim)
}
inline void TreasureBox::set_normaldefaultanim(const char* value, size_t size) {
  set_has_normaldefaultanim();
  if (normaldefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normaldefaultanim_ = new ::std::string;
  }
  normaldefaultanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TreasureBox.NormalDefaultAnim)
}
inline ::std::string* TreasureBox::mutable_normaldefaultanim() {
  set_has_normaldefaultanim();
  if (normaldefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    normaldefaultanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.NormalDefaultAnim)
  return normaldefaultanim_;
}
inline ::std::string* TreasureBox::release_normaldefaultanim() {
  clear_has_normaldefaultanim();
  if (normaldefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = normaldefaultanim_;
    normaldefaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TreasureBox::set_allocated_normaldefaultanim(::std::string* normaldefaultanim) {
  if (normaldefaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete normaldefaultanim_;
  }
  if (normaldefaultanim) {
    set_has_normaldefaultanim();
    normaldefaultanim_ = normaldefaultanim;
  } else {
    clear_has_normaldefaultanim();
    normaldefaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.NormalDefaultAnim)
}

// optional string TriggeredAssetPath = 8;
inline bool TreasureBox::has_triggeredassetpath() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TreasureBox::set_has_triggeredassetpath() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TreasureBox::clear_has_triggeredassetpath() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TreasureBox::clear_triggeredassetpath() {
  if (triggeredassetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggeredassetpath_->clear();
  }
  clear_has_triggeredassetpath();
}
inline const ::std::string& TreasureBox::triggeredassetpath() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.TriggeredAssetPath)
  return *triggeredassetpath_;
}
inline void TreasureBox::set_triggeredassetpath(const ::std::string& value) {
  set_has_triggeredassetpath();
  if (triggeredassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggeredassetpath_ = new ::std::string;
  }
  triggeredassetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TreasureBox.TriggeredAssetPath)
}
inline void TreasureBox::set_triggeredassetpath(const char* value) {
  set_has_triggeredassetpath();
  if (triggeredassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggeredassetpath_ = new ::std::string;
  }
  triggeredassetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TreasureBox.TriggeredAssetPath)
}
inline void TreasureBox::set_triggeredassetpath(const char* value, size_t size) {
  set_has_triggeredassetpath();
  if (triggeredassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggeredassetpath_ = new ::std::string;
  }
  triggeredassetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TreasureBox.TriggeredAssetPath)
}
inline ::std::string* TreasureBox::mutable_triggeredassetpath() {
  set_has_triggeredassetpath();
  if (triggeredassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggeredassetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.TriggeredAssetPath)
  return triggeredassetpath_;
}
inline ::std::string* TreasureBox::release_triggeredassetpath() {
  clear_has_triggeredassetpath();
  if (triggeredassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = triggeredassetpath_;
    triggeredassetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TreasureBox::set_allocated_triggeredassetpath(::std::string* triggeredassetpath) {
  if (triggeredassetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete triggeredassetpath_;
  }
  if (triggeredassetpath) {
    set_has_triggeredassetpath();
    triggeredassetpath_ = triggeredassetpath;
  } else {
    clear_has_triggeredassetpath();
    triggeredassetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.TriggeredAssetPath)
}

// optional bool TriggeredAssetIsAnim = 9;
inline bool TreasureBox::has_triggeredassetisanim() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TreasureBox::set_has_triggeredassetisanim() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TreasureBox::clear_has_triggeredassetisanim() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TreasureBox::clear_triggeredassetisanim() {
  triggeredassetisanim_ = false;
  clear_has_triggeredassetisanim();
}
inline bool TreasureBox::triggeredassetisanim() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.TriggeredAssetIsAnim)
  return triggeredassetisanim_;
}
inline void TreasureBox::set_triggeredassetisanim(bool value) {
  set_has_triggeredassetisanim();
  triggeredassetisanim_ = value;
  // @@protoc_insertion_point(field_set:pb.TreasureBox.TriggeredAssetIsAnim)
}

// optional string TriggeredDefaultAnim = 10;
inline bool TreasureBox::has_triggereddefaultanim() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TreasureBox::set_has_triggereddefaultanim() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TreasureBox::clear_has_triggereddefaultanim() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TreasureBox::clear_triggereddefaultanim() {
  if (triggereddefaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggereddefaultanim_->clear();
  }
  clear_has_triggereddefaultanim();
}
inline const ::std::string& TreasureBox::triggereddefaultanim() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.TriggeredDefaultAnim)
  return *triggereddefaultanim_;
}
inline void TreasureBox::set_triggereddefaultanim(const ::std::string& value) {
  set_has_triggereddefaultanim();
  if (triggereddefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggereddefaultanim_ = new ::std::string;
  }
  triggereddefaultanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TreasureBox.TriggeredDefaultAnim)
}
inline void TreasureBox::set_triggereddefaultanim(const char* value) {
  set_has_triggereddefaultanim();
  if (triggereddefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggereddefaultanim_ = new ::std::string;
  }
  triggereddefaultanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TreasureBox.TriggeredDefaultAnim)
}
inline void TreasureBox::set_triggereddefaultanim(const char* value, size_t size) {
  set_has_triggereddefaultanim();
  if (triggereddefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggereddefaultanim_ = new ::std::string;
  }
  triggereddefaultanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TreasureBox.TriggeredDefaultAnim)
}
inline ::std::string* TreasureBox::mutable_triggereddefaultanim() {
  set_has_triggereddefaultanim();
  if (triggereddefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    triggereddefaultanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.TriggeredDefaultAnim)
  return triggereddefaultanim_;
}
inline ::std::string* TreasureBox::release_triggereddefaultanim() {
  clear_has_triggereddefaultanim();
  if (triggereddefaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = triggereddefaultanim_;
    triggereddefaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TreasureBox::set_allocated_triggereddefaultanim(::std::string* triggereddefaultanim) {
  if (triggereddefaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete triggereddefaultanim_;
  }
  if (triggereddefaultanim) {
    set_has_triggereddefaultanim();
    triggereddefaultanim_ = triggereddefaultanim;
  } else {
    clear_has_triggereddefaultanim();
    triggereddefaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.TriggeredDefaultAnim)
}

// optional string SortingLayer = 11;
inline bool TreasureBox::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TreasureBox::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TreasureBox::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TreasureBox::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& TreasureBox::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.SortingLayer)
  return *sortinglayer_;
}
inline void TreasureBox::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TreasureBox.SortingLayer)
}
inline void TreasureBox::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TreasureBox.SortingLayer)
}
inline void TreasureBox::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TreasureBox.SortingLayer)
}
inline ::std::string* TreasureBox::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TreasureBox.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* TreasureBox::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TreasureBox::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TreasureBox.SortingLayer)
}

// optional int32 SortingOrder = 12;
inline bool TreasureBox::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TreasureBox::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TreasureBox::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TreasureBox::clear_sortingorder() {
  sortingorder_ = 0;
  clear_has_sortingorder();
}
inline ::google::protobuf::int32 TreasureBox::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.SortingOrder)
  return sortingorder_;
}
inline void TreasureBox::set_sortingorder(::google::protobuf::int32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.TreasureBox.SortingOrder)
}

// optional bool DelAfterReceive = 13;
inline bool TreasureBox::has_delafterreceive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TreasureBox::set_has_delafterreceive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TreasureBox::clear_has_delafterreceive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TreasureBox::clear_delafterreceive() {
  delafterreceive_ = false;
  clear_has_delafterreceive();
}
inline bool TreasureBox::delafterreceive() const {
  // @@protoc_insertion_point(field_get:pb.TreasureBox.DelAfterReceive)
  return delafterreceive_;
}
inline void TreasureBox::set_delafterreceive(bool value) {
  set_has_delafterreceive();
  delafterreceive_ = value;
  // @@protoc_insertion_point(field_set:pb.TreasureBox.DelAfterReceive)
}

// -------------------------------------------------------------------

// InteracteSceneUI

// optional string Name = 1;
inline bool InteracteSceneUI::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InteracteSceneUI::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InteracteSceneUI::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InteracteSceneUI::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InteracteSceneUI::name() const {
  // @@protoc_insertion_point(field_get:pb.InteracteSceneUI.Name)
  return *name_;
}
inline void InteracteSceneUI::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.InteracteSceneUI.Name)
}
inline void InteracteSceneUI::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.InteracteSceneUI.Name)
}
inline void InteracteSceneUI::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.InteracteSceneUI.Name)
}
inline ::std::string* InteracteSceneUI::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.InteracteSceneUI.Name)
  return name_;
}
inline ::std::string* InteracteSceneUI::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InteracteSceneUI::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.InteracteSceneUI.Name)
}

// optional .pb.PbVector2 Position = 2;
inline bool InteracteSceneUI::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InteracteSceneUI::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InteracteSceneUI::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InteracteSceneUI::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& InteracteSceneUI::position() const {
  // @@protoc_insertion_point(field_get:pb.InteracteSceneUI.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* InteracteSceneUI::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.InteracteSceneUI.Position)
  return position_;
}
inline ::pb::PbVector2* InteracteSceneUI::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void InteracteSceneUI::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.InteracteSceneUI.Position)
}

// optional .pb.PbVector2 Scale = 3;
inline bool InteracteSceneUI::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InteracteSceneUI::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InteracteSceneUI::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InteracteSceneUI::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector2::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector2& InteracteSceneUI::scale() const {
  // @@protoc_insertion_point(field_get:pb.InteracteSceneUI.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector2* InteracteSceneUI::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.InteracteSceneUI.Scale)
  return scale_;
}
inline ::pb::PbVector2* InteracteSceneUI::release_scale() {
  clear_has_scale();
  ::pb::PbVector2* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void InteracteSceneUI::set_allocated_scale(::pb::PbVector2* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.InteracteSceneUI.Scale)
}

// optional string AssetPath = 4;
inline bool InteracteSceneUI::has_assetpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InteracteSceneUI::set_has_assetpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InteracteSceneUI::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InteracteSceneUI::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& InteracteSceneUI::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.InteracteSceneUI.AssetPath)
  return *assetpath_;
}
inline void InteracteSceneUI::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.InteracteSceneUI.AssetPath)
}
inline void InteracteSceneUI::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.InteracteSceneUI.AssetPath)
}
inline void InteracteSceneUI::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.InteracteSceneUI.AssetPath)
}
inline ::std::string* InteracteSceneUI::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.InteracteSceneUI.AssetPath)
  return assetpath_;
}
inline ::std::string* InteracteSceneUI::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InteracteSceneUI::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.InteracteSceneUI.AssetPath)
}

// optional .pb.PbRect RectInfo = 5;
inline bool InteracteSceneUI::has_rectinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InteracteSceneUI::set_has_rectinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InteracteSceneUI::clear_has_rectinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InteracteSceneUI::clear_rectinfo() {
  if (rectinfo_ != NULL) rectinfo_->::pb::PbRect::Clear();
  clear_has_rectinfo();
}
inline const ::pb::PbRect& InteracteSceneUI::rectinfo() const {
  // @@protoc_insertion_point(field_get:pb.InteracteSceneUI.RectInfo)
  return rectinfo_ != NULL ? *rectinfo_ : *default_instance_->rectinfo_;
}
inline ::pb::PbRect* InteracteSceneUI::mutable_rectinfo() {
  set_has_rectinfo();
  if (rectinfo_ == NULL) rectinfo_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.InteracteSceneUI.RectInfo)
  return rectinfo_;
}
inline ::pb::PbRect* InteracteSceneUI::release_rectinfo() {
  clear_has_rectinfo();
  ::pb::PbRect* temp = rectinfo_;
  rectinfo_ = NULL;
  return temp;
}
inline void InteracteSceneUI::set_allocated_rectinfo(::pb::PbRect* rectinfo) {
  delete rectinfo_;
  rectinfo_ = rectinfo;
  if (rectinfo) {
    set_has_rectinfo();
  } else {
    clear_has_rectinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.InteracteSceneUI.RectInfo)
}

// -------------------------------------------------------------------

// WarMisty

// optional float UniformScale = 1;
inline bool WarMisty::has_uniformscale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarMisty::set_has_uniformscale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarMisty::clear_has_uniformscale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarMisty::clear_uniformscale() {
  uniformscale_ = 0;
  clear_has_uniformscale();
}
inline float WarMisty::uniformscale() const {
  // @@protoc_insertion_point(field_get:pb.WarMisty.UniformScale)
  return uniformscale_;
}
inline void WarMisty::set_uniformscale(float value) {
  set_has_uniformscale();
  uniformscale_ = value;
  // @@protoc_insertion_point(field_set:pb.WarMisty.UniformScale)
}

// optional .pb.PbVector2 Position = 2;
inline bool WarMisty::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarMisty::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WarMisty::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WarMisty::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& WarMisty::position() const {
  // @@protoc_insertion_point(field_get:pb.WarMisty.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* WarMisty::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.WarMisty.Position)
  return position_;
}
inline ::pb::PbVector2* WarMisty::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void WarMisty::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.WarMisty.Position)
}

// optional uint32 AssetPathIndex = 3;
inline bool WarMisty::has_assetpathindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WarMisty::set_has_assetpathindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WarMisty::clear_has_assetpathindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WarMisty::clear_assetpathindex() {
  assetpathindex_ = 0u;
  clear_has_assetpathindex();
}
inline ::google::protobuf::uint32 WarMisty::assetpathindex() const {
  // @@protoc_insertion_point(field_get:pb.WarMisty.AssetPathIndex)
  return assetpathindex_;
}
inline void WarMisty::set_assetpathindex(::google::protobuf::uint32 value) {
  set_has_assetpathindex();
  assetpathindex_ = value;
  // @@protoc_insertion_point(field_set:pb.WarMisty.AssetPathIndex)
}

// -------------------------------------------------------------------

// WarMistyArea

// optional string Name = 1;
inline bool WarMistyArea::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarMistyArea::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarMistyArea::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarMistyArea::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WarMistyArea::name() const {
  // @@protoc_insertion_point(field_get:pb.WarMistyArea.Name)
  return *name_;
}
inline void WarMistyArea::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.WarMistyArea.Name)
}
inline void WarMistyArea::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.WarMistyArea.Name)
}
inline void WarMistyArea::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.WarMistyArea.Name)
}
inline ::std::string* WarMistyArea::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.WarMistyArea.Name)
  return name_;
}
inline ::std::string* WarMistyArea::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WarMistyArea::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.WarMistyArea.Name)
}

// repeated .pb.WarMisty WarMistyArr = 2;
inline int WarMistyArea::warmistyarr_size() const {
  return warmistyarr_.size();
}
inline void WarMistyArea::clear_warmistyarr() {
  warmistyarr_.Clear();
}
inline const ::pb::WarMisty& WarMistyArea::warmistyarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.WarMistyArea.WarMistyArr)
  return warmistyarr_.Get(index);
}
inline ::pb::WarMisty* WarMistyArea::mutable_warmistyarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.WarMistyArea.WarMistyArr)
  return warmistyarr_.Mutable(index);
}
inline ::pb::WarMisty* WarMistyArea::add_warmistyarr() {
  // @@protoc_insertion_point(field_add:pb.WarMistyArea.WarMistyArr)
  return warmistyarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::WarMisty >&
WarMistyArea::warmistyarr() const {
  // @@protoc_insertion_point(field_list:pb.WarMistyArea.WarMistyArr)
  return warmistyarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::WarMisty >*
WarMistyArea::mutable_warmistyarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.WarMistyArea.WarMistyArr)
  return &warmistyarr_;
}

// optional bool Visible = 3;
inline bool WarMistyArea::has_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WarMistyArea::set_has_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WarMistyArea::clear_has_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WarMistyArea::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool WarMistyArea::visible() const {
  // @@protoc_insertion_point(field_get:pb.WarMistyArea.Visible)
  return visible_;
}
inline void WarMistyArea::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.WarMistyArea.Visible)
}

// optional string SortingLayer = 4;
inline bool WarMistyArea::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WarMistyArea::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WarMistyArea::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WarMistyArea::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& WarMistyArea::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.WarMistyArea.SortingLayer)
  return *sortinglayer_;
}
inline void WarMistyArea::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.WarMistyArea.SortingLayer)
}
inline void WarMistyArea::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.WarMistyArea.SortingLayer)
}
inline void WarMistyArea::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.WarMistyArea.SortingLayer)
}
inline ::std::string* WarMistyArea::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.WarMistyArea.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* WarMistyArea::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WarMistyArea::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.WarMistyArea.SortingLayer)
}

// optional int32 SortingOrder = 5;
inline bool WarMistyArea::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WarMistyArea::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WarMistyArea::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WarMistyArea::clear_sortingorder() {
  sortingorder_ = 0;
  clear_has_sortingorder();
}
inline ::google::protobuf::int32 WarMistyArea::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.WarMistyArea.SortingOrder)
  return sortingorder_;
}
inline void WarMistyArea::set_sortingorder(::google::protobuf::int32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.WarMistyArea.SortingOrder)
}

// -------------------------------------------------------------------

// TaskNpc

// optional string Name = 1;
inline bool TaskNpc::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskNpc::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskNpc::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskNpc::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskNpc::name() const {
  // @@protoc_insertion_point(field_get:pb.TaskNpc.Name)
  return *name_;
}
inline void TaskNpc::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TaskNpc.Name)
}
inline void TaskNpc::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskNpc.Name)
}
inline void TaskNpc::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskNpc.Name)
}
inline ::std::string* TaskNpc::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TaskNpc.Name)
  return name_;
}
inline ::std::string* TaskNpc::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskNpc::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskNpc.Name)
}

// optional .pb.PbVector2 Position = 2;
inline bool TaskNpc::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskNpc::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskNpc::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskNpc::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& TaskNpc::position() const {
  // @@protoc_insertion_point(field_get:pb.TaskNpc.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* TaskNpc::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.TaskNpc.Position)
  return position_;
}
inline ::pb::PbVector2* TaskNpc::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void TaskNpc::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskNpc.Position)
}

// optional .pb.PbRect RectInfo = 3;
inline bool TaskNpc::has_rectinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskNpc::set_has_rectinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskNpc::clear_has_rectinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskNpc::clear_rectinfo() {
  if (rectinfo_ != NULL) rectinfo_->::pb::PbRect::Clear();
  clear_has_rectinfo();
}
inline const ::pb::PbRect& TaskNpc::rectinfo() const {
  // @@protoc_insertion_point(field_get:pb.TaskNpc.RectInfo)
  return rectinfo_ != NULL ? *rectinfo_ : *default_instance_->rectinfo_;
}
inline ::pb::PbRect* TaskNpc::mutable_rectinfo() {
  set_has_rectinfo();
  if (rectinfo_ == NULL) rectinfo_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.TaskNpc.RectInfo)
  return rectinfo_;
}
inline ::pb::PbRect* TaskNpc::release_rectinfo() {
  clear_has_rectinfo();
  ::pb::PbRect* temp = rectinfo_;
  rectinfo_ = NULL;
  return temp;
}
inline void TaskNpc::set_allocated_rectinfo(::pb::PbRect* rectinfo) {
  delete rectinfo_;
  rectinfo_ = rectinfo;
  if (rectinfo) {
    set_has_rectinfo();
  } else {
    clear_has_rectinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskNpc.RectInfo)
}

// optional string ViewElementName = 4;
inline bool TaskNpc::has_viewelementname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskNpc::set_has_viewelementname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskNpc::clear_has_viewelementname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskNpc::clear_viewelementname() {
  if (viewelementname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_->clear();
  }
  clear_has_viewelementname();
}
inline const ::std::string& TaskNpc::viewelementname() const {
  // @@protoc_insertion_point(field_get:pb.TaskNpc.ViewElementName)
  return *viewelementname_;
}
inline void TaskNpc::set_viewelementname(const ::std::string& value) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TaskNpc.ViewElementName)
}
inline void TaskNpc::set_viewelementname(const char* value) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskNpc.ViewElementName)
}
inline void TaskNpc::set_viewelementname(const char* value, size_t size) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskNpc.ViewElementName)
}
inline ::std::string* TaskNpc::mutable_viewelementname() {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TaskNpc.ViewElementName)
  return viewelementname_;
}
inline ::std::string* TaskNpc::release_viewelementname() {
  clear_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = viewelementname_;
    viewelementname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskNpc::set_allocated_viewelementname(::std::string* viewelementname) {
  if (viewelementname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete viewelementname_;
  }
  if (viewelementname) {
    set_has_viewelementname();
    viewelementname_ = viewelementname;
  } else {
    clear_has_viewelementname();
    viewelementname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskNpc.ViewElementName)
}

// optional .pb.ESceneElementType ViewElementType = 5;
inline bool TaskNpc::has_viewelementtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskNpc::set_has_viewelementtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskNpc::clear_has_viewelementtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskNpc::clear_viewelementtype() {
  viewelementtype_ = 1;
  clear_has_viewelementtype();
}
inline ::pb::ESceneElementType TaskNpc::viewelementtype() const {
  // @@protoc_insertion_point(field_get:pb.TaskNpc.ViewElementType)
  return static_cast< ::pb::ESceneElementType >(viewelementtype_);
}
inline void TaskNpc::set_viewelementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_viewelementtype();
  viewelementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskNpc.ViewElementType)
}

// -------------------------------------------------------------------

// MapInfo

// optional int32 MapSceneType = 1;
inline bool MapInfo::has_mapscenetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapInfo::set_has_mapscenetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapInfo::clear_has_mapscenetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapInfo::clear_mapscenetype() {
  mapscenetype_ = 0;
  clear_has_mapscenetype();
}
inline ::google::protobuf::int32 MapInfo::mapscenetype() const {
  // @@protoc_insertion_point(field_get:pb.MapInfo.MapSceneType)
  return mapscenetype_;
}
inline void MapInfo::set_mapscenetype(::google::protobuf::int32 value) {
  set_has_mapscenetype();
  mapscenetype_ = value;
  // @@protoc_insertion_point(field_set:pb.MapInfo.MapSceneType)
}

// optional string MapSceneName = 2;
inline bool MapInfo::has_mapscenename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapInfo::set_has_mapscenename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapInfo::clear_has_mapscenename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapInfo::clear_mapscenename() {
  if (mapscenename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapscenename_->clear();
  }
  clear_has_mapscenename();
}
inline const ::std::string& MapInfo::mapscenename() const {
  // @@protoc_insertion_point(field_get:pb.MapInfo.MapSceneName)
  return *mapscenename_;
}
inline void MapInfo::set_mapscenename(const ::std::string& value) {
  set_has_mapscenename();
  if (mapscenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapscenename_ = new ::std::string;
  }
  mapscenename_->assign(value);
  // @@protoc_insertion_point(field_set:pb.MapInfo.MapSceneName)
}
inline void MapInfo::set_mapscenename(const char* value) {
  set_has_mapscenename();
  if (mapscenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapscenename_ = new ::std::string;
  }
  mapscenename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.MapInfo.MapSceneName)
}
inline void MapInfo::set_mapscenename(const char* value, size_t size) {
  set_has_mapscenename();
  if (mapscenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapscenename_ = new ::std::string;
  }
  mapscenename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.MapInfo.MapSceneName)
}
inline ::std::string* MapInfo::mutable_mapscenename() {
  set_has_mapscenename();
  if (mapscenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapscenename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.MapInfo.MapSceneName)
  return mapscenename_;
}
inline ::std::string* MapInfo::release_mapscenename() {
  clear_has_mapscenename();
  if (mapscenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapscenename_;
    mapscenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapInfo::set_allocated_mapscenename(::std::string* mapscenename) {
  if (mapscenename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapscenename_;
  }
  if (mapscenename) {
    set_has_mapscenename();
    mapscenename_ = mapscenename;
  } else {
    clear_has_mapscenename();
    mapscenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.MapInfo.MapSceneName)
}

// -------------------------------------------------------------------

// SceneConfInstance

// required int32 Id = 1;
inline bool SceneConfInstance::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneConfInstance::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneConfInstance::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneConfInstance::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SceneConfInstance::id() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.Id)
  return id_;
}
inline void SceneConfInstance::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.SceneConfInstance.Id)
}

// required string ConfName = 2;
inline bool SceneConfInstance::has_confname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneConfInstance::set_has_confname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneConfInstance::clear_has_confname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneConfInstance::clear_confname() {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& SceneConfInstance::confname() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.ConfName)
  return *confname_;
}
inline void SceneConfInstance::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConfInstance.ConfName)
}
inline void SceneConfInstance::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfInstance.ConfName)
}
inline void SceneConfInstance::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfInstance.ConfName)
}
inline ::std::string* SceneConfInstance::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.ConfName)
  return confname_;
}
inline ::std::string* SceneConfInstance::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConfInstance::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfInstance.ConfName)
}

// optional .pb.MapInfo MapInfo = 3;
inline bool SceneConfInstance::has_mapinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneConfInstance::set_has_mapinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneConfInstance::clear_has_mapinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneConfInstance::clear_mapinfo() {
  if (mapinfo_ != NULL) mapinfo_->::pb::MapInfo::Clear();
  clear_has_mapinfo();
}
inline const ::pb::MapInfo& SceneConfInstance::mapinfo() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.MapInfo)
  return mapinfo_ != NULL ? *mapinfo_ : *default_instance_->mapinfo_;
}
inline ::pb::MapInfo* SceneConfInstance::mutable_mapinfo() {
  set_has_mapinfo();
  if (mapinfo_ == NULL) mapinfo_ = new ::pb::MapInfo;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.MapInfo)
  return mapinfo_;
}
inline ::pb::MapInfo* SceneConfInstance::release_mapinfo() {
  clear_has_mapinfo();
  ::pb::MapInfo* temp = mapinfo_;
  mapinfo_ = NULL;
  return temp;
}
inline void SceneConfInstance::set_allocated_mapinfo(::pb::MapInfo* mapinfo) {
  delete mapinfo_;
  mapinfo_ = mapinfo;
  if (mapinfo) {
    set_has_mapinfo();
  } else {
    clear_has_mapinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfInstance.MapInfo)
}

// required .pb.SceneChunkInfo ChunkInfo = 4;
inline bool SceneConfInstance::has_chunkinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneConfInstance::set_has_chunkinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneConfInstance::clear_has_chunkinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneConfInstance::clear_chunkinfo() {
  if (chunkinfo_ != NULL) chunkinfo_->::pb::SceneChunkInfo::Clear();
  clear_has_chunkinfo();
}
inline const ::pb::SceneChunkInfo& SceneConfInstance::chunkinfo() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.ChunkInfo)
  return chunkinfo_ != NULL ? *chunkinfo_ : *default_instance_->chunkinfo_;
}
inline ::pb::SceneChunkInfo* SceneConfInstance::mutable_chunkinfo() {
  set_has_chunkinfo();
  if (chunkinfo_ == NULL) chunkinfo_ = new ::pb::SceneChunkInfo;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.ChunkInfo)
  return chunkinfo_;
}
inline ::pb::SceneChunkInfo* SceneConfInstance::release_chunkinfo() {
  clear_has_chunkinfo();
  ::pb::SceneChunkInfo* temp = chunkinfo_;
  chunkinfo_ = NULL;
  return temp;
}
inline void SceneConfInstance::set_allocated_chunkinfo(::pb::SceneChunkInfo* chunkinfo) {
  delete chunkinfo_;
  chunkinfo_ = chunkinfo;
  if (chunkinfo) {
    set_has_chunkinfo();
  } else {
    clear_has_chunkinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfInstance.ChunkInfo)
}

// repeated .pb.PointElement2 PointElementArr = 5;
inline int SceneConfInstance::pointelementarr_size() const {
  return pointelementarr_.size();
}
inline void SceneConfInstance::clear_pointelementarr() {
  pointelementarr_.Clear();
}
inline const ::pb::PointElement2& SceneConfInstance::pointelementarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.PointElementArr)
  return pointelementarr_.Get(index);
}
inline ::pb::PointElement2* SceneConfInstance::mutable_pointelementarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.PointElementArr)
  return pointelementarr_.Mutable(index);
}
inline ::pb::PointElement2* SceneConfInstance::add_pointelementarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.PointElementArr)
  return pointelementarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >&
SceneConfInstance::pointelementarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.PointElementArr)
  return pointelementarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >*
SceneConfInstance::mutable_pointelementarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.PointElementArr)
  return &pointelementarr_;
}

// required .pb.PbRect CameraMoveArea = 6;
inline bool SceneConfInstance::has_cameramovearea() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SceneConfInstance::set_has_cameramovearea() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SceneConfInstance::clear_has_cameramovearea() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SceneConfInstance::clear_cameramovearea() {
  if (cameramovearea_ != NULL) cameramovearea_->::pb::PbRect::Clear();
  clear_has_cameramovearea();
}
inline const ::pb::PbRect& SceneConfInstance::cameramovearea() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.CameraMoveArea)
  return cameramovearea_ != NULL ? *cameramovearea_ : *default_instance_->cameramovearea_;
}
inline ::pb::PbRect* SceneConfInstance::mutable_cameramovearea() {
  set_has_cameramovearea();
  if (cameramovearea_ == NULL) cameramovearea_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.CameraMoveArea)
  return cameramovearea_;
}
inline ::pb::PbRect* SceneConfInstance::release_cameramovearea() {
  clear_has_cameramovearea();
  ::pb::PbRect* temp = cameramovearea_;
  cameramovearea_ = NULL;
  return temp;
}
inline void SceneConfInstance::set_allocated_cameramovearea(::pb::PbRect* cameramovearea) {
  delete cameramovearea_;
  cameramovearea_ = cameramovearea;
  if (cameramovearea) {
    set_has_cameramovearea();
  } else {
    clear_has_cameramovearea();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfInstance.CameraMoveArea)
}

// repeated .pb.RectArea2 RectAreaArr = 7;
inline int SceneConfInstance::rectareaarr_size() const {
  return rectareaarr_.size();
}
inline void SceneConfInstance::clear_rectareaarr() {
  rectareaarr_.Clear();
}
inline const ::pb::RectArea2& SceneConfInstance::rectareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.RectAreaArr)
  return rectareaarr_.Get(index);
}
inline ::pb::RectArea2* SceneConfInstance::mutable_rectareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.RectAreaArr)
  return rectareaarr_.Mutable(index);
}
inline ::pb::RectArea2* SceneConfInstance::add_rectareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.RectAreaArr)
  return rectareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >&
SceneConfInstance::rectareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.RectAreaArr)
  return rectareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >*
SceneConfInstance::mutable_rectareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.RectAreaArr)
  return &rectareaarr_;
}

// repeated .pb.CustomArea2 CustomAreaArr = 8;
inline int SceneConfInstance::customareaarr_size() const {
  return customareaarr_.size();
}
inline void SceneConfInstance::clear_customareaarr() {
  customareaarr_.Clear();
}
inline const ::pb::CustomArea2& SceneConfInstance::customareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.CustomAreaArr)
  return customareaarr_.Get(index);
}
inline ::pb::CustomArea2* SceneConfInstance::mutable_customareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.CustomAreaArr)
  return customareaarr_.Mutable(index);
}
inline ::pb::CustomArea2* SceneConfInstance::add_customareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.CustomAreaArr)
  return customareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >&
SceneConfInstance::customareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.CustomAreaArr)
  return customareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >*
SceneConfInstance::mutable_customareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.CustomAreaArr)
  return &customareaarr_;
}

// repeated .pb.AnimAsset2 AnimAssetArr = 9;
inline int SceneConfInstance::animassetarr_size() const {
  return animassetarr_.size();
}
inline void SceneConfInstance::clear_animassetarr() {
  animassetarr_.Clear();
}
inline const ::pb::AnimAsset2& SceneConfInstance::animassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.AnimAssetArr)
  return animassetarr_.Get(index);
}
inline ::pb::AnimAsset2* SceneConfInstance::mutable_animassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.AnimAssetArr)
  return animassetarr_.Mutable(index);
}
inline ::pb::AnimAsset2* SceneConfInstance::add_animassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.AnimAssetArr)
  return animassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
SceneConfInstance::animassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.AnimAssetArr)
  return animassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
SceneConfInstance::mutable_animassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.AnimAssetArr)
  return &animassetarr_;
}

// repeated .pb.StaticAsset2 StaticAssetArr = 10;
inline int SceneConfInstance::staticassetarr_size() const {
  return staticassetarr_.size();
}
inline void SceneConfInstance::clear_staticassetarr() {
  staticassetarr_.Clear();
}
inline const ::pb::StaticAsset2& SceneConfInstance::staticassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.StaticAssetArr)
  return staticassetarr_.Get(index);
}
inline ::pb::StaticAsset2* SceneConfInstance::mutable_staticassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.StaticAssetArr)
  return staticassetarr_.Mutable(index);
}
inline ::pb::StaticAsset2* SceneConfInstance::add_staticassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.StaticAssetArr)
  return staticassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
SceneConfInstance::staticassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.StaticAssetArr)
  return staticassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
SceneConfInstance::mutable_staticassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.StaticAssetArr)
  return &staticassetarr_;
}

// repeated .pb.EffectAsset2 EffectAssetArr = 11;
inline int SceneConfInstance::effectassetarr_size() const {
  return effectassetarr_.size();
}
inline void SceneConfInstance::clear_effectassetarr() {
  effectassetarr_.Clear();
}
inline const ::pb::EffectAsset2& SceneConfInstance::effectassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.EffectAssetArr)
  return effectassetarr_.Get(index);
}
inline ::pb::EffectAsset2* SceneConfInstance::mutable_effectassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.EffectAssetArr)
  return effectassetarr_.Mutable(index);
}
inline ::pb::EffectAsset2* SceneConfInstance::add_effectassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.EffectAssetArr)
  return effectassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
SceneConfInstance::effectassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.EffectAssetArr)
  return effectassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
SceneConfInstance::mutable_effectassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.EffectAssetArr)
  return &effectassetarr_;
}

// repeated .pb.TreasureBox TreasureBoxArr = 12;
inline int SceneConfInstance::treasureboxarr_size() const {
  return treasureboxarr_.size();
}
inline void SceneConfInstance::clear_treasureboxarr() {
  treasureboxarr_.Clear();
}
inline const ::pb::TreasureBox& SceneConfInstance::treasureboxarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.TreasureBoxArr)
  return treasureboxarr_.Get(index);
}
inline ::pb::TreasureBox* SceneConfInstance::mutable_treasureboxarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.TreasureBoxArr)
  return treasureboxarr_.Mutable(index);
}
inline ::pb::TreasureBox* SceneConfInstance::add_treasureboxarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.TreasureBoxArr)
  return treasureboxarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TreasureBox >&
SceneConfInstance::treasureboxarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.TreasureBoxArr)
  return treasureboxarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TreasureBox >*
SceneConfInstance::mutable_treasureboxarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.TreasureBoxArr)
  return &treasureboxarr_;
}

// repeated .pb.WarMistyArea WarMistyAreaArr = 13;
inline int SceneConfInstance::warmistyareaarr_size() const {
  return warmistyareaarr_.size();
}
inline void SceneConfInstance::clear_warmistyareaarr() {
  warmistyareaarr_.Clear();
}
inline const ::pb::WarMistyArea& SceneConfInstance::warmistyareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.WarMistyAreaArr)
  return warmistyareaarr_.Get(index);
}
inline ::pb::WarMistyArea* SceneConfInstance::mutable_warmistyareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.WarMistyAreaArr)
  return warmistyareaarr_.Mutable(index);
}
inline ::pb::WarMistyArea* SceneConfInstance::add_warmistyareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.WarMistyAreaArr)
  return warmistyareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::WarMistyArea >&
SceneConfInstance::warmistyareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.WarMistyAreaArr)
  return warmistyareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::WarMistyArea >*
SceneConfInstance::mutable_warmistyareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.WarMistyAreaArr)
  return &warmistyareaarr_;
}

// repeated .pb.InteracteSceneUI InteracteSceneUIArr = 14;
inline int SceneConfInstance::interactesceneuiarr_size() const {
  return interactesceneuiarr_.size();
}
inline void SceneConfInstance::clear_interactesceneuiarr() {
  interactesceneuiarr_.Clear();
}
inline const ::pb::InteracteSceneUI& SceneConfInstance::interactesceneuiarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.InteracteSceneUIArr)
  return interactesceneuiarr_.Get(index);
}
inline ::pb::InteracteSceneUI* SceneConfInstance::mutable_interactesceneuiarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.InteracteSceneUIArr)
  return interactesceneuiarr_.Mutable(index);
}
inline ::pb::InteracteSceneUI* SceneConfInstance::add_interactesceneuiarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.InteracteSceneUIArr)
  return interactesceneuiarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::InteracteSceneUI >&
SceneConfInstance::interactesceneuiarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.InteracteSceneUIArr)
  return interactesceneuiarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::InteracteSceneUI >*
SceneConfInstance::mutable_interactesceneuiarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.InteracteSceneUIArr)
  return &interactesceneuiarr_;
}

// repeated .pb.PatrolPath2 PatrolPathArr = 15;
inline int SceneConfInstance::patrolpatharr_size() const {
  return patrolpatharr_.size();
}
inline void SceneConfInstance::clear_patrolpatharr() {
  patrolpatharr_.Clear();
}
inline const ::pb::PatrolPath2& SceneConfInstance::patrolpatharr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.PatrolPathArr)
  return patrolpatharr_.Get(index);
}
inline ::pb::PatrolPath2* SceneConfInstance::mutable_patrolpatharr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.PatrolPathArr)
  return patrolpatharr_.Mutable(index);
}
inline ::pb::PatrolPath2* SceneConfInstance::add_patrolpatharr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.PatrolPathArr)
  return patrolpatharr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >&
SceneConfInstance::patrolpatharr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.PatrolPathArr)
  return patrolpatharr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPath2 >*
SceneConfInstance::mutable_patrolpatharr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.PatrolPathArr)
  return &patrolpatharr_;
}

// repeated .pb.CarrierEnt2 CarrierEntArr = 16;
inline int SceneConfInstance::carrierentarr_size() const {
  return carrierentarr_.size();
}
inline void SceneConfInstance::clear_carrierentarr() {
  carrierentarr_.Clear();
}
inline const ::pb::CarrierEnt2& SceneConfInstance::carrierentarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.CarrierEntArr)
  return carrierentarr_.Get(index);
}
inline ::pb::CarrierEnt2* SceneConfInstance::mutable_carrierentarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.CarrierEntArr)
  return carrierentarr_.Mutable(index);
}
inline ::pb::CarrierEnt2* SceneConfInstance::add_carrierentarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.CarrierEntArr)
  return carrierentarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CarrierEnt2 >&
SceneConfInstance::carrierentarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.CarrierEntArr)
  return carrierentarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CarrierEnt2 >*
SceneConfInstance::mutable_carrierentarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.CarrierEntArr)
  return &carrierentarr_;
}

// repeated .pb.Obstacle ObstacleArr = 17;
inline int SceneConfInstance::obstaclearr_size() const {
  return obstaclearr_.size();
}
inline void SceneConfInstance::clear_obstaclearr() {
  obstaclearr_.Clear();
}
inline const ::pb::Obstacle& SceneConfInstance::obstaclearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.ObstacleArr)
  return obstaclearr_.Get(index);
}
inline ::pb::Obstacle* SceneConfInstance::mutable_obstaclearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.ObstacleArr)
  return obstaclearr_.Mutable(index);
}
inline ::pb::Obstacle* SceneConfInstance::add_obstaclearr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.ObstacleArr)
  return obstaclearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >&
SceneConfInstance::obstaclearr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.ObstacleArr)
  return obstaclearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >*
SceneConfInstance::mutable_obstaclearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.ObstacleArr)
  return &obstaclearr_;
}

// repeated string MistyAssetPathArr = 18;
inline int SceneConfInstance::mistyassetpatharr_size() const {
  return mistyassetpatharr_.size();
}
inline void SceneConfInstance::clear_mistyassetpatharr() {
  mistyassetpatharr_.Clear();
}
inline const ::std::string& SceneConfInstance::mistyassetpatharr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.MistyAssetPathArr)
  return mistyassetpatharr_.Get(index);
}
inline ::std::string* SceneConfInstance::mutable_mistyassetpatharr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.MistyAssetPathArr)
  return mistyassetpatharr_.Mutable(index);
}
inline void SceneConfInstance::set_mistyassetpatharr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.SceneConfInstance.MistyAssetPathArr)
  mistyassetpatharr_.Mutable(index)->assign(value);
}
inline void SceneConfInstance::set_mistyassetpatharr(int index, const char* value) {
  mistyassetpatharr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfInstance.MistyAssetPathArr)
}
inline void SceneConfInstance::set_mistyassetpatharr(int index, const char* value, size_t size) {
  mistyassetpatharr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfInstance.MistyAssetPathArr)
}
inline ::std::string* SceneConfInstance::add_mistyassetpatharr() {
  return mistyassetpatharr_.Add();
}
inline void SceneConfInstance::add_mistyassetpatharr(const ::std::string& value) {
  mistyassetpatharr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.MistyAssetPathArr)
}
inline void SceneConfInstance::add_mistyassetpatharr(const char* value) {
  mistyassetpatharr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.SceneConfInstance.MistyAssetPathArr)
}
inline void SceneConfInstance::add_mistyassetpatharr(const char* value, size_t size) {
  mistyassetpatharr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.SceneConfInstance.MistyAssetPathArr)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SceneConfInstance::mistyassetpatharr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.MistyAssetPathArr)
  return mistyassetpatharr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SceneConfInstance::mutable_mistyassetpatharr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.MistyAssetPathArr)
  return &mistyassetpatharr_;
}

// repeated .pb.TaskNpc TaskNpcArr = 19;
inline int SceneConfInstance::tasknpcarr_size() const {
  return tasknpcarr_.size();
}
inline void SceneConfInstance::clear_tasknpcarr() {
  tasknpcarr_.Clear();
}
inline const ::pb::TaskNpc& SceneConfInstance::tasknpcarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfInstance.TaskNpcArr)
  return tasknpcarr_.Get(index);
}
inline ::pb::TaskNpc* SceneConfInstance::mutable_tasknpcarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfInstance.TaskNpcArr)
  return tasknpcarr_.Mutable(index);
}
inline ::pb::TaskNpc* SceneConfInstance::add_tasknpcarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfInstance.TaskNpcArr)
  return tasknpcarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskNpc >&
SceneConfInstance::tasknpcarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfInstance.TaskNpcArr)
  return tasknpcarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TaskNpc >*
SceneConfInstance::mutable_tasknpcarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfInstance.TaskNpcArr)
  return &tasknpcarr_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fSceneConfInstance_2eproto__INCLUDED
