// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/AvatarData.proto

#ifndef PROTOBUF_module_2fAvatarData_2eproto__INCLUDED
#define PROTOBUF_module_2fAvatarData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/AudioDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fAvatarData_2eproto();
void protobuf_AssignDesc_module_2fAvatarData_2eproto();
void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

class AvatarVector3;
class EffectEvent;
class TriggerEvent;
class SocketPosition;
class SkillTriggerEvent;
class TSkillTriggerDeath;
class BlendShapeInfo;
class AnimData;
class AvatarData;

// ===================================================================

/*FOR2LUA
<Record>
	<name>AvatarVector3</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AvatarVector3 : public ::google::protobuf::Message {
 public:
  AvatarVector3();
  virtual ~AvatarVector3();

  AvatarVector3(const AvatarVector3& from);

  inline AvatarVector3& operator=(const AvatarVector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AvatarVector3& default_instance();

  void Swap(AvatarVector3* other);

  // implements Message ----------------------------------------------

  AvatarVector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AvatarVector3& from);
  void MergeFrom(const AvatarVector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 X = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AvatarVector3</name>
  	<Function>
  		<name>x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 Y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AvatarVector3</name>
  	<Function>
  		<name>y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 Z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AvatarVector3</name>
  	<Function>
  		<name>z</name>
  		<replaceName>Z</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_z</name>
  		<replaceName>Z</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_z</name>
  		<replaceName>Z</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.AvatarVector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static AvatarVector3* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>EffectEvent</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class EffectEvent : public ::google::protobuf::Message {
 public:
  EffectEvent();
  virtual ~EffectEvent();

  EffectEvent(const EffectEvent& from);

  inline EffectEvent& operator=(const EffectEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EffectEvent& default_instance();

  void Swap(EffectEvent* other);

  // implements Message ----------------------------------------------

  EffectEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EffectEvent& from);
  void MergeFrom(const EffectEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SocketName = 1;
  inline bool has_socketname() const;
  inline void clear_socketname();
  static const int kSocketNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>socketname</name>
  		<replaceName>SocketName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_socketname</name>
  		<replaceName>SocketName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_socketname</name>
  		<replaceName>SocketName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& socketname() const;
  inline void set_socketname(const ::std::string& value);
  inline void set_socketname(const char* value);
  inline void set_socketname(const char* value, size_t size);
  inline ::std::string* mutable_socketname();
  inline ::std::string* release_socketname();
  inline void set_allocated_socketname(::std::string* socketname);

  // required string EffectName = 2;
  inline bool has_effectname() const;
  inline void clear_effectname();
  static const int kEffectNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>effectname</name>
  		<replaceName>EffectName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effectname</name>
  		<replaceName>EffectName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectname</name>
  		<replaceName>EffectName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& effectname() const;
  inline void set_effectname(const ::std::string& value);
  inline void set_effectname(const char* value);
  inline void set_effectname(const char* value, size_t size);
  inline ::std::string* mutable_effectname();
  inline ::std::string* release_effectname();
  inline void set_allocated_effectname(::std::string* effectname);

  // required float StartTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float starttime() const;
  inline void set_starttime(float value);

  // required float EffectTimeLength = 4;
  inline bool has_effecttimelength() const;
  inline void clear_effecttimelength();
  static const int kEffectTimeLengthFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>effecttimelength</name>
  		<replaceName>EffectTimeLength</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effecttimelength</name>
  		<replaceName>EffectTimeLength</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effecttimelength</name>
  		<replaceName>EffectTimeLength</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float effecttimelength() const;
  inline void set_effecttimelength(float value);

  // required float EffectScale = 5;
  inline bool has_effectscale() const;
  inline void clear_effectscale();
  static const int kEffectScaleFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>effectscale</name>
  		<replaceName>EffectScale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effectscale</name>
  		<replaceName>EffectScale</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectscale</name>
  		<replaceName>EffectScale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float effectscale() const;
  inline void set_effectscale(float value);

  // required float EffectSpeed = 6;
  inline bool has_effectspeed() const;
  inline void clear_effectspeed();
  static const int kEffectSpeedFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>effectspeed</name>
  		<replaceName>EffectSpeed</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effectspeed</name>
  		<replaceName>EffectSpeed</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectspeed</name>
  		<replaceName>EffectSpeed</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float effectspeed() const;
  inline void set_effectspeed(float value);

  // required .pb.AvatarVector3 EffectPosition = 7;
  inline bool has_effectposition() const;
  inline void clear_effectposition();
  static const int kEffectPositionFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>effectposition</name>
  		<replaceName>EffectPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effectposition</name>
  		<replaceName>EffectPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_effectposition</name>
  		<replaceName>EffectPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectposition</name>
  		<replaceName>EffectPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AvatarVector3& effectposition() const;
  inline ::pb::AvatarVector3* mutable_effectposition();
  inline ::pb::AvatarVector3* release_effectposition();
  inline void set_allocated_effectposition(::pb::AvatarVector3* effectposition);

  // required .pb.AvatarVector3 EffectEulerAngles = 8;
  inline bool has_effecteulerangles() const;
  inline void clear_effecteulerangles();
  static const int kEffectEulerAnglesFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>effecteulerangles</name>
  		<replaceName>EffectEulerAngles</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effecteulerangles</name>
  		<replaceName>EffectEulerAngles</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_effecteulerangles</name>
  		<replaceName>EffectEulerAngles</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effecteulerangles</name>
  		<replaceName>EffectEulerAngles</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AvatarVector3& effecteulerangles() const;
  inline ::pb::AvatarVector3* mutable_effecteulerangles();
  inline ::pb::AvatarVector3* release_effecteulerangles();
  inline void set_allocated_effecteulerangles(::pb::AvatarVector3* effecteulerangles);

  // required float Loop = 9;
  inline bool has_loop() const;
  inline void clear_loop();
  static const int kLoopFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>loop</name>
  		<replaceName>Loop</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_loop</name>
  		<replaceName>Loop</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_loop</name>
  		<replaceName>Loop</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float loop() const;
  inline void set_loop(float value);

  // optional bool UseWorldPos = 10;
  inline bool has_useworldpos() const;
  inline void clear_useworldpos();
  static const int kUseWorldPosFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>EffectEvent</name>
  	<Function>
  		<name>useworldpos</name>
  		<replaceName>UseWorldPos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_useworldpos</name>
  		<replaceName>UseWorldPos</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_useworldpos</name>
  		<replaceName>UseWorldPos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool useworldpos() const;
  inline void set_useworldpos(bool value);

  // @@protoc_insertion_point(class_scope:pb.EffectEvent)
 private:
  inline void set_has_socketname();
  inline void clear_has_socketname();
  inline void set_has_effectname();
  inline void clear_has_effectname();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_effecttimelength();
  inline void clear_has_effecttimelength();
  inline void set_has_effectscale();
  inline void clear_has_effectscale();
  inline void set_has_effectspeed();
  inline void clear_has_effectspeed();
  inline void set_has_effectposition();
  inline void clear_has_effectposition();
  inline void set_has_effecteulerangles();
  inline void clear_has_effecteulerangles();
  inline void set_has_loop();
  inline void clear_has_loop();
  inline void set_has_useworldpos();
  inline void clear_has_useworldpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* socketname_;
  ::std::string* effectname_;
  float starttime_;
  float effecttimelength_;
  float effectscale_;
  float effectspeed_;
  ::pb::AvatarVector3* effectposition_;
  ::pb::AvatarVector3* effecteulerangles_;
  float loop_;
  bool useworldpos_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static EffectEvent* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TriggerEvent</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TriggerEvent : public ::google::protobuf::Message {
 public:
  TriggerEvent();
  virtual ~TriggerEvent();

  TriggerEvent(const TriggerEvent& from);

  inline TriggerEvent& operator=(const TriggerEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerEvent& default_instance();

  void Swap(TriggerEvent* other);

  // implements Message ----------------------------------------------

  TriggerEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerEvent& from);
  void MergeFrom(const TriggerEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double StartTime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TriggerEvent</name>
  	<Function>
  		<name>starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline double starttime() const;
  inline void set_starttime(double value);

  // required double TriggerLength = 3;
  inline bool has_triggerlength() const;
  inline void clear_triggerlength();
  static const int kTriggerLengthFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TriggerEvent</name>
  	<Function>
  		<name>triggerlength</name>
  		<replaceName>TriggerLength</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggerlength</name>
  		<replaceName>TriggerLength</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggerlength</name>
  		<replaceName>TriggerLength</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline double triggerlength() const;
  inline void set_triggerlength(double value);

  // required int32 TriggerType = 4;
  inline bool has_triggertype() const;
  inline void clear_triggertype();
  static const int kTriggerTypeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TriggerEvent</name>
  	<Function>
  		<name>triggertype</name>
  		<replaceName>TriggerType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggertype</name>
  		<replaceName>TriggerType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggertype</name>
  		<replaceName>TriggerType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 triggertype() const;
  inline void set_triggertype(::google::protobuf::int32 value);

  // repeated float TriggerParam = 5;
  inline int triggerparam_size() const;
  inline void clear_triggerparam();
  static const int kTriggerParamFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>TriggerEvent</name>
  	<Function>
  		<name>triggerparam</name>
  		<replaceName>TriggerParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_triggerparam</name>
  		<replaceName>TriggerParam</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_triggerparam</name>
  		<replaceName>TriggerParam</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggerparam</name>
  		<replaceName>TriggerParam</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>triggerparam_size</name>
  		<replaceName>TriggerParam</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float triggerparam(int index) const;
  inline void set_triggerparam(int index, float value);
  inline void add_triggerparam(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      triggerparam() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_triggerparam();

  // @@protoc_insertion_point(class_scope:pb.TriggerEvent)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_triggerlength();
  inline void clear_has_triggerlength();
  inline void set_has_triggertype();
  inline void clear_has_triggertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double starttime_;
  double triggerlength_;
  ::google::protobuf::RepeatedField< float > triggerparam_;
  ::google::protobuf::int32 triggertype_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static TriggerEvent* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SocketPosition</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SocketPosition : public ::google::protobuf::Message {
 public:
  SocketPosition();
  virtual ~SocketPosition();

  SocketPosition(const SocketPosition& from);

  inline SocketPosition& operator=(const SocketPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SocketPosition& default_instance();

  void Swap(SocketPosition* other);

  // implements Message ----------------------------------------------

  SocketPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SocketPosition& from);
  void MergeFrom(const SocketPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SocketName = 1;
  inline bool has_socketname() const;
  inline void clear_socketname();
  static const int kSocketNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SocketPosition</name>
  	<Function>
  		<name>socketname</name>
  		<replaceName>SocketName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_socketname</name>
  		<replaceName>SocketName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_socketname</name>
  		<replaceName>SocketName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& socketname() const;
  inline void set_socketname(const ::std::string& value);
  inline void set_socketname(const char* value);
  inline void set_socketname(const char* value, size_t size);
  inline ::std::string* mutable_socketname();
  inline ::std::string* release_socketname();
  inline void set_allocated_socketname(::std::string* socketname);

  // required .pb.AvatarVector3 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SocketPosition</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AvatarVector3& position() const;
  inline ::pb::AvatarVector3* mutable_position();
  inline ::pb::AvatarVector3* release_position();
  inline void set_allocated_position(::pb::AvatarVector3* position);

  // @@protoc_insertion_point(class_scope:pb.SocketPosition)
 private:
  inline void set_has_socketname();
  inline void clear_has_socketname();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* socketname_;
  ::pb::AvatarVector3* position_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static SocketPosition* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SkillTriggerEvent</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SkillTriggerEvent : public ::google::protobuf::Message {
 public:
  SkillTriggerEvent();
  virtual ~SkillTriggerEvent();

  SkillTriggerEvent(const SkillTriggerEvent& from);

  inline SkillTriggerEvent& operator=(const SkillTriggerEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillTriggerEvent& default_instance();

  void Swap(SkillTriggerEvent* other);

  // implements Message ----------------------------------------------

  SkillTriggerEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillTriggerEvent& from);
  void MergeFrom(const SkillTriggerEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 StartTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SkillTriggerEvent</name>
  	<Function>
  		<name>starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);

  // repeated .pb.SocketPosition Positions = 2;
  inline int positions_size() const;
  inline void clear_positions();
  static const int kPositionsFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SkillTriggerEvent</name>
  	<Function>
  		<name>positions</name>
  		<replaceName>Positions</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_positions</name>
  		<replaceName>Positions</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_positions</name>
  		<replaceName>Positions</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_positions</name>
  		<replaceName>Positions</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>positions_size</name>
  		<replaceName>Positions</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SocketPosition& positions(int index) const;
  inline ::pb::SocketPosition* mutable_positions(int index);
  inline ::pb::SocketPosition* add_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >&
      positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >*
      mutable_positions();

  // @@protoc_insertion_point(class_scope:pb.SkillTriggerEvent)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition > positions_;
  ::google::protobuf::int32 starttime_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static SkillTriggerEvent* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TSkillTriggerDeath</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TSkillTriggerDeath : public ::google::protobuf::Message {
 public:
  TSkillTriggerDeath();
  virtual ~TSkillTriggerDeath();

  TSkillTriggerDeath(const TSkillTriggerDeath& from);

  inline TSkillTriggerDeath& operator=(const TSkillTriggerDeath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSkillTriggerDeath& default_instance();

  void Swap(TSkillTriggerDeath* other);

  // implements Message ----------------------------------------------

  TSkillTriggerDeath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSkillTriggerDeath& from);
  void MergeFrom(const TSkillTriggerDeath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 StartTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TSkillTriggerDeath</name>
  	<Function>
  		<name>starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);

  // required string AnimName = 2;
  inline bool has_animname() const;
  inline void clear_animname();
  static const int kAnimNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TSkillTriggerDeath</name>
  	<Function>
  		<name>animname</name>
  		<replaceName>AnimName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_animname</name>
  		<replaceName>AnimName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animname</name>
  		<replaceName>AnimName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& animname() const;
  inline void set_animname(const ::std::string& value);
  inline void set_animname(const char* value);
  inline void set_animname(const char* value, size_t size);
  inline ::std::string* mutable_animname();
  inline ::std::string* release_animname();
  inline void set_allocated_animname(::std::string* animname);

  // repeated int32 SkillIdArr = 3;
  inline int skillidarr_size() const;
  inline void clear_skillidarr();
  static const int kSkillIdArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TSkillTriggerDeath</name>
  	<Function>
  		<name>skillidarr</name>
  		<replaceName>SkillIdArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_skillidarr</name>
  		<replaceName>SkillIdArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_skillidarr</name>
  		<replaceName>SkillIdArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_skillidarr</name>
  		<replaceName>SkillIdArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>skillidarr_size</name>
  		<replaceName>SkillIdArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 skillidarr(int index) const;
  inline void set_skillidarr(int index, ::google::protobuf::int32 value);
  inline void add_skillidarr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skillidarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skillidarr();

  // @@protoc_insertion_point(class_scope:pb.TSkillTriggerDeath)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_animname();
  inline void clear_has_animname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* animname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skillidarr_;
  ::google::protobuf::int32 starttime_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static TSkillTriggerDeath* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BlendShapeInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BlendShapeInfo : public ::google::protobuf::Message {
 public:
  BlendShapeInfo();
  virtual ~BlendShapeInfo();

  BlendShapeInfo(const BlendShapeInfo& from);

  inline BlendShapeInfo& operator=(const BlendShapeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlendShapeInfo& default_instance();

  void Swap(BlendShapeInfo* other);

  // implements Message ----------------------------------------------

  BlendShapeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlendShapeInfo& from);
  void MergeFrom(const BlendShapeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float StartTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starttime</name>
  		<replaceName>StartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float starttime() const;
  inline void set_starttime(float value);

  // required float FadeInTime = 4;
  inline bool has_fadeintime() const;
  inline void clear_fadeintime();
  static const int kFadeInTimeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>fadeintime</name>
  		<replaceName>FadeInTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fadeintime</name>
  		<replaceName>FadeInTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fadeintime</name>
  		<replaceName>FadeInTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fadeintime() const;
  inline void set_fadeintime(float value);

  // required float LastTime = 5;
  inline bool has_lasttime() const;
  inline void clear_lasttime();
  static const int kLastTimeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>lasttime</name>
  		<replaceName>LastTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_lasttime</name>
  		<replaceName>LastTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_lasttime</name>
  		<replaceName>LastTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float lasttime() const;
  inline void set_lasttime(float value);

  // required float FadeOutTime = 6;
  inline bool has_fadeouttime() const;
  inline void clear_fadeouttime();
  static const int kFadeOutTimeFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>fadeouttime</name>
  		<replaceName>FadeOutTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fadeouttime</name>
  		<replaceName>FadeOutTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fadeouttime</name>
  		<replaceName>FadeOutTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fadeouttime() const;
  inline void set_fadeouttime(float value);

  // required float FadeInBlendWeight = 7;
  inline bool has_fadeinblendweight() const;
  inline void clear_fadeinblendweight();
  static const int kFadeInBlendWeightFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>fadeinblendweight</name>
  		<replaceName>FadeInBlendWeight</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fadeinblendweight</name>
  		<replaceName>FadeInBlendWeight</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fadeinblendweight</name>
  		<replaceName>FadeInBlendWeight</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fadeinblendweight() const;
  inline void set_fadeinblendweight(float value);

  // required float LastBlendWeight = 8;
  inline bool has_lastblendweight() const;
  inline void clear_lastblendweight();
  static const int kLastBlendWeightFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>lastblendweight</name>
  		<replaceName>LastBlendWeight</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_lastblendweight</name>
  		<replaceName>LastBlendWeight</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_lastblendweight</name>
  		<replaceName>LastBlendWeight</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float lastblendweight() const;
  inline void set_lastblendweight(float value);

  // required float FadeOutBlendWeight = 9;
  inline bool has_fadeoutblendweight() const;
  inline void clear_fadeoutblendweight();
  static const int kFadeOutBlendWeightFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>fadeoutblendweight</name>
  		<replaceName>FadeOutBlendWeight</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fadeoutblendweight</name>
  		<replaceName>FadeOutBlendWeight</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fadeoutblendweight</name>
  		<replaceName>FadeOutBlendWeight</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fadeoutblendweight() const;
  inline void set_fadeoutblendweight(float value);

  // required int32 ShowCount = 10;
  inline bool has_showcount() const;
  inline void clear_showcount();
  static const int kShowCountFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>showcount</name>
  		<replaceName>ShowCount</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_showcount</name>
  		<replaceName>ShowCount</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_showcount</name>
  		<replaceName>ShowCount</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 showcount() const;
  inline void set_showcount(::google::protobuf::int32 value);

  // required int32 HideCount = 11;
  inline bool has_hidecount() const;
  inline void clear_hidecount();
  static const int kHideCountFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>BlendShapeInfo</name>
  	<Function>
  		<name>hidecount</name>
  		<replaceName>HideCount</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_hidecount</name>
  		<replaceName>HideCount</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_hidecount</name>
  		<replaceName>HideCount</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 hidecount() const;
  inline void set_hidecount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BlendShapeInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_fadeintime();
  inline void clear_has_fadeintime();
  inline void set_has_lasttime();
  inline void clear_has_lasttime();
  inline void set_has_fadeouttime();
  inline void clear_has_fadeouttime();
  inline void set_has_fadeinblendweight();
  inline void clear_has_fadeinblendweight();
  inline void set_has_lastblendweight();
  inline void clear_has_lastblendweight();
  inline void set_has_fadeoutblendweight();
  inline void clear_has_fadeoutblendweight();
  inline void set_has_showcount();
  inline void clear_has_showcount();
  inline void set_has_hidecount();
  inline void clear_has_hidecount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 index_;
  float starttime_;
  float fadeintime_;
  float lasttime_;
  float fadeouttime_;
  float fadeinblendweight_;
  float lastblendweight_;
  float fadeoutblendweight_;
  ::google::protobuf::int32 showcount_;
  ::google::protobuf::int32 hidecount_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static BlendShapeInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AnimData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AnimData : public ::google::protobuf::Message {
 public:
  AnimData();
  virtual ~AnimData();

  AnimData(const AnimData& from);

  inline AnimData& operator=(const AnimData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimData& default_instance();

  void Swap(AnimData* other);

  // implements Message ----------------------------------------------

  AnimData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimData& from);
  void MergeFrom(const AnimData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string AnimName = 1;
  inline bool has_animname() const;
  inline void clear_animname();
  static const int kAnimNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>animname</name>
  		<replaceName>AnimName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_animname</name>
  		<replaceName>AnimName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animname</name>
  		<replaceName>AnimName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& animname() const;
  inline void set_animname(const ::std::string& value);
  inline void set_animname(const char* value);
  inline void set_animname(const char* value, size_t size);
  inline ::std::string* mutable_animname();
  inline ::std::string* release_animname();
  inline void set_allocated_animname(::std::string* animname);

  // required int32 AnimTimeLength = 2;
  inline bool has_animtimelength() const;
  inline void clear_animtimelength();
  static const int kAnimTimeLengthFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>animtimelength</name>
  		<replaceName>AnimTimeLength</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_animtimelength</name>
  		<replaceName>AnimTimeLength</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animtimelength</name>
  		<replaceName>AnimTimeLength</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 animtimelength() const;
  inline void set_animtimelength(::google::protobuf::int32 value);

  // required int32 PauseEndEventTime = 4;
  inline bool has_pauseendeventtime() const;
  inline void clear_pauseendeventtime();
  static const int kPauseEndEventTimeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>pauseendeventtime</name>
  		<replaceName>PauseEndEventTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_pauseendeventtime</name>
  		<replaceName>PauseEndEventTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pauseendeventtime</name>
  		<replaceName>PauseEndEventTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 pauseendeventtime() const;
  inline void set_pauseendeventtime(::google::protobuf::int32 value);

  // repeated .pb.EffectEvent EffectEvents = 6;
  inline int effectevents_size() const;
  inline void clear_effectevents();
  static const int kEffectEventsFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>effectevents</name>
  		<replaceName>EffectEvents</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectevents</name>
  		<replaceName>EffectEvents</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectevents</name>
  		<replaceName>EffectEvents</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectevents</name>
  		<replaceName>EffectEvents</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectevents_size</name>
  		<replaceName>EffectEvents</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectEvent& effectevents(int index) const;
  inline ::pb::EffectEvent* mutable_effectevents(int index);
  inline ::pb::EffectEvent* add_effectevents();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectEvent >&
      effectevents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectEvent >*
      mutable_effectevents();

  // repeated .pb.AudioInfo AudioInfoArr = 7;
  inline int audioinfoarr_size() const;
  inline void clear_audioinfoarr();
  static const int kAudioInfoArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>audioinfoarr</name>
  		<replaceName>AudioInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_audioinfoarr</name>
  		<replaceName>AudioInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_audioinfoarr</name>
  		<replaceName>AudioInfoArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_audioinfoarr</name>
  		<replaceName>AudioInfoArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>audioinfoarr_size</name>
  		<replaceName>AudioInfoArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AudioInfo& audioinfoarr(int index) const;
  inline ::pb::AudioInfo* mutable_audioinfoarr(int index);
  inline ::pb::AudioInfo* add_audioinfoarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AudioInfo >&
      audioinfoarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AudioInfo >*
      mutable_audioinfoarr();

  // repeated .pb.TriggerEvent TriggerEvents = 8;
  inline int triggerevents_size() const;
  inline void clear_triggerevents();
  static const int kTriggerEventsFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>triggerevents</name>
  		<replaceName>TriggerEvents</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_triggerevents</name>
  		<replaceName>TriggerEvents</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_triggerevents</name>
  		<replaceName>TriggerEvents</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggerevents</name>
  		<replaceName>TriggerEvents</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>triggerevents_size</name>
  		<replaceName>TriggerEvents</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TriggerEvent& triggerevents(int index) const;
  inline ::pb::TriggerEvent* mutable_triggerevents(int index);
  inline ::pb::TriggerEvent* add_triggerevents();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TriggerEvent >&
      triggerevents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TriggerEvent >*
      mutable_triggerevents();

  // repeated .pb.SkillTriggerEvent SkillTriggerEvents = 9;
  inline int skilltriggerevents_size() const;
  inline void clear_skilltriggerevents();
  static const int kSkillTriggerEventsFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>skilltriggerevents</name>
  		<replaceName>SkillTriggerEvents</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_skilltriggerevents</name>
  		<replaceName>SkillTriggerEvents</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_skilltriggerevents</name>
  		<replaceName>SkillTriggerEvents</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_skilltriggerevents</name>
  		<replaceName>SkillTriggerEvents</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>skilltriggerevents_size</name>
  		<replaceName>SkillTriggerEvents</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SkillTriggerEvent& skilltriggerevents(int index) const;
  inline ::pb::SkillTriggerEvent* mutable_skilltriggerevents(int index);
  inline ::pb::SkillTriggerEvent* add_skilltriggerevents();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::SkillTriggerEvent >&
      skilltriggerevents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::SkillTriggerEvent >*
      mutable_skilltriggerevents();

  // repeated .pb.BlendShapeInfo BlendShapeInfoList = 10;
  inline int blendshapeinfolist_size() const;
  inline void clear_blendshapeinfolist();
  static const int kBlendShapeInfoListFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>blendshapeinfolist</name>
  		<replaceName>BlendShapeInfoList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_blendshapeinfolist</name>
  		<replaceName>BlendShapeInfoList</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_blendshapeinfolist</name>
  		<replaceName>BlendShapeInfoList</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_blendshapeinfolist</name>
  		<replaceName>BlendShapeInfoList</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>blendshapeinfolist_size</name>
  		<replaceName>BlendShapeInfoList</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BlendShapeInfo& blendshapeinfolist(int index) const;
  inline ::pb::BlendShapeInfo* mutable_blendshapeinfolist(int index);
  inline ::pb::BlendShapeInfo* add_blendshapeinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BlendShapeInfo >&
      blendshapeinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BlendShapeInfo >*
      mutable_blendshapeinfolist();

  // repeated .pb.SocketPosition InitSocketPosition = 11;
  inline int initsocketposition_size() const;
  inline void clear_initsocketposition();
  static const int kInitSocketPositionFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>initsocketposition</name>
  		<replaceName>InitSocketPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_initsocketposition</name>
  		<replaceName>InitSocketPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_initsocketposition</name>
  		<replaceName>InitSocketPosition</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_initsocketposition</name>
  		<replaceName>InitSocketPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>initsocketposition_size</name>
  		<replaceName>InitSocketPosition</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SocketPosition& initsocketposition(int index) const;
  inline ::pb::SocketPosition* mutable_initsocketposition(int index);
  inline ::pb::SocketPosition* add_initsocketposition();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >&
      initsocketposition() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >*
      mutable_initsocketposition();

  // repeated .pb.TSkillTriggerDeath SkillTriggerDeath = 12;
  inline int skilltriggerdeath_size() const;
  inline void clear_skilltriggerdeath();
  static const int kSkillTriggerDeathFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>AnimData</name>
  	<Function>
  		<name>skilltriggerdeath</name>
  		<replaceName>SkillTriggerDeath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_skilltriggerdeath</name>
  		<replaceName>SkillTriggerDeath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_skilltriggerdeath</name>
  		<replaceName>SkillTriggerDeath</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_skilltriggerdeath</name>
  		<replaceName>SkillTriggerDeath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>skilltriggerdeath_size</name>
  		<replaceName>SkillTriggerDeath</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TSkillTriggerDeath& skilltriggerdeath(int index) const;
  inline ::pb::TSkillTriggerDeath* mutable_skilltriggerdeath(int index);
  inline ::pb::TSkillTriggerDeath* add_skilltriggerdeath();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TSkillTriggerDeath >&
      skilltriggerdeath() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TSkillTriggerDeath >*
      mutable_skilltriggerdeath();

  // @@protoc_insertion_point(class_scope:pb.AnimData)
 private:
  inline void set_has_animname();
  inline void clear_has_animname();
  inline void set_has_animtimelength();
  inline void clear_has_animtimelength();
  inline void set_has_pauseendeventtime();
  inline void clear_has_pauseendeventtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* animname_;
  ::google::protobuf::int32 animtimelength_;
  ::google::protobuf::int32 pauseendeventtime_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectEvent > effectevents_;
  ::google::protobuf::RepeatedPtrField< ::pb::AudioInfo > audioinfoarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::TriggerEvent > triggerevents_;
  ::google::protobuf::RepeatedPtrField< ::pb::SkillTriggerEvent > skilltriggerevents_;
  ::google::protobuf::RepeatedPtrField< ::pb::BlendShapeInfo > blendshapeinfolist_;
  ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition > initsocketposition_;
  ::google::protobuf::RepeatedPtrField< ::pb::TSkillTriggerDeath > skilltriggerdeath_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static AnimData* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AvatarData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AvatarData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AvatarData : public ::google::protobuf::Message {
 public:
  AvatarData();
  virtual ~AvatarData();

  AvatarData(const AvatarData& from);

  inline AvatarData& operator=(const AvatarData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AvatarData& default_instance();

  void Swap(AvatarData* other);

  // implements Message ----------------------------------------------

  AvatarData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AvatarData& from);
  void MergeFrom(const AvatarData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AvatarData</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string AvatarName = 2;
  inline bool has_avatarname() const;
  inline void clear_avatarname();
  static const int kAvatarNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AvatarData</name>
  	<Function>
  		<name>avatarname</name>
  		<replaceName>AvatarName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_avatarname</name>
  		<replaceName>AvatarName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_avatarname</name>
  		<replaceName>AvatarName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& avatarname() const;
  inline void set_avatarname(const ::std::string& value);
  inline void set_avatarname(const char* value);
  inline void set_avatarname(const char* value, size_t size);
  inline ::std::string* mutable_avatarname();
  inline ::std::string* release_avatarname();
  inline void set_allocated_avatarname(::std::string* avatarname);

  // repeated .pb.AnimData AnimDatas = 3;
  inline int animdatas_size() const;
  inline void clear_animdatas();
  static const int kAnimDatasFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AvatarData</name>
  	<Function>
  		<name>animdatas</name>
  		<replaceName>AnimDatas</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_animdatas</name>
  		<replaceName>AnimDatas</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_animdatas</name>
  		<replaceName>AnimDatas</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animdatas</name>
  		<replaceName>AnimDatas</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>animdatas_size</name>
  		<replaceName>AnimDatas</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AnimData& animdatas(int index) const;
  inline ::pb::AnimData* mutable_animdatas(int index);
  inline ::pb::AnimData* add_animdatas();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimData >&
      animdatas() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AnimData >*
      mutable_animdatas();

  // @@protoc_insertion_point(class_scope:pb.AvatarData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_avatarname();
  inline void clear_has_avatarname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatarname_;
  ::google::protobuf::RepeatedPtrField< ::pb::AnimData > animdatas_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fAvatarData_2eproto();
  friend void protobuf_AssignDesc_module_2fAvatarData_2eproto();
  friend void protobuf_ShutdownFile_module_2fAvatarData_2eproto();

  void InitAsDefaultInstance();
  static AvatarData* default_instance_;
};
// ===================================================================


// ===================================================================

// AvatarVector3

// required int32 X = 1;
inline bool AvatarVector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarVector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarVector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarVector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 AvatarVector3::x() const {
  // @@protoc_insertion_point(field_get:pb.AvatarVector3.X)
  return x_;
}
inline void AvatarVector3::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pb.AvatarVector3.X)
}

// required int32 Y = 2;
inline bool AvatarVector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarVector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarVector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarVector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 AvatarVector3::y() const {
  // @@protoc_insertion_point(field_get:pb.AvatarVector3.Y)
  return y_;
}
inline void AvatarVector3::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pb.AvatarVector3.Y)
}

// required int32 Z = 3;
inline bool AvatarVector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AvatarVector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AvatarVector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AvatarVector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 AvatarVector3::z() const {
  // @@protoc_insertion_point(field_get:pb.AvatarVector3.Z)
  return z_;
}
inline void AvatarVector3::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:pb.AvatarVector3.Z)
}

// -------------------------------------------------------------------

// EffectEvent

// required string SocketName = 1;
inline bool EffectEvent::has_socketname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectEvent::set_has_socketname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectEvent::clear_has_socketname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectEvent::clear_socketname() {
  if (socketname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_->clear();
  }
  clear_has_socketname();
}
inline const ::std::string& EffectEvent::socketname() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.SocketName)
  return *socketname_;
}
inline void EffectEvent::set_socketname(const ::std::string& value) {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  socketname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectEvent.SocketName)
}
inline void EffectEvent::set_socketname(const char* value) {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  socketname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectEvent.SocketName)
}
inline void EffectEvent::set_socketname(const char* value, size_t size) {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  socketname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectEvent.SocketName)
}
inline ::std::string* EffectEvent::mutable_socketname() {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectEvent.SocketName)
  return socketname_;
}
inline ::std::string* EffectEvent::release_socketname() {
  clear_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = socketname_;
    socketname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectEvent::set_allocated_socketname(::std::string* socketname) {
  if (socketname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete socketname_;
  }
  if (socketname) {
    set_has_socketname();
    socketname_ = socketname;
  } else {
    clear_has_socketname();
    socketname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectEvent.SocketName)
}

// required string EffectName = 2;
inline bool EffectEvent::has_effectname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectEvent::set_has_effectname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectEvent::clear_has_effectname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectEvent::clear_effectname() {
  if (effectname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effectname_->clear();
  }
  clear_has_effectname();
}
inline const ::std::string& EffectEvent::effectname() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.EffectName)
  return *effectname_;
}
inline void EffectEvent::set_effectname(const ::std::string& value) {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effectname_ = new ::std::string;
  }
  effectname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectEvent.EffectName)
}
inline void EffectEvent::set_effectname(const char* value) {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effectname_ = new ::std::string;
  }
  effectname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectEvent.EffectName)
}
inline void EffectEvent::set_effectname(const char* value, size_t size) {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effectname_ = new ::std::string;
  }
  effectname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectEvent.EffectName)
}
inline ::std::string* EffectEvent::mutable_effectname() {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effectname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectEvent.EffectName)
  return effectname_;
}
inline ::std::string* EffectEvent::release_effectname() {
  clear_has_effectname();
  if (effectname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = effectname_;
    effectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectEvent::set_allocated_effectname(::std::string* effectname) {
  if (effectname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete effectname_;
  }
  if (effectname) {
    set_has_effectname();
    effectname_ = effectname;
  } else {
    clear_has_effectname();
    effectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectEvent.EffectName)
}

// required float StartTime = 3;
inline bool EffectEvent::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectEvent::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EffectEvent::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EffectEvent::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float EffectEvent::starttime() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.StartTime)
  return starttime_;
}
inline void EffectEvent::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectEvent.StartTime)
}

// required float EffectTimeLength = 4;
inline bool EffectEvent::has_effecttimelength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EffectEvent::set_has_effecttimelength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EffectEvent::clear_has_effecttimelength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EffectEvent::clear_effecttimelength() {
  effecttimelength_ = 0;
  clear_has_effecttimelength();
}
inline float EffectEvent::effecttimelength() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.EffectTimeLength)
  return effecttimelength_;
}
inline void EffectEvent::set_effecttimelength(float value) {
  set_has_effecttimelength();
  effecttimelength_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectEvent.EffectTimeLength)
}

// required float EffectScale = 5;
inline bool EffectEvent::has_effectscale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EffectEvent::set_has_effectscale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EffectEvent::clear_has_effectscale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EffectEvent::clear_effectscale() {
  effectscale_ = 0;
  clear_has_effectscale();
}
inline float EffectEvent::effectscale() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.EffectScale)
  return effectscale_;
}
inline void EffectEvent::set_effectscale(float value) {
  set_has_effectscale();
  effectscale_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectEvent.EffectScale)
}

// required float EffectSpeed = 6;
inline bool EffectEvent::has_effectspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EffectEvent::set_has_effectspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EffectEvent::clear_has_effectspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EffectEvent::clear_effectspeed() {
  effectspeed_ = 0;
  clear_has_effectspeed();
}
inline float EffectEvent::effectspeed() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.EffectSpeed)
  return effectspeed_;
}
inline void EffectEvent::set_effectspeed(float value) {
  set_has_effectspeed();
  effectspeed_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectEvent.EffectSpeed)
}

// required .pb.AvatarVector3 EffectPosition = 7;
inline bool EffectEvent::has_effectposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EffectEvent::set_has_effectposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EffectEvent::clear_has_effectposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EffectEvent::clear_effectposition() {
  if (effectposition_ != NULL) effectposition_->::pb::AvatarVector3::Clear();
  clear_has_effectposition();
}
inline const ::pb::AvatarVector3& EffectEvent::effectposition() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.EffectPosition)
  return effectposition_ != NULL ? *effectposition_ : *default_instance_->effectposition_;
}
inline ::pb::AvatarVector3* EffectEvent::mutable_effectposition() {
  set_has_effectposition();
  if (effectposition_ == NULL) effectposition_ = new ::pb::AvatarVector3;
  // @@protoc_insertion_point(field_mutable:pb.EffectEvent.EffectPosition)
  return effectposition_;
}
inline ::pb::AvatarVector3* EffectEvent::release_effectposition() {
  clear_has_effectposition();
  ::pb::AvatarVector3* temp = effectposition_;
  effectposition_ = NULL;
  return temp;
}
inline void EffectEvent::set_allocated_effectposition(::pb::AvatarVector3* effectposition) {
  delete effectposition_;
  effectposition_ = effectposition;
  if (effectposition) {
    set_has_effectposition();
  } else {
    clear_has_effectposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectEvent.EffectPosition)
}

// required .pb.AvatarVector3 EffectEulerAngles = 8;
inline bool EffectEvent::has_effecteulerangles() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EffectEvent::set_has_effecteulerangles() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EffectEvent::clear_has_effecteulerangles() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EffectEvent::clear_effecteulerangles() {
  if (effecteulerangles_ != NULL) effecteulerangles_->::pb::AvatarVector3::Clear();
  clear_has_effecteulerangles();
}
inline const ::pb::AvatarVector3& EffectEvent::effecteulerangles() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.EffectEulerAngles)
  return effecteulerangles_ != NULL ? *effecteulerangles_ : *default_instance_->effecteulerangles_;
}
inline ::pb::AvatarVector3* EffectEvent::mutable_effecteulerangles() {
  set_has_effecteulerangles();
  if (effecteulerangles_ == NULL) effecteulerangles_ = new ::pb::AvatarVector3;
  // @@protoc_insertion_point(field_mutable:pb.EffectEvent.EffectEulerAngles)
  return effecteulerangles_;
}
inline ::pb::AvatarVector3* EffectEvent::release_effecteulerangles() {
  clear_has_effecteulerangles();
  ::pb::AvatarVector3* temp = effecteulerangles_;
  effecteulerangles_ = NULL;
  return temp;
}
inline void EffectEvent::set_allocated_effecteulerangles(::pb::AvatarVector3* effecteulerangles) {
  delete effecteulerangles_;
  effecteulerangles_ = effecteulerangles;
  if (effecteulerangles) {
    set_has_effecteulerangles();
  } else {
    clear_has_effecteulerangles();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectEvent.EffectEulerAngles)
}

// required float Loop = 9;
inline bool EffectEvent::has_loop() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EffectEvent::set_has_loop() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EffectEvent::clear_has_loop() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EffectEvent::clear_loop() {
  loop_ = 0;
  clear_has_loop();
}
inline float EffectEvent::loop() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.Loop)
  return loop_;
}
inline void EffectEvent::set_loop(float value) {
  set_has_loop();
  loop_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectEvent.Loop)
}

// optional bool UseWorldPos = 10;
inline bool EffectEvent::has_useworldpos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EffectEvent::set_has_useworldpos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EffectEvent::clear_has_useworldpos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EffectEvent::clear_useworldpos() {
  useworldpos_ = false;
  clear_has_useworldpos();
}
inline bool EffectEvent::useworldpos() const {
  // @@protoc_insertion_point(field_get:pb.EffectEvent.UseWorldPos)
  return useworldpos_;
}
inline void EffectEvent::set_useworldpos(bool value) {
  set_has_useworldpos();
  useworldpos_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectEvent.UseWorldPos)
}

// -------------------------------------------------------------------

// TriggerEvent

// required double StartTime = 2;
inline bool TriggerEvent::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerEvent::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerEvent::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerEvent::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline double TriggerEvent::starttime() const {
  // @@protoc_insertion_point(field_get:pb.TriggerEvent.StartTime)
  return starttime_;
}
inline void TriggerEvent::set_starttime(double value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pb.TriggerEvent.StartTime)
}

// required double TriggerLength = 3;
inline bool TriggerEvent::has_triggerlength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggerEvent::set_has_triggerlength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggerEvent::clear_has_triggerlength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggerEvent::clear_triggerlength() {
  triggerlength_ = 0;
  clear_has_triggerlength();
}
inline double TriggerEvent::triggerlength() const {
  // @@protoc_insertion_point(field_get:pb.TriggerEvent.TriggerLength)
  return triggerlength_;
}
inline void TriggerEvent::set_triggerlength(double value) {
  set_has_triggerlength();
  triggerlength_ = value;
  // @@protoc_insertion_point(field_set:pb.TriggerEvent.TriggerLength)
}

// required int32 TriggerType = 4;
inline bool TriggerEvent::has_triggertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggerEvent::set_has_triggertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggerEvent::clear_has_triggertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggerEvent::clear_triggertype() {
  triggertype_ = 0;
  clear_has_triggertype();
}
inline ::google::protobuf::int32 TriggerEvent::triggertype() const {
  // @@protoc_insertion_point(field_get:pb.TriggerEvent.TriggerType)
  return triggertype_;
}
inline void TriggerEvent::set_triggertype(::google::protobuf::int32 value) {
  set_has_triggertype();
  triggertype_ = value;
  // @@protoc_insertion_point(field_set:pb.TriggerEvent.TriggerType)
}

// repeated float TriggerParam = 5;
inline int TriggerEvent::triggerparam_size() const {
  return triggerparam_.size();
}
inline void TriggerEvent::clear_triggerparam() {
  triggerparam_.Clear();
}
inline float TriggerEvent::triggerparam(int index) const {
  // @@protoc_insertion_point(field_get:pb.TriggerEvent.TriggerParam)
  return triggerparam_.Get(index);
}
inline void TriggerEvent::set_triggerparam(int index, float value) {
  triggerparam_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.TriggerEvent.TriggerParam)
}
inline void TriggerEvent::add_triggerparam(float value) {
  triggerparam_.Add(value);
  // @@protoc_insertion_point(field_add:pb.TriggerEvent.TriggerParam)
}
inline const ::google::protobuf::RepeatedField< float >&
TriggerEvent::triggerparam() const {
  // @@protoc_insertion_point(field_list:pb.TriggerEvent.TriggerParam)
  return triggerparam_;
}
inline ::google::protobuf::RepeatedField< float >*
TriggerEvent::mutable_triggerparam() {
  // @@protoc_insertion_point(field_mutable_list:pb.TriggerEvent.TriggerParam)
  return &triggerparam_;
}

// -------------------------------------------------------------------

// SocketPosition

// required string SocketName = 1;
inline bool SocketPosition::has_socketname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketPosition::set_has_socketname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketPosition::clear_has_socketname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketPosition::clear_socketname() {
  if (socketname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_->clear();
  }
  clear_has_socketname();
}
inline const ::std::string& SocketPosition::socketname() const {
  // @@protoc_insertion_point(field_get:pb.SocketPosition.SocketName)
  return *socketname_;
}
inline void SocketPosition::set_socketname(const ::std::string& value) {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  socketname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SocketPosition.SocketName)
}
inline void SocketPosition::set_socketname(const char* value) {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  socketname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SocketPosition.SocketName)
}
inline void SocketPosition::set_socketname(const char* value, size_t size) {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  socketname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SocketPosition.SocketName)
}
inline ::std::string* SocketPosition::mutable_socketname() {
  set_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    socketname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SocketPosition.SocketName)
  return socketname_;
}
inline ::std::string* SocketPosition::release_socketname() {
  clear_has_socketname();
  if (socketname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = socketname_;
    socketname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SocketPosition::set_allocated_socketname(::std::string* socketname) {
  if (socketname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete socketname_;
  }
  if (socketname) {
    set_has_socketname();
    socketname_ = socketname;
  } else {
    clear_has_socketname();
    socketname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SocketPosition.SocketName)
}

// required .pb.AvatarVector3 Position = 2;
inline bool SocketPosition::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketPosition::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketPosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketPosition::clear_position() {
  if (position_ != NULL) position_->::pb::AvatarVector3::Clear();
  clear_has_position();
}
inline const ::pb::AvatarVector3& SocketPosition::position() const {
  // @@protoc_insertion_point(field_get:pb.SocketPosition.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::AvatarVector3* SocketPosition::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::AvatarVector3;
  // @@protoc_insertion_point(field_mutable:pb.SocketPosition.Position)
  return position_;
}
inline ::pb::AvatarVector3* SocketPosition::release_position() {
  clear_has_position();
  ::pb::AvatarVector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void SocketPosition::set_allocated_position(::pb::AvatarVector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SocketPosition.Position)
}

// -------------------------------------------------------------------

// SkillTriggerEvent

// required int32 StartTime = 1;
inline bool SkillTriggerEvent::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillTriggerEvent::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillTriggerEvent::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillTriggerEvent::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 SkillTriggerEvent::starttime() const {
  // @@protoc_insertion_point(field_get:pb.SkillTriggerEvent.StartTime)
  return starttime_;
}
inline void SkillTriggerEvent::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pb.SkillTriggerEvent.StartTime)
}

// repeated .pb.SocketPosition Positions = 2;
inline int SkillTriggerEvent::positions_size() const {
  return positions_.size();
}
inline void SkillTriggerEvent::clear_positions() {
  positions_.Clear();
}
inline const ::pb::SocketPosition& SkillTriggerEvent::positions(int index) const {
  // @@protoc_insertion_point(field_get:pb.SkillTriggerEvent.Positions)
  return positions_.Get(index);
}
inline ::pb::SocketPosition* SkillTriggerEvent::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SkillTriggerEvent.Positions)
  return positions_.Mutable(index);
}
inline ::pb::SocketPosition* SkillTriggerEvent::add_positions() {
  // @@protoc_insertion_point(field_add:pb.SkillTriggerEvent.Positions)
  return positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >&
SkillTriggerEvent::positions() const {
  // @@protoc_insertion_point(field_list:pb.SkillTriggerEvent.Positions)
  return positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >*
SkillTriggerEvent::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:pb.SkillTriggerEvent.Positions)
  return &positions_;
}

// -------------------------------------------------------------------

// TSkillTriggerDeath

// required int32 StartTime = 1;
inline bool TSkillTriggerDeath::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSkillTriggerDeath::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSkillTriggerDeath::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSkillTriggerDeath::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 TSkillTriggerDeath::starttime() const {
  // @@protoc_insertion_point(field_get:pb.TSkillTriggerDeath.StartTime)
  return starttime_;
}
inline void TSkillTriggerDeath::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pb.TSkillTriggerDeath.StartTime)
}

// required string AnimName = 2;
inline bool TSkillTriggerDeath::has_animname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TSkillTriggerDeath::set_has_animname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TSkillTriggerDeath::clear_has_animname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TSkillTriggerDeath::clear_animname() {
  if (animname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_->clear();
  }
  clear_has_animname();
}
inline const ::std::string& TSkillTriggerDeath::animname() const {
  // @@protoc_insertion_point(field_get:pb.TSkillTriggerDeath.AnimName)
  return *animname_;
}
inline void TSkillTriggerDeath::set_animname(const ::std::string& value) {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  animname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TSkillTriggerDeath.AnimName)
}
inline void TSkillTriggerDeath::set_animname(const char* value) {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  animname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TSkillTriggerDeath.AnimName)
}
inline void TSkillTriggerDeath::set_animname(const char* value, size_t size) {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  animname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TSkillTriggerDeath.AnimName)
}
inline ::std::string* TSkillTriggerDeath::mutable_animname() {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TSkillTriggerDeath.AnimName)
  return animname_;
}
inline ::std::string* TSkillTriggerDeath::release_animname() {
  clear_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = animname_;
    animname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TSkillTriggerDeath::set_allocated_animname(::std::string* animname) {
  if (animname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete animname_;
  }
  if (animname) {
    set_has_animname();
    animname_ = animname;
  } else {
    clear_has_animname();
    animname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TSkillTriggerDeath.AnimName)
}

// repeated int32 SkillIdArr = 3;
inline int TSkillTriggerDeath::skillidarr_size() const {
  return skillidarr_.size();
}
inline void TSkillTriggerDeath::clear_skillidarr() {
  skillidarr_.Clear();
}
inline ::google::protobuf::int32 TSkillTriggerDeath::skillidarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.TSkillTriggerDeath.SkillIdArr)
  return skillidarr_.Get(index);
}
inline void TSkillTriggerDeath::set_skillidarr(int index, ::google::protobuf::int32 value) {
  skillidarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.TSkillTriggerDeath.SkillIdArr)
}
inline void TSkillTriggerDeath::add_skillidarr(::google::protobuf::int32 value) {
  skillidarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.TSkillTriggerDeath.SkillIdArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TSkillTriggerDeath::skillidarr() const {
  // @@protoc_insertion_point(field_list:pb.TSkillTriggerDeath.SkillIdArr)
  return skillidarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TSkillTriggerDeath::mutable_skillidarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.TSkillTriggerDeath.SkillIdArr)
  return &skillidarr_;
}

// -------------------------------------------------------------------

// BlendShapeInfo

// required int32 Index = 1;
inline bool BlendShapeInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlendShapeInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlendShapeInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlendShapeInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BlendShapeInfo::index() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.Index)
  return index_;
}
inline void BlendShapeInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.Index)
}

// required string Name = 2;
inline bool BlendShapeInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlendShapeInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlendShapeInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlendShapeInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BlendShapeInfo::name() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.Name)
  return *name_;
}
inline void BlendShapeInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.Name)
}
inline void BlendShapeInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BlendShapeInfo.Name)
}
inline void BlendShapeInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BlendShapeInfo.Name)
}
inline ::std::string* BlendShapeInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BlendShapeInfo.Name)
  return name_;
}
inline ::std::string* BlendShapeInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlendShapeInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BlendShapeInfo.Name)
}

// required float StartTime = 3;
inline bool BlendShapeInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlendShapeInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlendShapeInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlendShapeInfo::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float BlendShapeInfo::starttime() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.StartTime)
  return starttime_;
}
inline void BlendShapeInfo::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.StartTime)
}

// required float FadeInTime = 4;
inline bool BlendShapeInfo::has_fadeintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlendShapeInfo::set_has_fadeintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlendShapeInfo::clear_has_fadeintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlendShapeInfo::clear_fadeintime() {
  fadeintime_ = 0;
  clear_has_fadeintime();
}
inline float BlendShapeInfo::fadeintime() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.FadeInTime)
  return fadeintime_;
}
inline void BlendShapeInfo::set_fadeintime(float value) {
  set_has_fadeintime();
  fadeintime_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.FadeInTime)
}

// required float LastTime = 5;
inline bool BlendShapeInfo::has_lasttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlendShapeInfo::set_has_lasttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlendShapeInfo::clear_has_lasttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlendShapeInfo::clear_lasttime() {
  lasttime_ = 0;
  clear_has_lasttime();
}
inline float BlendShapeInfo::lasttime() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.LastTime)
  return lasttime_;
}
inline void BlendShapeInfo::set_lasttime(float value) {
  set_has_lasttime();
  lasttime_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.LastTime)
}

// required float FadeOutTime = 6;
inline bool BlendShapeInfo::has_fadeouttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlendShapeInfo::set_has_fadeouttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlendShapeInfo::clear_has_fadeouttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlendShapeInfo::clear_fadeouttime() {
  fadeouttime_ = 0;
  clear_has_fadeouttime();
}
inline float BlendShapeInfo::fadeouttime() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.FadeOutTime)
  return fadeouttime_;
}
inline void BlendShapeInfo::set_fadeouttime(float value) {
  set_has_fadeouttime();
  fadeouttime_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.FadeOutTime)
}

// required float FadeInBlendWeight = 7;
inline bool BlendShapeInfo::has_fadeinblendweight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlendShapeInfo::set_has_fadeinblendweight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlendShapeInfo::clear_has_fadeinblendweight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlendShapeInfo::clear_fadeinblendweight() {
  fadeinblendweight_ = 0;
  clear_has_fadeinblendweight();
}
inline float BlendShapeInfo::fadeinblendweight() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.FadeInBlendWeight)
  return fadeinblendweight_;
}
inline void BlendShapeInfo::set_fadeinblendweight(float value) {
  set_has_fadeinblendweight();
  fadeinblendweight_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.FadeInBlendWeight)
}

// required float LastBlendWeight = 8;
inline bool BlendShapeInfo::has_lastblendweight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BlendShapeInfo::set_has_lastblendweight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BlendShapeInfo::clear_has_lastblendweight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BlendShapeInfo::clear_lastblendweight() {
  lastblendweight_ = 0;
  clear_has_lastblendweight();
}
inline float BlendShapeInfo::lastblendweight() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.LastBlendWeight)
  return lastblendweight_;
}
inline void BlendShapeInfo::set_lastblendweight(float value) {
  set_has_lastblendweight();
  lastblendweight_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.LastBlendWeight)
}

// required float FadeOutBlendWeight = 9;
inline bool BlendShapeInfo::has_fadeoutblendweight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BlendShapeInfo::set_has_fadeoutblendweight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BlendShapeInfo::clear_has_fadeoutblendweight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BlendShapeInfo::clear_fadeoutblendweight() {
  fadeoutblendweight_ = 0;
  clear_has_fadeoutblendweight();
}
inline float BlendShapeInfo::fadeoutblendweight() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.FadeOutBlendWeight)
  return fadeoutblendweight_;
}
inline void BlendShapeInfo::set_fadeoutblendweight(float value) {
  set_has_fadeoutblendweight();
  fadeoutblendweight_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.FadeOutBlendWeight)
}

// required int32 ShowCount = 10;
inline bool BlendShapeInfo::has_showcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BlendShapeInfo::set_has_showcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BlendShapeInfo::clear_has_showcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BlendShapeInfo::clear_showcount() {
  showcount_ = 0;
  clear_has_showcount();
}
inline ::google::protobuf::int32 BlendShapeInfo::showcount() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.ShowCount)
  return showcount_;
}
inline void BlendShapeInfo::set_showcount(::google::protobuf::int32 value) {
  set_has_showcount();
  showcount_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.ShowCount)
}

// required int32 HideCount = 11;
inline bool BlendShapeInfo::has_hidecount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BlendShapeInfo::set_has_hidecount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BlendShapeInfo::clear_has_hidecount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BlendShapeInfo::clear_hidecount() {
  hidecount_ = 0;
  clear_has_hidecount();
}
inline ::google::protobuf::int32 BlendShapeInfo::hidecount() const {
  // @@protoc_insertion_point(field_get:pb.BlendShapeInfo.HideCount)
  return hidecount_;
}
inline void BlendShapeInfo::set_hidecount(::google::protobuf::int32 value) {
  set_has_hidecount();
  hidecount_ = value;
  // @@protoc_insertion_point(field_set:pb.BlendShapeInfo.HideCount)
}

// -------------------------------------------------------------------

// AnimData

// required string AnimName = 1;
inline bool AnimData::has_animname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimData::set_has_animname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimData::clear_has_animname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimData::clear_animname() {
  if (animname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_->clear();
  }
  clear_has_animname();
}
inline const ::std::string& AnimData::animname() const {
  // @@protoc_insertion_point(field_get:pb.AnimData.AnimName)
  return *animname_;
}
inline void AnimData::set_animname(const ::std::string& value) {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  animname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimData.AnimName)
}
inline void AnimData::set_animname(const char* value) {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  animname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimData.AnimName)
}
inline void AnimData::set_animname(const char* value, size_t size) {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  animname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimData.AnimName)
}
inline ::std::string* AnimData::mutable_animname() {
  set_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimData.AnimName)
  return animname_;
}
inline ::std::string* AnimData::release_animname() {
  clear_has_animname();
  if (animname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = animname_;
    animname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimData::set_allocated_animname(::std::string* animname) {
  if (animname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete animname_;
  }
  if (animname) {
    set_has_animname();
    animname_ = animname;
  } else {
    clear_has_animname();
    animname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimData.AnimName)
}

// required int32 AnimTimeLength = 2;
inline bool AnimData::has_animtimelength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimData::set_has_animtimelength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimData::clear_has_animtimelength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimData::clear_animtimelength() {
  animtimelength_ = 0;
  clear_has_animtimelength();
}
inline ::google::protobuf::int32 AnimData::animtimelength() const {
  // @@protoc_insertion_point(field_get:pb.AnimData.AnimTimeLength)
  return animtimelength_;
}
inline void AnimData::set_animtimelength(::google::protobuf::int32 value) {
  set_has_animtimelength();
  animtimelength_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimData.AnimTimeLength)
}

// required int32 PauseEndEventTime = 4;
inline bool AnimData::has_pauseendeventtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimData::set_has_pauseendeventtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimData::clear_has_pauseendeventtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimData::clear_pauseendeventtime() {
  pauseendeventtime_ = 0;
  clear_has_pauseendeventtime();
}
inline ::google::protobuf::int32 AnimData::pauseendeventtime() const {
  // @@protoc_insertion_point(field_get:pb.AnimData.PauseEndEventTime)
  return pauseendeventtime_;
}
inline void AnimData::set_pauseendeventtime(::google::protobuf::int32 value) {
  set_has_pauseendeventtime();
  pauseendeventtime_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimData.PauseEndEventTime)
}

// repeated .pb.EffectEvent EffectEvents = 6;
inline int AnimData::effectevents_size() const {
  return effectevents_.size();
}
inline void AnimData::clear_effectevents() {
  effectevents_.Clear();
}
inline const ::pb::EffectEvent& AnimData::effectevents(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.EffectEvents)
  return effectevents_.Get(index);
}
inline ::pb::EffectEvent* AnimData::mutable_effectevents(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.EffectEvents)
  return effectevents_.Mutable(index);
}
inline ::pb::EffectEvent* AnimData::add_effectevents() {
  // @@protoc_insertion_point(field_add:pb.AnimData.EffectEvents)
  return effectevents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectEvent >&
AnimData::effectevents() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.EffectEvents)
  return effectevents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectEvent >*
AnimData::mutable_effectevents() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.EffectEvents)
  return &effectevents_;
}

// repeated .pb.AudioInfo AudioInfoArr = 7;
inline int AnimData::audioinfoarr_size() const {
  return audioinfoarr_.size();
}
inline void AnimData::clear_audioinfoarr() {
  audioinfoarr_.Clear();
}
inline const ::pb::AudioInfo& AnimData::audioinfoarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.AudioInfoArr)
  return audioinfoarr_.Get(index);
}
inline ::pb::AudioInfo* AnimData::mutable_audioinfoarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.AudioInfoArr)
  return audioinfoarr_.Mutable(index);
}
inline ::pb::AudioInfo* AnimData::add_audioinfoarr() {
  // @@protoc_insertion_point(field_add:pb.AnimData.AudioInfoArr)
  return audioinfoarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AudioInfo >&
AnimData::audioinfoarr() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.AudioInfoArr)
  return audioinfoarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AudioInfo >*
AnimData::mutable_audioinfoarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.AudioInfoArr)
  return &audioinfoarr_;
}

// repeated .pb.TriggerEvent TriggerEvents = 8;
inline int AnimData::triggerevents_size() const {
  return triggerevents_.size();
}
inline void AnimData::clear_triggerevents() {
  triggerevents_.Clear();
}
inline const ::pb::TriggerEvent& AnimData::triggerevents(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.TriggerEvents)
  return triggerevents_.Get(index);
}
inline ::pb::TriggerEvent* AnimData::mutable_triggerevents(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.TriggerEvents)
  return triggerevents_.Mutable(index);
}
inline ::pb::TriggerEvent* AnimData::add_triggerevents() {
  // @@protoc_insertion_point(field_add:pb.AnimData.TriggerEvents)
  return triggerevents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TriggerEvent >&
AnimData::triggerevents() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.TriggerEvents)
  return triggerevents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TriggerEvent >*
AnimData::mutable_triggerevents() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.TriggerEvents)
  return &triggerevents_;
}

// repeated .pb.SkillTriggerEvent SkillTriggerEvents = 9;
inline int AnimData::skilltriggerevents_size() const {
  return skilltriggerevents_.size();
}
inline void AnimData::clear_skilltriggerevents() {
  skilltriggerevents_.Clear();
}
inline const ::pb::SkillTriggerEvent& AnimData::skilltriggerevents(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.SkillTriggerEvents)
  return skilltriggerevents_.Get(index);
}
inline ::pb::SkillTriggerEvent* AnimData::mutable_skilltriggerevents(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.SkillTriggerEvents)
  return skilltriggerevents_.Mutable(index);
}
inline ::pb::SkillTriggerEvent* AnimData::add_skilltriggerevents() {
  // @@protoc_insertion_point(field_add:pb.AnimData.SkillTriggerEvents)
  return skilltriggerevents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::SkillTriggerEvent >&
AnimData::skilltriggerevents() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.SkillTriggerEvents)
  return skilltriggerevents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::SkillTriggerEvent >*
AnimData::mutable_skilltriggerevents() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.SkillTriggerEvents)
  return &skilltriggerevents_;
}

// repeated .pb.BlendShapeInfo BlendShapeInfoList = 10;
inline int AnimData::blendshapeinfolist_size() const {
  return blendshapeinfolist_.size();
}
inline void AnimData::clear_blendshapeinfolist() {
  blendshapeinfolist_.Clear();
}
inline const ::pb::BlendShapeInfo& AnimData::blendshapeinfolist(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.BlendShapeInfoList)
  return blendshapeinfolist_.Get(index);
}
inline ::pb::BlendShapeInfo* AnimData::mutable_blendshapeinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.BlendShapeInfoList)
  return blendshapeinfolist_.Mutable(index);
}
inline ::pb::BlendShapeInfo* AnimData::add_blendshapeinfolist() {
  // @@protoc_insertion_point(field_add:pb.AnimData.BlendShapeInfoList)
  return blendshapeinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BlendShapeInfo >&
AnimData::blendshapeinfolist() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.BlendShapeInfoList)
  return blendshapeinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BlendShapeInfo >*
AnimData::mutable_blendshapeinfolist() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.BlendShapeInfoList)
  return &blendshapeinfolist_;
}

// repeated .pb.SocketPosition InitSocketPosition = 11;
inline int AnimData::initsocketposition_size() const {
  return initsocketposition_.size();
}
inline void AnimData::clear_initsocketposition() {
  initsocketposition_.Clear();
}
inline const ::pb::SocketPosition& AnimData::initsocketposition(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.InitSocketPosition)
  return initsocketposition_.Get(index);
}
inline ::pb::SocketPosition* AnimData::mutable_initsocketposition(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.InitSocketPosition)
  return initsocketposition_.Mutable(index);
}
inline ::pb::SocketPosition* AnimData::add_initsocketposition() {
  // @@protoc_insertion_point(field_add:pb.AnimData.InitSocketPosition)
  return initsocketposition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >&
AnimData::initsocketposition() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.InitSocketPosition)
  return initsocketposition_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::SocketPosition >*
AnimData::mutable_initsocketposition() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.InitSocketPosition)
  return &initsocketposition_;
}

// repeated .pb.TSkillTriggerDeath SkillTriggerDeath = 12;
inline int AnimData::skilltriggerdeath_size() const {
  return skilltriggerdeath_.size();
}
inline void AnimData::clear_skilltriggerdeath() {
  skilltriggerdeath_.Clear();
}
inline const ::pb::TSkillTriggerDeath& AnimData::skilltriggerdeath(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimData.SkillTriggerDeath)
  return skilltriggerdeath_.Get(index);
}
inline ::pb::TSkillTriggerDeath* AnimData::mutable_skilltriggerdeath(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimData.SkillTriggerDeath)
  return skilltriggerdeath_.Mutable(index);
}
inline ::pb::TSkillTriggerDeath* AnimData::add_skilltriggerdeath() {
  // @@protoc_insertion_point(field_add:pb.AnimData.SkillTriggerDeath)
  return skilltriggerdeath_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TSkillTriggerDeath >&
AnimData::skilltriggerdeath() const {
  // @@protoc_insertion_point(field_list:pb.AnimData.SkillTriggerDeath)
  return skilltriggerdeath_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TSkillTriggerDeath >*
AnimData::mutable_skilltriggerdeath() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimData.SkillTriggerDeath)
  return &skilltriggerdeath_;
}

// -------------------------------------------------------------------

// AvatarData

// required int32 Id = 1;
inline bool AvatarData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AvatarData::id() const {
  // @@protoc_insertion_point(field_get:pb.AvatarData.Id)
  return id_;
}
inline void AvatarData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.AvatarData.Id)
}

// required string AvatarName = 2;
inline bool AvatarData::has_avatarname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarData::set_has_avatarname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarData::clear_has_avatarname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarData::clear_avatarname() {
  if (avatarname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarname_->clear();
  }
  clear_has_avatarname();
}
inline const ::std::string& AvatarData::avatarname() const {
  // @@protoc_insertion_point(field_get:pb.AvatarData.AvatarName)
  return *avatarname_;
}
inline void AvatarData::set_avatarname(const ::std::string& value) {
  set_has_avatarname();
  if (avatarname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarname_ = new ::std::string;
  }
  avatarname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AvatarData.AvatarName)
}
inline void AvatarData::set_avatarname(const char* value) {
  set_has_avatarname();
  if (avatarname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarname_ = new ::std::string;
  }
  avatarname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AvatarData.AvatarName)
}
inline void AvatarData::set_avatarname(const char* value, size_t size) {
  set_has_avatarname();
  if (avatarname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarname_ = new ::std::string;
  }
  avatarname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AvatarData.AvatarName)
}
inline ::std::string* AvatarData::mutable_avatarname() {
  set_has_avatarname();
  if (avatarname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AvatarData.AvatarName)
  return avatarname_;
}
inline ::std::string* AvatarData::release_avatarname() {
  clear_has_avatarname();
  if (avatarname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatarname_;
    avatarname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AvatarData::set_allocated_avatarname(::std::string* avatarname) {
  if (avatarname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatarname_;
  }
  if (avatarname) {
    set_has_avatarname();
    avatarname_ = avatarname;
  } else {
    clear_has_avatarname();
    avatarname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AvatarData.AvatarName)
}

// repeated .pb.AnimData AnimDatas = 3;
inline int AvatarData::animdatas_size() const {
  return animdatas_.size();
}
inline void AvatarData::clear_animdatas() {
  animdatas_.Clear();
}
inline const ::pb::AnimData& AvatarData::animdatas(int index) const {
  // @@protoc_insertion_point(field_get:pb.AvatarData.AnimDatas)
  return animdatas_.Get(index);
}
inline ::pb::AnimData* AvatarData::mutable_animdatas(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AvatarData.AnimDatas)
  return animdatas_.Mutable(index);
}
inline ::pb::AnimData* AvatarData::add_animdatas() {
  // @@protoc_insertion_point(field_add:pb.AvatarData.AnimDatas)
  return animdatas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimData >&
AvatarData::animdatas() const {
  // @@protoc_insertion_point(field_list:pb.AvatarData.AnimDatas)
  return animdatas_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AnimData >*
AvatarData::mutable_animdatas() {
  // @@protoc_insertion_point(field_mutable_list:pb.AvatarData.AnimDatas)
  return &animdatas_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fAvatarData_2eproto__INCLUDED
