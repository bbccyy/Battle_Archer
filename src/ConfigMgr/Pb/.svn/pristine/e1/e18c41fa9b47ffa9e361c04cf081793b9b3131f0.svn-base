// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/AdventureResConf.proto

#ifndef PROTOBUF_module_2fAdventureResConf_2eproto__INCLUDED
#define PROTOBUF_module_2fAdventureResConf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
#include "module/SceneConf2d.pb.h"
#include "module/SceneElementDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fAdventureResConf_2eproto();
void protobuf_AssignDesc_module_2fAdventureResConf_2eproto();
void protobuf_ShutdownFile_module_2fAdventureResConf_2eproto();

class NameMapping;
class TemplateConf;
class AdventureResConf;

// ===================================================================

/*FOR2LUA
<Record>
	<name>NameMapping</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureResConf.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class NameMapping : public ::google::protobuf::Message {
 public:
  NameMapping();
  virtual ~NameMapping();

  NameMapping(const NameMapping& from);

  inline NameMapping& operator=(const NameMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameMapping& default_instance();

  void Swap(NameMapping* other);

  // implements Message ----------------------------------------------

  NameMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameMapping& from);
  void MergeFrom(const NameMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>NameMapping</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 Index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>NameMapping</name>
  	<Function>
  		<name>index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.NameMapping)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_module_2fAdventureResConf_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureResConf_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureResConf_2eproto();

  void InitAsDefaultInstance();
  static NameMapping* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TemplateConf</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureResConf.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TemplateConf : public ::google::protobuf::Message {
 public:
  TemplateConf();
  virtual ~TemplateConf();

  TemplateConf(const TemplateConf& from);

  inline TemplateConf& operator=(const TemplateConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplateConf& default_instance();

  void Swap(TemplateConf* other);

  // implements Message ----------------------------------------------

  TemplateConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplateConf& from);
  void MergeFrom(const TemplateConf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pb.EAssetType ArtResType = 3;
  inline bool has_artrestype() const;
  inline void clear_artrestype();
  static const int kArtResTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>artrestype</name>
  		<replaceName>ArtResType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artrestype</name>
  		<replaceName>ArtResType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artrestype</name>
  		<replaceName>ArtResType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EAssetType artrestype() const;
  inline void set_artrestype(::pb::EAssetType value);

  // optional string ArtResPath = 4;
  inline bool has_artrespath() const;
  inline void clear_artrespath();
  static const int kArtResPathFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>artrespath</name>
  		<replaceName>ArtResPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artrespath</name>
  		<replaceName>ArtResPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artrespath</name>
  		<replaceName>ArtResPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& artrespath() const;
  inline void set_artrespath(const ::std::string& value);
  inline void set_artrespath(const char* value);
  inline void set_artrespath(const char* value, size_t size);
  inline ::std::string* mutable_artrespath();
  inline ::std::string* release_artrespath();
  inline void set_allocated_artrespath(::std::string* artrespath);

  // optional int32 Type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .pb.PbVector2 Pivot = 6;
  inline bool has_pivot() const;
  inline void clear_pivot();
  static const int kPivotFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>pivot</name>
  		<replaceName>Pivot</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_pivot</name>
  		<replaceName>Pivot</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_pivot</name>
  		<replaceName>Pivot</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pivot</name>
  		<replaceName>Pivot</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& pivot() const;
  inline ::pb::PbVector2* mutable_pivot();
  inline ::pb::PbVector2* release_pivot();
  inline void set_allocated_pivot(::pb::PbVector2* pivot);

  // repeated .pb.PbVector2_Int OccupationGridArr = 7;
  inline int occupationgridarr_size() const;
  inline void clear_occupationgridarr();
  static const int kOccupationGridArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>occupationgridarr</name>
  		<replaceName>OccupationGridArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_occupationgridarr</name>
  		<replaceName>OccupationGridArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_occupationgridarr</name>
  		<replaceName>OccupationGridArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_occupationgridarr</name>
  		<replaceName>OccupationGridArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>occupationgridarr_size</name>
  		<replaceName>OccupationGridArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2_Int& occupationgridarr(int index) const;
  inline ::pb::PbVector2_Int* mutable_occupationgridarr(int index);
  inline ::pb::PbVector2_Int* add_occupationgridarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >&
      occupationgridarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >*
      mutable_occupationgridarr();

  // repeated .pb.PbVector2_Int EventTriggerGridArr = 8;
  inline int eventtriggergridarr_size() const;
  inline void clear_eventtriggergridarr();
  static const int kEventTriggerGridArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>eventtriggergridarr</name>
  		<replaceName>EventTriggerGridArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_eventtriggergridarr</name>
  		<replaceName>EventTriggerGridArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_eventtriggergridarr</name>
  		<replaceName>EventTriggerGridArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventtriggergridarr</name>
  		<replaceName>EventTriggerGridArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>eventtriggergridarr_size</name>
  		<replaceName>EventTriggerGridArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2_Int& eventtriggergridarr(int index) const;
  inline ::pb::PbVector2_Int* mutable_eventtriggergridarr(int index);
  inline ::pb::PbVector2_Int* add_eventtriggergridarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >&
      eventtriggergridarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >*
      mutable_eventtriggergridarr();

  // optional .pb.PbVector2 WidAndLen = 9;
  inline bool has_widandlen() const;
  inline void clear_widandlen();
  static const int kWidAndLenFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>widandlen</name>
  		<replaceName>WidAndLen</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_widandlen</name>
  		<replaceName>WidAndLen</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_widandlen</name>
  		<replaceName>WidAndLen</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_widandlen</name>
  		<replaceName>WidAndLen</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& widandlen() const;
  inline ::pb::PbVector2* mutable_widandlen();
  inline ::pb::PbVector2* release_widandlen();
  inline void set_allocated_widandlen(::pb::PbVector2* widandlen);

  // optional string DefaultAnimName = 10;
  inline bool has_defaultanimname() const;
  inline void clear_defaultanimname();
  static const int kDefaultAnimNameFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>defaultanimname</name>
  		<replaceName>DefaultAnimName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_defaultanimname</name>
  		<replaceName>DefaultAnimName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_defaultanimname</name>
  		<replaceName>DefaultAnimName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& defaultanimname() const;
  inline void set_defaultanimname(const ::std::string& value);
  inline void set_defaultanimname(const char* value);
  inline void set_defaultanimname(const char* value, size_t size);
  inline ::std::string* mutable_defaultanimname();
  inline ::std::string* release_defaultanimname();
  inline void set_allocated_defaultanimname(::std::string* defaultanimname);

  // optional int32 DefaultAnimDirectionIndex = 11;
  inline bool has_defaultanimdirectionindex() const;
  inline void clear_defaultanimdirectionindex();
  static const int kDefaultAnimDirectionIndexFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>defaultanimdirectionindex</name>
  		<replaceName>DefaultAnimDirectionIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_defaultanimdirectionindex</name>
  		<replaceName>DefaultAnimDirectionIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_defaultanimdirectionindex</name>
  		<replaceName>DefaultAnimDirectionIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 defaultanimdirectionindex() const;
  inline void set_defaultanimdirectionindex(::google::protobuf::int32 value);

  // repeated .pb.EffectAsset2 EffectAssetArr = 12;
  inline int effectassetarr_size() const;
  inline void clear_effectassetarr();
  static const int kEffectAssetArrFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectassetarr_size</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectAsset2& effectassetarr(int index) const;
  inline ::pb::EffectAsset2* mutable_effectassetarr(int index);
  inline ::pb::EffectAsset2* add_effectassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
      effectassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
      mutable_effectassetarr();

  // repeated .pb.AttachPoint2 AttachPointArr = 13;
  inline int attachpointarr_size() const;
  inline void clear_attachpointarr();
  static const int kAttachPointArrFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>TemplateConf</name>
  	<Function>
  		<name>attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>attachpointarr_size</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AttachPoint2& attachpointarr(int index) const;
  inline ::pb::AttachPoint2* mutable_attachpointarr(int index);
  inline ::pb::AttachPoint2* add_attachpointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
      attachpointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
      mutable_attachpointarr();

  // @@protoc_insertion_point(class_scope:pb.TemplateConf)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_artrestype();
  inline void clear_has_artrestype();
  inline void set_has_artrespath();
  inline void clear_has_artrespath();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pivot();
  inline void clear_has_pivot();
  inline void set_has_widandlen();
  inline void clear_has_widandlen();
  inline void set_has_defaultanimname();
  inline void clear_has_defaultanimname();
  inline void set_has_defaultanimdirectionindex();
  inline void clear_has_defaultanimdirectionindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  int artrestype_;
  ::std::string* artrespath_;
  ::pb::PbVector2* pivot_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int > occupationgridarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int > eventtriggergridarr_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 defaultanimdirectionindex_;
  ::pb::PbVector2* widandlen_;
  ::std::string* defaultanimname_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 > effectassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 > attachpointarr_;
  friend void  protobuf_AddDesc_module_2fAdventureResConf_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureResConf_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureResConf_2eproto();

  void InitAsDefaultInstance();
  static TemplateConf* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureResConf</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureResConf.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureResConf : public ::google::protobuf::Message {
 public:
  AdventureResConf();
  virtual ~AdventureResConf();

  AdventureResConf(const AdventureResConf& from);

  inline AdventureResConf& operator=(const AdventureResConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureResConf& default_instance();

  void Swap(AdventureResConf* other);

  // implements Message ----------------------------------------------

  AdventureResConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureResConf& from);
  void MergeFrom(const AdventureResConf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureResConf</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .pb.PbVector2 TerrainCellSize = 2;
  inline bool has_terraincellsize() const;
  inline void clear_terraincellsize();
  static const int kTerrainCellSizeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureResConf</name>
  	<Function>
  		<name>terraincellsize</name>
  		<replaceName>TerrainCellSize</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_terraincellsize</name>
  		<replaceName>TerrainCellSize</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_terraincellsize</name>
  		<replaceName>TerrainCellSize</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_terraincellsize</name>
  		<replaceName>TerrainCellSize</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& terraincellsize() const;
  inline ::pb::PbVector2* mutable_terraincellsize();
  inline ::pb::PbVector2* release_terraincellsize();
  inline void set_allocated_terraincellsize(::pb::PbVector2* terraincellsize);

  // repeated .pb.TemplateConf TemplateConfArr = 3;
  inline int templateconfarr_size() const;
  inline void clear_templateconfarr();
  static const int kTemplateConfArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureResConf</name>
  	<Function>
  		<name>templateconfarr</name>
  		<replaceName>TemplateConfArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_templateconfarr</name>
  		<replaceName>TemplateConfArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_templateconfarr</name>
  		<replaceName>TemplateConfArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_templateconfarr</name>
  		<replaceName>TemplateConfArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>templateconfarr_size</name>
  		<replaceName>TemplateConfArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TemplateConf& templateconfarr(int index) const;
  inline ::pb::TemplateConf* mutable_templateconfarr(int index);
  inline ::pb::TemplateConf* add_templateconfarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TemplateConf >&
      templateconfarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TemplateConf >*
      mutable_templateconfarr();

  // @@protoc_insertion_point(class_scope:pb.AdventureResConf)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_terraincellsize();
  inline void clear_has_terraincellsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector2* terraincellsize_;
  ::google::protobuf::RepeatedPtrField< ::pb::TemplateConf > templateconfarr_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fAdventureResConf_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureResConf_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureResConf_2eproto();

  void InitAsDefaultInstance();
  static AdventureResConf* default_instance_;
};
// ===================================================================


// ===================================================================

// NameMapping

// optional string Name = 1;
inline bool NameMapping::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameMapping::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameMapping::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameMapping::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameMapping::name() const {
  // @@protoc_insertion_point(field_get:pb.NameMapping.Name)
  return *name_;
}
inline void NameMapping::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.NameMapping.Name)
}
inline void NameMapping::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.NameMapping.Name)
}
inline void NameMapping::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.NameMapping.Name)
}
inline ::std::string* NameMapping::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.NameMapping.Name)
  return name_;
}
inline ::std::string* NameMapping::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NameMapping::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.NameMapping.Name)
}

// optional int32 Index = 2;
inline bool NameMapping::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameMapping::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameMapping::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameMapping::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 NameMapping::index() const {
  // @@protoc_insertion_point(field_get:pb.NameMapping.Index)
  return index_;
}
inline void NameMapping::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.NameMapping.Index)
}

// -------------------------------------------------------------------

// TemplateConf

// optional int32 Id = 1;
inline bool TemplateConf::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplateConf::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplateConf::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplateConf::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TemplateConf::id() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.Id)
  return id_;
}
inline void TemplateConf::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.TemplateConf.Id)
}

// optional string Name = 2;
inline bool TemplateConf::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplateConf::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplateConf::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplateConf::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TemplateConf::name() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.Name)
  return *name_;
}
inline void TemplateConf::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TemplateConf.Name)
}
inline void TemplateConf::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TemplateConf.Name)
}
inline void TemplateConf::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TemplateConf.Name)
}
inline ::std::string* TemplateConf::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.Name)
  return name_;
}
inline ::std::string* TemplateConf::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplateConf::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TemplateConf.Name)
}

// optional .pb.EAssetType ArtResType = 3;
inline bool TemplateConf::has_artrestype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TemplateConf::set_has_artrestype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TemplateConf::clear_has_artrestype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TemplateConf::clear_artrestype() {
  artrestype_ = 1;
  clear_has_artrestype();
}
inline ::pb::EAssetType TemplateConf::artrestype() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.ArtResType)
  return static_cast< ::pb::EAssetType >(artrestype_);
}
inline void TemplateConf::set_artrestype(::pb::EAssetType value) {
  assert(::pb::EAssetType_IsValid(value));
  set_has_artrestype();
  artrestype_ = value;
  // @@protoc_insertion_point(field_set:pb.TemplateConf.ArtResType)
}

// optional string ArtResPath = 4;
inline bool TemplateConf::has_artrespath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TemplateConf::set_has_artrespath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TemplateConf::clear_has_artrespath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TemplateConf::clear_artrespath() {
  if (artrespath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artrespath_->clear();
  }
  clear_has_artrespath();
}
inline const ::std::string& TemplateConf::artrespath() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.ArtResPath)
  return *artrespath_;
}
inline void TemplateConf::set_artrespath(const ::std::string& value) {
  set_has_artrespath();
  if (artrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artrespath_ = new ::std::string;
  }
  artrespath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TemplateConf.ArtResPath)
}
inline void TemplateConf::set_artrespath(const char* value) {
  set_has_artrespath();
  if (artrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artrespath_ = new ::std::string;
  }
  artrespath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TemplateConf.ArtResPath)
}
inline void TemplateConf::set_artrespath(const char* value, size_t size) {
  set_has_artrespath();
  if (artrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artrespath_ = new ::std::string;
  }
  artrespath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TemplateConf.ArtResPath)
}
inline ::std::string* TemplateConf::mutable_artrespath() {
  set_has_artrespath();
  if (artrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artrespath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.ArtResPath)
  return artrespath_;
}
inline ::std::string* TemplateConf::release_artrespath() {
  clear_has_artrespath();
  if (artrespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = artrespath_;
    artrespath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplateConf::set_allocated_artrespath(::std::string* artrespath) {
  if (artrespath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete artrespath_;
  }
  if (artrespath) {
    set_has_artrespath();
    artrespath_ = artrespath;
  } else {
    clear_has_artrespath();
    artrespath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TemplateConf.ArtResPath)
}

// optional int32 Type = 5;
inline bool TemplateConf::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TemplateConf::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TemplateConf::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TemplateConf::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TemplateConf::type() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.Type)
  return type_;
}
inline void TemplateConf::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.TemplateConf.Type)
}

// optional .pb.PbVector2 Pivot = 6;
inline bool TemplateConf::has_pivot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TemplateConf::set_has_pivot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TemplateConf::clear_has_pivot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TemplateConf::clear_pivot() {
  if (pivot_ != NULL) pivot_->::pb::PbVector2::Clear();
  clear_has_pivot();
}
inline const ::pb::PbVector2& TemplateConf::pivot() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.Pivot)
  return pivot_ != NULL ? *pivot_ : *default_instance_->pivot_;
}
inline ::pb::PbVector2* TemplateConf::mutable_pivot() {
  set_has_pivot();
  if (pivot_ == NULL) pivot_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.Pivot)
  return pivot_;
}
inline ::pb::PbVector2* TemplateConf::release_pivot() {
  clear_has_pivot();
  ::pb::PbVector2* temp = pivot_;
  pivot_ = NULL;
  return temp;
}
inline void TemplateConf::set_allocated_pivot(::pb::PbVector2* pivot) {
  delete pivot_;
  pivot_ = pivot;
  if (pivot) {
    set_has_pivot();
  } else {
    clear_has_pivot();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TemplateConf.Pivot)
}

// repeated .pb.PbVector2_Int OccupationGridArr = 7;
inline int TemplateConf::occupationgridarr_size() const {
  return occupationgridarr_.size();
}
inline void TemplateConf::clear_occupationgridarr() {
  occupationgridarr_.Clear();
}
inline const ::pb::PbVector2_Int& TemplateConf::occupationgridarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.OccupationGridArr)
  return occupationgridarr_.Get(index);
}
inline ::pb::PbVector2_Int* TemplateConf::mutable_occupationgridarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.OccupationGridArr)
  return occupationgridarr_.Mutable(index);
}
inline ::pb::PbVector2_Int* TemplateConf::add_occupationgridarr() {
  // @@protoc_insertion_point(field_add:pb.TemplateConf.OccupationGridArr)
  return occupationgridarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >&
TemplateConf::occupationgridarr() const {
  // @@protoc_insertion_point(field_list:pb.TemplateConf.OccupationGridArr)
  return occupationgridarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >*
TemplateConf::mutable_occupationgridarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.TemplateConf.OccupationGridArr)
  return &occupationgridarr_;
}

// repeated .pb.PbVector2_Int EventTriggerGridArr = 8;
inline int TemplateConf::eventtriggergridarr_size() const {
  return eventtriggergridarr_.size();
}
inline void TemplateConf::clear_eventtriggergridarr() {
  eventtriggergridarr_.Clear();
}
inline const ::pb::PbVector2_Int& TemplateConf::eventtriggergridarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.EventTriggerGridArr)
  return eventtriggergridarr_.Get(index);
}
inline ::pb::PbVector2_Int* TemplateConf::mutable_eventtriggergridarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.EventTriggerGridArr)
  return eventtriggergridarr_.Mutable(index);
}
inline ::pb::PbVector2_Int* TemplateConf::add_eventtriggergridarr() {
  // @@protoc_insertion_point(field_add:pb.TemplateConf.EventTriggerGridArr)
  return eventtriggergridarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >&
TemplateConf::eventtriggergridarr() const {
  // @@protoc_insertion_point(field_list:pb.TemplateConf.EventTriggerGridArr)
  return eventtriggergridarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >*
TemplateConf::mutable_eventtriggergridarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.TemplateConf.EventTriggerGridArr)
  return &eventtriggergridarr_;
}

// optional .pb.PbVector2 WidAndLen = 9;
inline bool TemplateConf::has_widandlen() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TemplateConf::set_has_widandlen() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TemplateConf::clear_has_widandlen() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TemplateConf::clear_widandlen() {
  if (widandlen_ != NULL) widandlen_->::pb::PbVector2::Clear();
  clear_has_widandlen();
}
inline const ::pb::PbVector2& TemplateConf::widandlen() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.WidAndLen)
  return widandlen_ != NULL ? *widandlen_ : *default_instance_->widandlen_;
}
inline ::pb::PbVector2* TemplateConf::mutable_widandlen() {
  set_has_widandlen();
  if (widandlen_ == NULL) widandlen_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.WidAndLen)
  return widandlen_;
}
inline ::pb::PbVector2* TemplateConf::release_widandlen() {
  clear_has_widandlen();
  ::pb::PbVector2* temp = widandlen_;
  widandlen_ = NULL;
  return temp;
}
inline void TemplateConf::set_allocated_widandlen(::pb::PbVector2* widandlen) {
  delete widandlen_;
  widandlen_ = widandlen;
  if (widandlen) {
    set_has_widandlen();
  } else {
    clear_has_widandlen();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TemplateConf.WidAndLen)
}

// optional string DefaultAnimName = 10;
inline bool TemplateConf::has_defaultanimname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TemplateConf::set_has_defaultanimname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TemplateConf::clear_has_defaultanimname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TemplateConf::clear_defaultanimname() {
  if (defaultanimname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanimname_->clear();
  }
  clear_has_defaultanimname();
}
inline const ::std::string& TemplateConf::defaultanimname() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.DefaultAnimName)
  return *defaultanimname_;
}
inline void TemplateConf::set_defaultanimname(const ::std::string& value) {
  set_has_defaultanimname();
  if (defaultanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanimname_ = new ::std::string;
  }
  defaultanimname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TemplateConf.DefaultAnimName)
}
inline void TemplateConf::set_defaultanimname(const char* value) {
  set_has_defaultanimname();
  if (defaultanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanimname_ = new ::std::string;
  }
  defaultanimname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TemplateConf.DefaultAnimName)
}
inline void TemplateConf::set_defaultanimname(const char* value, size_t size) {
  set_has_defaultanimname();
  if (defaultanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanimname_ = new ::std::string;
  }
  defaultanimname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TemplateConf.DefaultAnimName)
}
inline ::std::string* TemplateConf::mutable_defaultanimname() {
  set_has_defaultanimname();
  if (defaultanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanimname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.DefaultAnimName)
  return defaultanimname_;
}
inline ::std::string* TemplateConf::release_defaultanimname() {
  clear_has_defaultanimname();
  if (defaultanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = defaultanimname_;
    defaultanimname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplateConf::set_allocated_defaultanimname(::std::string* defaultanimname) {
  if (defaultanimname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete defaultanimname_;
  }
  if (defaultanimname) {
    set_has_defaultanimname();
    defaultanimname_ = defaultanimname;
  } else {
    clear_has_defaultanimname();
    defaultanimname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TemplateConf.DefaultAnimName)
}

// optional int32 DefaultAnimDirectionIndex = 11;
inline bool TemplateConf::has_defaultanimdirectionindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TemplateConf::set_has_defaultanimdirectionindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TemplateConf::clear_has_defaultanimdirectionindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TemplateConf::clear_defaultanimdirectionindex() {
  defaultanimdirectionindex_ = 0;
  clear_has_defaultanimdirectionindex();
}
inline ::google::protobuf::int32 TemplateConf::defaultanimdirectionindex() const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.DefaultAnimDirectionIndex)
  return defaultanimdirectionindex_;
}
inline void TemplateConf::set_defaultanimdirectionindex(::google::protobuf::int32 value) {
  set_has_defaultanimdirectionindex();
  defaultanimdirectionindex_ = value;
  // @@protoc_insertion_point(field_set:pb.TemplateConf.DefaultAnimDirectionIndex)
}

// repeated .pb.EffectAsset2 EffectAssetArr = 12;
inline int TemplateConf::effectassetarr_size() const {
  return effectassetarr_.size();
}
inline void TemplateConf::clear_effectassetarr() {
  effectassetarr_.Clear();
}
inline const ::pb::EffectAsset2& TemplateConf::effectassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.EffectAssetArr)
  return effectassetarr_.Get(index);
}
inline ::pb::EffectAsset2* TemplateConf::mutable_effectassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.EffectAssetArr)
  return effectassetarr_.Mutable(index);
}
inline ::pb::EffectAsset2* TemplateConf::add_effectassetarr() {
  // @@protoc_insertion_point(field_add:pb.TemplateConf.EffectAssetArr)
  return effectassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
TemplateConf::effectassetarr() const {
  // @@protoc_insertion_point(field_list:pb.TemplateConf.EffectAssetArr)
  return effectassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
TemplateConf::mutable_effectassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.TemplateConf.EffectAssetArr)
  return &effectassetarr_;
}

// repeated .pb.AttachPoint2 AttachPointArr = 13;
inline int TemplateConf::attachpointarr_size() const {
  return attachpointarr_.size();
}
inline void TemplateConf::clear_attachpointarr() {
  attachpointarr_.Clear();
}
inline const ::pb::AttachPoint2& TemplateConf::attachpointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.TemplateConf.AttachPointArr)
  return attachpointarr_.Get(index);
}
inline ::pb::AttachPoint2* TemplateConf::mutable_attachpointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TemplateConf.AttachPointArr)
  return attachpointarr_.Mutable(index);
}
inline ::pb::AttachPoint2* TemplateConf::add_attachpointarr() {
  // @@protoc_insertion_point(field_add:pb.TemplateConf.AttachPointArr)
  return attachpointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
TemplateConf::attachpointarr() const {
  // @@protoc_insertion_point(field_list:pb.TemplateConf.AttachPointArr)
  return attachpointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
TemplateConf::mutable_attachpointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.TemplateConf.AttachPointArr)
  return &attachpointarr_;
}

// -------------------------------------------------------------------

// AdventureResConf

// optional int32 Id = 1;
inline bool AdventureResConf::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureResConf::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureResConf::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureResConf::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AdventureResConf::id() const {
  // @@protoc_insertion_point(field_get:pb.AdventureResConf.Id)
  return id_;
}
inline void AdventureResConf::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureResConf.Id)
}

// optional .pb.PbVector2 TerrainCellSize = 2;
inline bool AdventureResConf::has_terraincellsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureResConf::set_has_terraincellsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureResConf::clear_has_terraincellsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureResConf::clear_terraincellsize() {
  if (terraincellsize_ != NULL) terraincellsize_->::pb::PbVector2::Clear();
  clear_has_terraincellsize();
}
inline const ::pb::PbVector2& AdventureResConf::terraincellsize() const {
  // @@protoc_insertion_point(field_get:pb.AdventureResConf.TerrainCellSize)
  return terraincellsize_ != NULL ? *terraincellsize_ : *default_instance_->terraincellsize_;
}
inline ::pb::PbVector2* AdventureResConf::mutable_terraincellsize() {
  set_has_terraincellsize();
  if (terraincellsize_ == NULL) terraincellsize_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AdventureResConf.TerrainCellSize)
  return terraincellsize_;
}
inline ::pb::PbVector2* AdventureResConf::release_terraincellsize() {
  clear_has_terraincellsize();
  ::pb::PbVector2* temp = terraincellsize_;
  terraincellsize_ = NULL;
  return temp;
}
inline void AdventureResConf::set_allocated_terraincellsize(::pb::PbVector2* terraincellsize) {
  delete terraincellsize_;
  terraincellsize_ = terraincellsize;
  if (terraincellsize) {
    set_has_terraincellsize();
  } else {
    clear_has_terraincellsize();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureResConf.TerrainCellSize)
}

// repeated .pb.TemplateConf TemplateConfArr = 3;
inline int AdventureResConf::templateconfarr_size() const {
  return templateconfarr_.size();
}
inline void AdventureResConf::clear_templateconfarr() {
  templateconfarr_.Clear();
}
inline const ::pb::TemplateConf& AdventureResConf::templateconfarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureResConf.TemplateConfArr)
  return templateconfarr_.Get(index);
}
inline ::pb::TemplateConf* AdventureResConf::mutable_templateconfarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureResConf.TemplateConfArr)
  return templateconfarr_.Mutable(index);
}
inline ::pb::TemplateConf* AdventureResConf::add_templateconfarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureResConf.TemplateConfArr)
  return templateconfarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TemplateConf >&
AdventureResConf::templateconfarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureResConf.TemplateConfArr)
  return templateconfarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TemplateConf >*
AdventureResConf::mutable_templateconfarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureResConf.TemplateConfArr)
  return &templateconfarr_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fAdventureResConf_2eproto__INCLUDED
