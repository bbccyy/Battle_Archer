// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net/Firewall.proto

#ifndef PROTOBUF_net_2fFirewall_2eproto__INCLUDED
#define PROTOBUF_net_2fFirewall_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "net/Battle.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_net_2fFirewall_2eproto();
void protobuf_AssignDesc_net_2fFirewall_2eproto();
void protobuf_ShutdownFile_net_2fFirewall_2eproto();

class TBanUserReq;
class TIllegalBehaviorReq;
class TFrontendVerErrReq;
class TFirewallVerMistake;
class TFirewallCheckReq;
class TFirewallCheckRsp;
class TFirewallCheckBattleArgs;

enum EFirewallCheckType {
  EFirewallCheckBattleArgs = 1
};
bool EFirewallCheckType_IsValid(int value);
const EFirewallCheckType EFirewallCheckType_MIN = EFirewallCheckBattleArgs;
const EFirewallCheckType EFirewallCheckType_MAX = EFirewallCheckBattleArgs;
const int EFirewallCheckType_ARRAYSIZE = EFirewallCheckType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFirewallCheckType_descriptor();
inline const ::std::string& EFirewallCheckType_Name(EFirewallCheckType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFirewallCheckType_descriptor(), value);
}
inline bool EFirewallCheckType_Parse(
    const ::std::string& name, EFirewallCheckType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFirewallCheckType>(
    EFirewallCheckType_descriptor(), name, value);
}
// ===================================================================

/*FOR2LUA
<Record>
	<name>TBanUserReq</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TBanUserReq : public ::google::protobuf::Message {
 public:
  TBanUserReq();
  virtual ~TBanUserReq();

  TBanUserReq(const TBanUserReq& from);

  inline TBanUserReq& operator=(const TBanUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TBanUserReq& default_instance();

  void Swap(TBanUserReq* other);

  // implements Message ----------------------------------------------

  TBanUserReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TBanUserReq& from);
  void MergeFrom(const TBanUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TBanUserReq</name>
  	<Function>
  		<name>uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 BanTime = 2;
  inline bool has_bantime() const;
  inline void clear_bantime();
  static const int kBanTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TBanUserReq</name>
  	<Function>
  		<name>bantime</name>
  		<replaceName>BanTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_bantime</name>
  		<replaceName>BanTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_bantime</name>
  		<replaceName>BanTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 bantime() const;
  inline void set_bantime(::google::protobuf::uint64 value);

  // optional uint64 LocalizeId = 3;
  inline bool has_localizeid() const;
  inline void clear_localizeid();
  static const int kLocalizeIdFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TBanUserReq</name>
  	<Function>
  		<name>localizeid</name>
  		<replaceName>LocalizeId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_localizeid</name>
  		<replaceName>LocalizeId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_localizeid</name>
  		<replaceName>LocalizeId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 localizeid() const;
  inline void set_localizeid(::google::protobuf::uint64 value);

  // optional uint32 BattleStarter = 4;
  inline bool has_battlestarter() const;
  inline void clear_battlestarter();
  static const int kBattleStarterFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TBanUserReq</name>
  	<Function>
  		<name>battlestarter</name>
  		<replaceName>BattleStarter</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_battlestarter</name>
  		<replaceName>BattleStarter</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_battlestarter</name>
  		<replaceName>BattleStarter</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 battlestarter() const;
  inline void set_battlestarter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.TBanUserReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_bantime();
  inline void clear_has_bantime();
  inline void set_has_localizeid();
  inline void clear_has_localizeid();
  inline void set_has_battlestarter();
  inline void clear_has_battlestarter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 bantime_;
  ::google::protobuf::uint64 localizeid_;
  ::google::protobuf::uint32 battlestarter_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TBanUserReq* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TIllegalBehaviorReq</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TIllegalBehaviorReq : public ::google::protobuf::Message {
 public:
  TIllegalBehaviorReq();
  virtual ~TIllegalBehaviorReq();

  TIllegalBehaviorReq(const TIllegalBehaviorReq& from);

  inline TIllegalBehaviorReq& operator=(const TIllegalBehaviorReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TIllegalBehaviorReq& default_instance();

  void Swap(TIllegalBehaviorReq* other);

  // implements Message ----------------------------------------------

  TIllegalBehaviorReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TIllegalBehaviorReq& from);
  void MergeFrom(const TIllegalBehaviorReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TIllegalBehaviorReq</name>
  	<Function>
  		<name>uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 BattleInfoid = 2;
  inline bool has_battleinfoid() const;
  inline void clear_battleinfoid();
  static const int kBattleInfoidFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TIllegalBehaviorReq</name>
  	<Function>
  		<name>battleinfoid</name>
  		<replaceName>BattleInfoid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_battleinfoid</name>
  		<replaceName>BattleInfoid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_battleinfoid</name>
  		<replaceName>BattleInfoid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 battleinfoid() const;
  inline void set_battleinfoid(::google::protobuf::uint32 value);

  // required uint32 TriggerCount = 3;
  inline bool has_triggercount() const;
  inline void clear_triggercount();
  static const int kTriggerCountFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TIllegalBehaviorReq</name>
  	<Function>
  		<name>triggercount</name>
  		<replaceName>TriggerCount</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggercount</name>
  		<replaceName>TriggerCount</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggercount</name>
  		<replaceName>TriggerCount</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 triggercount() const;
  inline void set_triggercount(::google::protobuf::uint32 value);

  // optional uint32 BattleStarter = 4;
  inline bool has_battlestarter() const;
  inline void clear_battlestarter();
  static const int kBattleStarterFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TIllegalBehaviorReq</name>
  	<Function>
  		<name>battlestarter</name>
  		<replaceName>BattleStarter</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_battlestarter</name>
  		<replaceName>BattleStarter</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_battlestarter</name>
  		<replaceName>BattleStarter</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 battlestarter() const;
  inline void set_battlestarter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.TIllegalBehaviorReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_battleinfoid();
  inline void clear_has_battleinfoid();
  inline void set_has_triggercount();
  inline void clear_has_triggercount();
  inline void set_has_battlestarter();
  inline void clear_has_battlestarter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 battleinfoid_;
  ::google::protobuf::uint32 triggercount_;
  ::google::protobuf::uint32 battlestarter_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TIllegalBehaviorReq* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TFrontendVerErrReq</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TFrontendVerErrReq : public ::google::protobuf::Message {
 public:
  TFrontendVerErrReq();
  virtual ~TFrontendVerErrReq();

  TFrontendVerErrReq(const TFrontendVerErrReq& from);

  inline TFrontendVerErrReq& operator=(const TFrontendVerErrReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFrontendVerErrReq& default_instance();

  void Swap(TFrontendVerErrReq* other);

  // implements Message ----------------------------------------------

  TFrontendVerErrReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFrontendVerErrReq& from);
  void MergeFrom(const TFrontendVerErrReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TFrontendVerErrReq</name>
  	<Function>
  		<name>uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string FrontendVer = 2;
  inline bool has_frontendver() const;
  inline void clear_frontendver();
  static const int kFrontendVerFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TFrontendVerErrReq</name>
  	<Function>
  		<name>frontendver</name>
  		<replaceName>FrontendVer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_frontendver</name>
  		<replaceName>FrontendVer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_frontendver</name>
  		<replaceName>FrontendVer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& frontendver() const;
  inline void set_frontendver(const ::std::string& value);
  inline void set_frontendver(const char* value);
  inline void set_frontendver(const char* value, size_t size);
  inline ::std::string* mutable_frontendver();
  inline ::std::string* release_frontendver();
  inline void set_allocated_frontendver(::std::string* frontendver);

  // optional string PlatformFrontendVer = 3;
  inline bool has_platformfrontendver() const;
  inline void clear_platformfrontendver();
  static const int kPlatformFrontendVerFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TFrontendVerErrReq</name>
  	<Function>
  		<name>platformfrontendver</name>
  		<replaceName>PlatformFrontendVer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_platformfrontendver</name>
  		<replaceName>PlatformFrontendVer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_platformfrontendver</name>
  		<replaceName>PlatformFrontendVer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& platformfrontendver() const;
  inline void set_platformfrontendver(const ::std::string& value);
  inline void set_platformfrontendver(const char* value);
  inline void set_platformfrontendver(const char* value, size_t size);
  inline ::std::string* mutable_platformfrontendver();
  inline ::std::string* release_platformfrontendver();
  inline void set_allocated_platformfrontendver(::std::string* platformfrontendver);

  // @@protoc_insertion_point(class_scope:pb.TFrontendVerErrReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_frontendver();
  inline void clear_has_frontendver();
  inline void set_has_platformfrontendver();
  inline void clear_has_platformfrontendver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uid_;
  ::std::string* frontendver_;
  ::std::string* platformfrontendver_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TFrontendVerErrReq* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TFirewallVerMistake</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TFirewallVerMistake : public ::google::protobuf::Message {
 public:
  TFirewallVerMistake();
  virtual ~TFirewallVerMistake();

  TFirewallVerMistake(const TFirewallVerMistake& from);

  inline TFirewallVerMistake& operator=(const TFirewallVerMistake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFirewallVerMistake& default_instance();

  void Swap(TFirewallVerMistake* other);

  // implements Message ----------------------------------------------

  TFirewallVerMistake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFirewallVerMistake& from);
  void MergeFrom(const TFirewallVerMistake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string FrontVer = 1;
  inline bool has_frontver() const;
  inline void clear_frontver();
  static const int kFrontVerFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TFirewallVerMistake</name>
  	<Function>
  		<name>frontver</name>
  		<replaceName>FrontVer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_frontver</name>
  		<replaceName>FrontVer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_frontver</name>
  		<replaceName>FrontVer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& frontver() const;
  inline void set_frontver(const ::std::string& value);
  inline void set_frontver(const char* value);
  inline void set_frontver(const char* value, size_t size);
  inline ::std::string* mutable_frontver();
  inline ::std::string* release_frontver();
  inline void set_allocated_frontver(::std::string* frontver);

  // optional string BackVer = 2;
  inline bool has_backver() const;
  inline void clear_backver();
  static const int kBackVerFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TFirewallVerMistake</name>
  	<Function>
  		<name>backver</name>
  		<replaceName>BackVer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_backver</name>
  		<replaceName>BackVer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_backver</name>
  		<replaceName>BackVer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& backver() const;
  inline void set_backver(const ::std::string& value);
  inline void set_backver(const char* value);
  inline void set_backver(const char* value, size_t size);
  inline ::std::string* mutable_backver();
  inline ::std::string* release_backver();
  inline void set_allocated_backver(::std::string* backver);

  // @@protoc_insertion_point(class_scope:pb.TFirewallVerMistake)
 private:
  inline void set_has_frontver();
  inline void clear_has_frontver();
  inline void set_has_backver();
  inline void clear_has_backver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* frontver_;
  ::std::string* backver_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TFirewallVerMistake* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TFirewallCheckReq</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TFirewallCheckReq : public ::google::protobuf::Message {
 public:
  TFirewallCheckReq();
  virtual ~TFirewallCheckReq();

  TFirewallCheckReq(const TFirewallCheckReq& from);

  inline TFirewallCheckReq& operator=(const TFirewallCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFirewallCheckReq& default_instance();

  void Swap(TFirewallCheckReq* other);

  // implements Message ----------------------------------------------

  TFirewallCheckReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFirewallCheckReq& from);
  void MergeFrom(const TFirewallCheckReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EFirewallCheckType CheckType = 1;
  inline bool has_checktype() const;
  inline void clear_checktype();
  static const int kCheckTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckReq</name>
  	<Function>
  		<name>checktype</name>
  		<replaceName>CheckType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_checktype</name>
  		<replaceName>CheckType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_checktype</name>
  		<replaceName>CheckType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EFirewallCheckType checktype() const;
  inline void set_checktype(::pb::EFirewallCheckType value);

  // optional string FrontendVer = 2;
  inline bool has_frontendver() const;
  inline void clear_frontendver();
  static const int kFrontendVerFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckReq</name>
  	<Function>
  		<name>frontendver</name>
  		<replaceName>FrontendVer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_frontendver</name>
  		<replaceName>FrontendVer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_frontendver</name>
  		<replaceName>FrontendVer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& frontendver() const;
  inline void set_frontendver(const ::std::string& value);
  inline void set_frontendver(const char* value);
  inline void set_frontendver(const char* value, size_t size);
  inline ::std::string* mutable_frontendver();
  inline ::std::string* release_frontendver();
  inline void set_allocated_frontendver(::std::string* frontendver);

  // optional string BattleConfVer = 3;
  inline bool has_battleconfver() const;
  inline void clear_battleconfver();
  static const int kBattleConfVerFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckReq</name>
  	<Function>
  		<name>battleconfver</name>
  		<replaceName>BattleConfVer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_battleconfver</name>
  		<replaceName>BattleConfVer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_battleconfver</name>
  		<replaceName>BattleConfVer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& battleconfver() const;
  inline void set_battleconfver(const ::std::string& value);
  inline void set_battleconfver(const char* value);
  inline void set_battleconfver(const char* value, size_t size);
  inline ::std::string* mutable_battleconfver();
  inline ::std::string* release_battleconfver();
  inline void set_allocated_battleconfver(::std::string* battleconfver);

  // optional bytes CheckData = 4;
  inline bool has_checkdata() const;
  inline void clear_checkdata();
  static const int kCheckDataFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckReq</name>
  	<Function>
  		<name>checkdata</name>
  		<replaceName>CheckData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_checkdata</name>
  		<replaceName>CheckData</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_checkdata</name>
  		<replaceName>CheckData</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& checkdata() const;
  inline void set_checkdata(const ::std::string& value);
  inline void set_checkdata(const char* value);
  inline void set_checkdata(const void* value, size_t size);
  inline ::std::string* mutable_checkdata();
  inline ::std::string* release_checkdata();
  inline void set_allocated_checkdata(::std::string* checkdata);

  // @@protoc_insertion_point(class_scope:pb.TFirewallCheckReq)
 private:
  inline void set_has_checktype();
  inline void clear_has_checktype();
  inline void set_has_frontendver();
  inline void clear_has_frontendver();
  inline void set_has_battleconfver();
  inline void clear_has_battleconfver();
  inline void set_has_checkdata();
  inline void clear_has_checkdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* frontendver_;
  ::std::string* battleconfver_;
  ::std::string* checkdata_;
  int checktype_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TFirewallCheckReq* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TFirewallCheckRsp</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TFirewallCheckRsp : public ::google::protobuf::Message {
 public:
  TFirewallCheckRsp();
  virtual ~TFirewallCheckRsp();

  TFirewallCheckRsp(const TFirewallCheckRsp& from);

  inline TFirewallCheckRsp& operator=(const TFirewallCheckRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFirewallCheckRsp& default_instance();

  void Swap(TFirewallCheckRsp* other);

  // implements Message ----------------------------------------------

  TFirewallCheckRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFirewallCheckRsp& from);
  void MergeFrom(const TFirewallCheckRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EFirewallCheckType CheckType = 1;
  inline bool has_checktype() const;
  inline void clear_checktype();
  static const int kCheckTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckRsp</name>
  	<Function>
  		<name>checktype</name>
  		<replaceName>CheckType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_checktype</name>
  		<replaceName>CheckType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_checktype</name>
  		<replaceName>CheckType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EFirewallCheckType checktype() const;
  inline void set_checktype(::pb::EFirewallCheckType value);

  // optional uint32 CheckStatus = 2;
  inline bool has_checkstatus() const;
  inline void clear_checkstatus();
  static const int kCheckStatusFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckRsp</name>
  	<Function>
  		<name>checkstatus</name>
  		<replaceName>CheckStatus</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_checkstatus</name>
  		<replaceName>CheckStatus</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_checkstatus</name>
  		<replaceName>CheckStatus</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 checkstatus() const;
  inline void set_checkstatus(::google::protobuf::uint32 value);

  // optional string CheckMsg = 3;
  inline bool has_checkmsg() const;
  inline void clear_checkmsg();
  static const int kCheckMsgFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckRsp</name>
  	<Function>
  		<name>checkmsg</name>
  		<replaceName>CheckMsg</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_checkmsg</name>
  		<replaceName>CheckMsg</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_checkmsg</name>
  		<replaceName>CheckMsg</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& checkmsg() const;
  inline void set_checkmsg(const ::std::string& value);
  inline void set_checkmsg(const char* value);
  inline void set_checkmsg(const char* value, size_t size);
  inline ::std::string* mutable_checkmsg();
  inline ::std::string* release_checkmsg();
  inline void set_allocated_checkmsg(::std::string* checkmsg);

  // @@protoc_insertion_point(class_scope:pb.TFirewallCheckRsp)
 private:
  inline void set_has_checktype();
  inline void clear_has_checktype();
  inline void set_has_checkstatus();
  inline void clear_has_checkstatus();
  inline void set_has_checkmsg();
  inline void clear_has_checkmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int checktype_;
  ::google::protobuf::uint32 checkstatus_;
  ::std::string* checkmsg_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TFirewallCheckRsp* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TFirewallCheckBattleArgs</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>net/Firewall.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TFirewallCheckBattleArgs : public ::google::protobuf::Message {
 public:
  TFirewallCheckBattleArgs();
  virtual ~TFirewallCheckBattleArgs();

  TFirewallCheckBattleArgs(const TFirewallCheckBattleArgs& from);

  inline TFirewallCheckBattleArgs& operator=(const TFirewallCheckBattleArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFirewallCheckBattleArgs& default_instance();

  void Swap(TFirewallCheckBattleArgs* other);

  // implements Message ----------------------------------------------

  TFirewallCheckBattleArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFirewallCheckBattleArgs& from);
  void MergeFrom(const TFirewallCheckBattleArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.TBattleArgs FrontendBattleArgs = 1;
  inline bool has_frontendbattleargs() const;
  inline void clear_frontendbattleargs();
  static const int kFrontendBattleArgsFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckBattleArgs</name>
  	<Function>
  		<name>frontendbattleargs</name>
  		<replaceName>FrontendBattleArgs</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_frontendbattleargs</name>
  		<replaceName>FrontendBattleArgs</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_frontendbattleargs</name>
  		<replaceName>FrontendBattleArgs</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_frontendbattleargs</name>
  		<replaceName>FrontendBattleArgs</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TBattleArgs& frontendbattleargs() const;
  inline ::pb::TBattleArgs* mutable_frontendbattleargs();
  inline ::pb::TBattleArgs* release_frontendbattleargs();
  inline void set_allocated_frontendbattleargs(::pb::TBattleArgs* frontendbattleargs);

  // required .pb.TBattleArgs BackendBattleArgs = 2;
  inline bool has_backendbattleargs() const;
  inline void clear_backendbattleargs();
  static const int kBackendBattleArgsFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TFirewallCheckBattleArgs</name>
  	<Function>
  		<name>backendbattleargs</name>
  		<replaceName>BackendBattleArgs</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_backendbattleargs</name>
  		<replaceName>BackendBattleArgs</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_backendbattleargs</name>
  		<replaceName>BackendBattleArgs</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_backendbattleargs</name>
  		<replaceName>BackendBattleArgs</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TBattleArgs& backendbattleargs() const;
  inline ::pb::TBattleArgs* mutable_backendbattleargs();
  inline ::pb::TBattleArgs* release_backendbattleargs();
  inline void set_allocated_backendbattleargs(::pb::TBattleArgs* backendbattleargs);

  // @@protoc_insertion_point(class_scope:pb.TFirewallCheckBattleArgs)
 private:
  inline void set_has_frontendbattleargs();
  inline void clear_has_frontendbattleargs();
  inline void set_has_backendbattleargs();
  inline void clear_has_backendbattleargs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::TBattleArgs* frontendbattleargs_;
  ::pb::TBattleArgs* backendbattleargs_;
  friend void  protobuf_AddDesc_net_2fFirewall_2eproto();
  friend void protobuf_AssignDesc_net_2fFirewall_2eproto();
  friend void protobuf_ShutdownFile_net_2fFirewall_2eproto();

  void InitAsDefaultInstance();
  static TFirewallCheckBattleArgs* default_instance_;
};
// ===================================================================


// ===================================================================

// TBanUserReq

// optional uint64 Uid = 1;
inline bool TBanUserReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TBanUserReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TBanUserReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TBanUserReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 TBanUserReq::uid() const {
  // @@protoc_insertion_point(field_get:pb.TBanUserReq.Uid)
  return uid_;
}
inline void TBanUserReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:pb.TBanUserReq.Uid)
}

// optional uint64 BanTime = 2;
inline bool TBanUserReq::has_bantime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TBanUserReq::set_has_bantime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TBanUserReq::clear_has_bantime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TBanUserReq::clear_bantime() {
  bantime_ = GOOGLE_ULONGLONG(0);
  clear_has_bantime();
}
inline ::google::protobuf::uint64 TBanUserReq::bantime() const {
  // @@protoc_insertion_point(field_get:pb.TBanUserReq.BanTime)
  return bantime_;
}
inline void TBanUserReq::set_bantime(::google::protobuf::uint64 value) {
  set_has_bantime();
  bantime_ = value;
  // @@protoc_insertion_point(field_set:pb.TBanUserReq.BanTime)
}

// optional uint64 LocalizeId = 3;
inline bool TBanUserReq::has_localizeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TBanUserReq::set_has_localizeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TBanUserReq::clear_has_localizeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TBanUserReq::clear_localizeid() {
  localizeid_ = GOOGLE_ULONGLONG(0);
  clear_has_localizeid();
}
inline ::google::protobuf::uint64 TBanUserReq::localizeid() const {
  // @@protoc_insertion_point(field_get:pb.TBanUserReq.LocalizeId)
  return localizeid_;
}
inline void TBanUserReq::set_localizeid(::google::protobuf::uint64 value) {
  set_has_localizeid();
  localizeid_ = value;
  // @@protoc_insertion_point(field_set:pb.TBanUserReq.LocalizeId)
}

// optional uint32 BattleStarter = 4;
inline bool TBanUserReq::has_battlestarter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TBanUserReq::set_has_battlestarter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TBanUserReq::clear_has_battlestarter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TBanUserReq::clear_battlestarter() {
  battlestarter_ = 0u;
  clear_has_battlestarter();
}
inline ::google::protobuf::uint32 TBanUserReq::battlestarter() const {
  // @@protoc_insertion_point(field_get:pb.TBanUserReq.BattleStarter)
  return battlestarter_;
}
inline void TBanUserReq::set_battlestarter(::google::protobuf::uint32 value) {
  set_has_battlestarter();
  battlestarter_ = value;
  // @@protoc_insertion_point(field_set:pb.TBanUserReq.BattleStarter)
}

// -------------------------------------------------------------------

// TIllegalBehaviorReq

// required uint64 Uid = 1;
inline bool TIllegalBehaviorReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TIllegalBehaviorReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TIllegalBehaviorReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TIllegalBehaviorReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 TIllegalBehaviorReq::uid() const {
  // @@protoc_insertion_point(field_get:pb.TIllegalBehaviorReq.Uid)
  return uid_;
}
inline void TIllegalBehaviorReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:pb.TIllegalBehaviorReq.Uid)
}

// required uint32 BattleInfoid = 2;
inline bool TIllegalBehaviorReq::has_battleinfoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TIllegalBehaviorReq::set_has_battleinfoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TIllegalBehaviorReq::clear_has_battleinfoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TIllegalBehaviorReq::clear_battleinfoid() {
  battleinfoid_ = 0u;
  clear_has_battleinfoid();
}
inline ::google::protobuf::uint32 TIllegalBehaviorReq::battleinfoid() const {
  // @@protoc_insertion_point(field_get:pb.TIllegalBehaviorReq.BattleInfoid)
  return battleinfoid_;
}
inline void TIllegalBehaviorReq::set_battleinfoid(::google::protobuf::uint32 value) {
  set_has_battleinfoid();
  battleinfoid_ = value;
  // @@protoc_insertion_point(field_set:pb.TIllegalBehaviorReq.BattleInfoid)
}

// required uint32 TriggerCount = 3;
inline bool TIllegalBehaviorReq::has_triggercount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TIllegalBehaviorReq::set_has_triggercount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TIllegalBehaviorReq::clear_has_triggercount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TIllegalBehaviorReq::clear_triggercount() {
  triggercount_ = 0u;
  clear_has_triggercount();
}
inline ::google::protobuf::uint32 TIllegalBehaviorReq::triggercount() const {
  // @@protoc_insertion_point(field_get:pb.TIllegalBehaviorReq.TriggerCount)
  return triggercount_;
}
inline void TIllegalBehaviorReq::set_triggercount(::google::protobuf::uint32 value) {
  set_has_triggercount();
  triggercount_ = value;
  // @@protoc_insertion_point(field_set:pb.TIllegalBehaviorReq.TriggerCount)
}

// optional uint32 BattleStarter = 4;
inline bool TIllegalBehaviorReq::has_battlestarter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TIllegalBehaviorReq::set_has_battlestarter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TIllegalBehaviorReq::clear_has_battlestarter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TIllegalBehaviorReq::clear_battlestarter() {
  battlestarter_ = 0u;
  clear_has_battlestarter();
}
inline ::google::protobuf::uint32 TIllegalBehaviorReq::battlestarter() const {
  // @@protoc_insertion_point(field_get:pb.TIllegalBehaviorReq.BattleStarter)
  return battlestarter_;
}
inline void TIllegalBehaviorReq::set_battlestarter(::google::protobuf::uint32 value) {
  set_has_battlestarter();
  battlestarter_ = value;
  // @@protoc_insertion_point(field_set:pb.TIllegalBehaviorReq.BattleStarter)
}

// -------------------------------------------------------------------

// TFrontendVerErrReq

// optional uint64 Uid = 1;
inline bool TFrontendVerErrReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFrontendVerErrReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFrontendVerErrReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFrontendVerErrReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 TFrontendVerErrReq::uid() const {
  // @@protoc_insertion_point(field_get:pb.TFrontendVerErrReq.Uid)
  return uid_;
}
inline void TFrontendVerErrReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:pb.TFrontendVerErrReq.Uid)
}

// optional string FrontendVer = 2;
inline bool TFrontendVerErrReq::has_frontendver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFrontendVerErrReq::set_has_frontendver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFrontendVerErrReq::clear_has_frontendver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFrontendVerErrReq::clear_frontendver() {
  if (frontendver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_->clear();
  }
  clear_has_frontendver();
}
inline const ::std::string& TFrontendVerErrReq::frontendver() const {
  // @@protoc_insertion_point(field_get:pb.TFrontendVerErrReq.FrontendVer)
  return *frontendver_;
}
inline void TFrontendVerErrReq::set_frontendver(const ::std::string& value) {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  frontendver_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFrontendVerErrReq.FrontendVer)
}
inline void TFrontendVerErrReq::set_frontendver(const char* value) {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  frontendver_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFrontendVerErrReq.FrontendVer)
}
inline void TFrontendVerErrReq::set_frontendver(const char* value, size_t size) {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  frontendver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFrontendVerErrReq.FrontendVer)
}
inline ::std::string* TFrontendVerErrReq::mutable_frontendver() {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFrontendVerErrReq.FrontendVer)
  return frontendver_;
}
inline ::std::string* TFrontendVerErrReq::release_frontendver() {
  clear_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = frontendver_;
    frontendver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFrontendVerErrReq::set_allocated_frontendver(::std::string* frontendver) {
  if (frontendver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete frontendver_;
  }
  if (frontendver) {
    set_has_frontendver();
    frontendver_ = frontendver;
  } else {
    clear_has_frontendver();
    frontendver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFrontendVerErrReq.FrontendVer)
}

// optional string PlatformFrontendVer = 3;
inline bool TFrontendVerErrReq::has_platformfrontendver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TFrontendVerErrReq::set_has_platformfrontendver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TFrontendVerErrReq::clear_has_platformfrontendver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TFrontendVerErrReq::clear_platformfrontendver() {
  if (platformfrontendver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platformfrontendver_->clear();
  }
  clear_has_platformfrontendver();
}
inline const ::std::string& TFrontendVerErrReq::platformfrontendver() const {
  // @@protoc_insertion_point(field_get:pb.TFrontendVerErrReq.PlatformFrontendVer)
  return *platformfrontendver_;
}
inline void TFrontendVerErrReq::set_platformfrontendver(const ::std::string& value) {
  set_has_platformfrontendver();
  if (platformfrontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platformfrontendver_ = new ::std::string;
  }
  platformfrontendver_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFrontendVerErrReq.PlatformFrontendVer)
}
inline void TFrontendVerErrReq::set_platformfrontendver(const char* value) {
  set_has_platformfrontendver();
  if (platformfrontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platformfrontendver_ = new ::std::string;
  }
  platformfrontendver_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFrontendVerErrReq.PlatformFrontendVer)
}
inline void TFrontendVerErrReq::set_platformfrontendver(const char* value, size_t size) {
  set_has_platformfrontendver();
  if (platformfrontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platformfrontendver_ = new ::std::string;
  }
  platformfrontendver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFrontendVerErrReq.PlatformFrontendVer)
}
inline ::std::string* TFrontendVerErrReq::mutable_platformfrontendver() {
  set_has_platformfrontendver();
  if (platformfrontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platformfrontendver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFrontendVerErrReq.PlatformFrontendVer)
  return platformfrontendver_;
}
inline ::std::string* TFrontendVerErrReq::release_platformfrontendver() {
  clear_has_platformfrontendver();
  if (platformfrontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = platformfrontendver_;
    platformfrontendver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFrontendVerErrReq::set_allocated_platformfrontendver(::std::string* platformfrontendver) {
  if (platformfrontendver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete platformfrontendver_;
  }
  if (platformfrontendver) {
    set_has_platformfrontendver();
    platformfrontendver_ = platformfrontendver;
  } else {
    clear_has_platformfrontendver();
    platformfrontendver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFrontendVerErrReq.PlatformFrontendVer)
}

// -------------------------------------------------------------------

// TFirewallVerMistake

// optional string FrontVer = 1;
inline bool TFirewallVerMistake::has_frontver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFirewallVerMistake::set_has_frontver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFirewallVerMistake::clear_has_frontver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFirewallVerMistake::clear_frontver() {
  if (frontver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontver_->clear();
  }
  clear_has_frontver();
}
inline const ::std::string& TFirewallVerMistake::frontver() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallVerMistake.FrontVer)
  return *frontver_;
}
inline void TFirewallVerMistake::set_frontver(const ::std::string& value) {
  set_has_frontver();
  if (frontver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontver_ = new ::std::string;
  }
  frontver_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFirewallVerMistake.FrontVer)
}
inline void TFirewallVerMistake::set_frontver(const char* value) {
  set_has_frontver();
  if (frontver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontver_ = new ::std::string;
  }
  frontver_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFirewallVerMistake.FrontVer)
}
inline void TFirewallVerMistake::set_frontver(const char* value, size_t size) {
  set_has_frontver();
  if (frontver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontver_ = new ::std::string;
  }
  frontver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFirewallVerMistake.FrontVer)
}
inline ::std::string* TFirewallVerMistake::mutable_frontver() {
  set_has_frontver();
  if (frontver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFirewallVerMistake.FrontVer)
  return frontver_;
}
inline ::std::string* TFirewallVerMistake::release_frontver() {
  clear_has_frontver();
  if (frontver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = frontver_;
    frontver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFirewallVerMistake::set_allocated_frontver(::std::string* frontver) {
  if (frontver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete frontver_;
  }
  if (frontver) {
    set_has_frontver();
    frontver_ = frontver;
  } else {
    clear_has_frontver();
    frontver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallVerMistake.FrontVer)
}

// optional string BackVer = 2;
inline bool TFirewallVerMistake::has_backver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFirewallVerMistake::set_has_backver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFirewallVerMistake::clear_has_backver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFirewallVerMistake::clear_backver() {
  if (backver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backver_->clear();
  }
  clear_has_backver();
}
inline const ::std::string& TFirewallVerMistake::backver() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallVerMistake.BackVer)
  return *backver_;
}
inline void TFirewallVerMistake::set_backver(const ::std::string& value) {
  set_has_backver();
  if (backver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backver_ = new ::std::string;
  }
  backver_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFirewallVerMistake.BackVer)
}
inline void TFirewallVerMistake::set_backver(const char* value) {
  set_has_backver();
  if (backver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backver_ = new ::std::string;
  }
  backver_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFirewallVerMistake.BackVer)
}
inline void TFirewallVerMistake::set_backver(const char* value, size_t size) {
  set_has_backver();
  if (backver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backver_ = new ::std::string;
  }
  backver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFirewallVerMistake.BackVer)
}
inline ::std::string* TFirewallVerMistake::mutable_backver() {
  set_has_backver();
  if (backver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFirewallVerMistake.BackVer)
  return backver_;
}
inline ::std::string* TFirewallVerMistake::release_backver() {
  clear_has_backver();
  if (backver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backver_;
    backver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFirewallVerMistake::set_allocated_backver(::std::string* backver) {
  if (backver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backver_;
  }
  if (backver) {
    set_has_backver();
    backver_ = backver;
  } else {
    clear_has_backver();
    backver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallVerMistake.BackVer)
}

// -------------------------------------------------------------------

// TFirewallCheckReq

// required .pb.EFirewallCheckType CheckType = 1;
inline bool TFirewallCheckReq::has_checktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFirewallCheckReq::set_has_checktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFirewallCheckReq::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFirewallCheckReq::clear_checktype() {
  checktype_ = 1;
  clear_has_checktype();
}
inline ::pb::EFirewallCheckType TFirewallCheckReq::checktype() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckReq.CheckType)
  return static_cast< ::pb::EFirewallCheckType >(checktype_);
}
inline void TFirewallCheckReq::set_checktype(::pb::EFirewallCheckType value) {
  assert(::pb::EFirewallCheckType_IsValid(value));
  set_has_checktype();
  checktype_ = value;
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckReq.CheckType)
}

// optional string FrontendVer = 2;
inline bool TFirewallCheckReq::has_frontendver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFirewallCheckReq::set_has_frontendver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFirewallCheckReq::clear_has_frontendver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFirewallCheckReq::clear_frontendver() {
  if (frontendver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_->clear();
  }
  clear_has_frontendver();
}
inline const ::std::string& TFirewallCheckReq::frontendver() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckReq.FrontendVer)
  return *frontendver_;
}
inline void TFirewallCheckReq::set_frontendver(const ::std::string& value) {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  frontendver_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckReq.FrontendVer)
}
inline void TFirewallCheckReq::set_frontendver(const char* value) {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  frontendver_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFirewallCheckReq.FrontendVer)
}
inline void TFirewallCheckReq::set_frontendver(const char* value, size_t size) {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  frontendver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFirewallCheckReq.FrontendVer)
}
inline ::std::string* TFirewallCheckReq::mutable_frontendver() {
  set_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frontendver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFirewallCheckReq.FrontendVer)
  return frontendver_;
}
inline ::std::string* TFirewallCheckReq::release_frontendver() {
  clear_has_frontendver();
  if (frontendver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = frontendver_;
    frontendver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFirewallCheckReq::set_allocated_frontendver(::std::string* frontendver) {
  if (frontendver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete frontendver_;
  }
  if (frontendver) {
    set_has_frontendver();
    frontendver_ = frontendver;
  } else {
    clear_has_frontendver();
    frontendver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallCheckReq.FrontendVer)
}

// optional string BattleConfVer = 3;
inline bool TFirewallCheckReq::has_battleconfver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TFirewallCheckReq::set_has_battleconfver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TFirewallCheckReq::clear_has_battleconfver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TFirewallCheckReq::clear_battleconfver() {
  if (battleconfver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    battleconfver_->clear();
  }
  clear_has_battleconfver();
}
inline const ::std::string& TFirewallCheckReq::battleconfver() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckReq.BattleConfVer)
  return *battleconfver_;
}
inline void TFirewallCheckReq::set_battleconfver(const ::std::string& value) {
  set_has_battleconfver();
  if (battleconfver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    battleconfver_ = new ::std::string;
  }
  battleconfver_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckReq.BattleConfVer)
}
inline void TFirewallCheckReq::set_battleconfver(const char* value) {
  set_has_battleconfver();
  if (battleconfver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    battleconfver_ = new ::std::string;
  }
  battleconfver_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFirewallCheckReq.BattleConfVer)
}
inline void TFirewallCheckReq::set_battleconfver(const char* value, size_t size) {
  set_has_battleconfver();
  if (battleconfver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    battleconfver_ = new ::std::string;
  }
  battleconfver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFirewallCheckReq.BattleConfVer)
}
inline ::std::string* TFirewallCheckReq::mutable_battleconfver() {
  set_has_battleconfver();
  if (battleconfver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    battleconfver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFirewallCheckReq.BattleConfVer)
  return battleconfver_;
}
inline ::std::string* TFirewallCheckReq::release_battleconfver() {
  clear_has_battleconfver();
  if (battleconfver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = battleconfver_;
    battleconfver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFirewallCheckReq::set_allocated_battleconfver(::std::string* battleconfver) {
  if (battleconfver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete battleconfver_;
  }
  if (battleconfver) {
    set_has_battleconfver();
    battleconfver_ = battleconfver;
  } else {
    clear_has_battleconfver();
    battleconfver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallCheckReq.BattleConfVer)
}

// optional bytes CheckData = 4;
inline bool TFirewallCheckReq::has_checkdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TFirewallCheckReq::set_has_checkdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TFirewallCheckReq::clear_has_checkdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TFirewallCheckReq::clear_checkdata() {
  if (checkdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkdata_->clear();
  }
  clear_has_checkdata();
}
inline const ::std::string& TFirewallCheckReq::checkdata() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckReq.CheckData)
  return *checkdata_;
}
inline void TFirewallCheckReq::set_checkdata(const ::std::string& value) {
  set_has_checkdata();
  if (checkdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkdata_ = new ::std::string;
  }
  checkdata_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckReq.CheckData)
}
inline void TFirewallCheckReq::set_checkdata(const char* value) {
  set_has_checkdata();
  if (checkdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkdata_ = new ::std::string;
  }
  checkdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFirewallCheckReq.CheckData)
}
inline void TFirewallCheckReq::set_checkdata(const void* value, size_t size) {
  set_has_checkdata();
  if (checkdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkdata_ = new ::std::string;
  }
  checkdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFirewallCheckReq.CheckData)
}
inline ::std::string* TFirewallCheckReq::mutable_checkdata() {
  set_has_checkdata();
  if (checkdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFirewallCheckReq.CheckData)
  return checkdata_;
}
inline ::std::string* TFirewallCheckReq::release_checkdata() {
  clear_has_checkdata();
  if (checkdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = checkdata_;
    checkdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFirewallCheckReq::set_allocated_checkdata(::std::string* checkdata) {
  if (checkdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete checkdata_;
  }
  if (checkdata) {
    set_has_checkdata();
    checkdata_ = checkdata;
  } else {
    clear_has_checkdata();
    checkdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallCheckReq.CheckData)
}

// -------------------------------------------------------------------

// TFirewallCheckRsp

// required .pb.EFirewallCheckType CheckType = 1;
inline bool TFirewallCheckRsp::has_checktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFirewallCheckRsp::set_has_checktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFirewallCheckRsp::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFirewallCheckRsp::clear_checktype() {
  checktype_ = 1;
  clear_has_checktype();
}
inline ::pb::EFirewallCheckType TFirewallCheckRsp::checktype() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckRsp.CheckType)
  return static_cast< ::pb::EFirewallCheckType >(checktype_);
}
inline void TFirewallCheckRsp::set_checktype(::pb::EFirewallCheckType value) {
  assert(::pb::EFirewallCheckType_IsValid(value));
  set_has_checktype();
  checktype_ = value;
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckRsp.CheckType)
}

// optional uint32 CheckStatus = 2;
inline bool TFirewallCheckRsp::has_checkstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFirewallCheckRsp::set_has_checkstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFirewallCheckRsp::clear_has_checkstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFirewallCheckRsp::clear_checkstatus() {
  checkstatus_ = 0u;
  clear_has_checkstatus();
}
inline ::google::protobuf::uint32 TFirewallCheckRsp::checkstatus() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckRsp.CheckStatus)
  return checkstatus_;
}
inline void TFirewallCheckRsp::set_checkstatus(::google::protobuf::uint32 value) {
  set_has_checkstatus();
  checkstatus_ = value;
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckRsp.CheckStatus)
}

// optional string CheckMsg = 3;
inline bool TFirewallCheckRsp::has_checkmsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TFirewallCheckRsp::set_has_checkmsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TFirewallCheckRsp::clear_has_checkmsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TFirewallCheckRsp::clear_checkmsg() {
  if (checkmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkmsg_->clear();
  }
  clear_has_checkmsg();
}
inline const ::std::string& TFirewallCheckRsp::checkmsg() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckRsp.CheckMsg)
  return *checkmsg_;
}
inline void TFirewallCheckRsp::set_checkmsg(const ::std::string& value) {
  set_has_checkmsg();
  if (checkmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkmsg_ = new ::std::string;
  }
  checkmsg_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TFirewallCheckRsp.CheckMsg)
}
inline void TFirewallCheckRsp::set_checkmsg(const char* value) {
  set_has_checkmsg();
  if (checkmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkmsg_ = new ::std::string;
  }
  checkmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TFirewallCheckRsp.CheckMsg)
}
inline void TFirewallCheckRsp::set_checkmsg(const char* value, size_t size) {
  set_has_checkmsg();
  if (checkmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkmsg_ = new ::std::string;
  }
  checkmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TFirewallCheckRsp.CheckMsg)
}
inline ::std::string* TFirewallCheckRsp::mutable_checkmsg() {
  set_has_checkmsg();
  if (checkmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    checkmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TFirewallCheckRsp.CheckMsg)
  return checkmsg_;
}
inline ::std::string* TFirewallCheckRsp::release_checkmsg() {
  clear_has_checkmsg();
  if (checkmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = checkmsg_;
    checkmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TFirewallCheckRsp::set_allocated_checkmsg(::std::string* checkmsg) {
  if (checkmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete checkmsg_;
  }
  if (checkmsg) {
    set_has_checkmsg();
    checkmsg_ = checkmsg;
  } else {
    clear_has_checkmsg();
    checkmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallCheckRsp.CheckMsg)
}

// -------------------------------------------------------------------

// TFirewallCheckBattleArgs

// required .pb.TBattleArgs FrontendBattleArgs = 1;
inline bool TFirewallCheckBattleArgs::has_frontendbattleargs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TFirewallCheckBattleArgs::set_has_frontendbattleargs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TFirewallCheckBattleArgs::clear_has_frontendbattleargs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TFirewallCheckBattleArgs::clear_frontendbattleargs() {
  if (frontendbattleargs_ != NULL) frontendbattleargs_->::pb::TBattleArgs::Clear();
  clear_has_frontendbattleargs();
}
inline const ::pb::TBattleArgs& TFirewallCheckBattleArgs::frontendbattleargs() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckBattleArgs.FrontendBattleArgs)
  return frontendbattleargs_ != NULL ? *frontendbattleargs_ : *default_instance_->frontendbattleargs_;
}
inline ::pb::TBattleArgs* TFirewallCheckBattleArgs::mutable_frontendbattleargs() {
  set_has_frontendbattleargs();
  if (frontendbattleargs_ == NULL) frontendbattleargs_ = new ::pb::TBattleArgs;
  // @@protoc_insertion_point(field_mutable:pb.TFirewallCheckBattleArgs.FrontendBattleArgs)
  return frontendbattleargs_;
}
inline ::pb::TBattleArgs* TFirewallCheckBattleArgs::release_frontendbattleargs() {
  clear_has_frontendbattleargs();
  ::pb::TBattleArgs* temp = frontendbattleargs_;
  frontendbattleargs_ = NULL;
  return temp;
}
inline void TFirewallCheckBattleArgs::set_allocated_frontendbattleargs(::pb::TBattleArgs* frontendbattleargs) {
  delete frontendbattleargs_;
  frontendbattleargs_ = frontendbattleargs;
  if (frontendbattleargs) {
    set_has_frontendbattleargs();
  } else {
    clear_has_frontendbattleargs();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallCheckBattleArgs.FrontendBattleArgs)
}

// required .pb.TBattleArgs BackendBattleArgs = 2;
inline bool TFirewallCheckBattleArgs::has_backendbattleargs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TFirewallCheckBattleArgs::set_has_backendbattleargs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TFirewallCheckBattleArgs::clear_has_backendbattleargs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TFirewallCheckBattleArgs::clear_backendbattleargs() {
  if (backendbattleargs_ != NULL) backendbattleargs_->::pb::TBattleArgs::Clear();
  clear_has_backendbattleargs();
}
inline const ::pb::TBattleArgs& TFirewallCheckBattleArgs::backendbattleargs() const {
  // @@protoc_insertion_point(field_get:pb.TFirewallCheckBattleArgs.BackendBattleArgs)
  return backendbattleargs_ != NULL ? *backendbattleargs_ : *default_instance_->backendbattleargs_;
}
inline ::pb::TBattleArgs* TFirewallCheckBattleArgs::mutable_backendbattleargs() {
  set_has_backendbattleargs();
  if (backendbattleargs_ == NULL) backendbattleargs_ = new ::pb::TBattleArgs;
  // @@protoc_insertion_point(field_mutable:pb.TFirewallCheckBattleArgs.BackendBattleArgs)
  return backendbattleargs_;
}
inline ::pb::TBattleArgs* TFirewallCheckBattleArgs::release_backendbattleargs() {
  clear_has_backendbattleargs();
  ::pb::TBattleArgs* temp = backendbattleargs_;
  backendbattleargs_ = NULL;
  return temp;
}
inline void TFirewallCheckBattleArgs::set_allocated_backendbattleargs(::pb::TBattleArgs* backendbattleargs) {
  delete backendbattleargs_;
  backendbattleargs_ = backendbattleargs;
  if (backendbattleargs) {
    set_has_backendbattleargs();
  } else {
    clear_has_backendbattleargs();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TFirewallCheckBattleArgs.BackendBattleArgs)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::EFirewallCheckType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EFirewallCheckType>() {
  return ::pb::EFirewallCheckType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_net_2fFirewall_2eproto__INCLUDED
