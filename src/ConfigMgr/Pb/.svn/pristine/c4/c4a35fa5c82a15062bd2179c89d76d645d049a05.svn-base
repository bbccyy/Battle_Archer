// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/BehaviorData.proto

#ifndef PROTOBUF_module_2fBehaviorData_2eproto__INCLUDED
#define PROTOBUF_module_2fBehaviorData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fBehaviorData_2eproto();
void protobuf_AssignDesc_module_2fBehaviorData_2eproto();
void protobuf_ShutdownFile_module_2fBehaviorData_2eproto();

class BehaviorPosition;
class BehaviorKeyValue;
class BehaviorTreeData;
class BehaviorRootData;
class BehaviorData;

enum EBehaviorGroupType {
  AND = 0,
  OR = 1
};
bool EBehaviorGroupType_IsValid(int value);
const EBehaviorGroupType EBehaviorGroupType_MIN = AND;
const EBehaviorGroupType EBehaviorGroupType_MAX = OR;
const int EBehaviorGroupType_ARRAYSIZE = EBehaviorGroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBehaviorGroupType_descriptor();
inline const ::std::string& EBehaviorGroupType_Name(EBehaviorGroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBehaviorGroupType_descriptor(), value);
}
inline bool EBehaviorGroupType_Parse(
    const ::std::string& name, EBehaviorGroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBehaviorGroupType>(
    EBehaviorGroupType_descriptor(), name, value);
}
enum EBehaviorDataType {
  INVALID = 0,
  INT = 1,
  FLOAT = 2,
  STRING = 3,
  INT_ARRAY = 4,
  FLOAT_ARRAY = 5,
  STRING_ARRAY = 6,
  BOOL = 7,
  ASSETPATH = 8,
  ASSETPATH_ARRAY = 9
};
bool EBehaviorDataType_IsValid(int value);
const EBehaviorDataType EBehaviorDataType_MIN = INVALID;
const EBehaviorDataType EBehaviorDataType_MAX = ASSETPATH_ARRAY;
const int EBehaviorDataType_ARRAYSIZE = EBehaviorDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBehaviorDataType_descriptor();
inline const ::std::string& EBehaviorDataType_Name(EBehaviorDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBehaviorDataType_descriptor(), value);
}
inline bool EBehaviorDataType_Parse(
    const ::std::string& name, EBehaviorDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBehaviorDataType>(
    EBehaviorDataType_descriptor(), name, value);
}
// ===================================================================

/*FOR2LUA
<Record>
	<name>BehaviorPosition</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BehaviorData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BehaviorPosition : public ::google::protobuf::Message {
 public:
  BehaviorPosition();
  virtual ~BehaviorPosition();

  BehaviorPosition(const BehaviorPosition& from);

  inline BehaviorPosition& operator=(const BehaviorPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorPosition& default_instance();

  void Swap(BehaviorPosition* other);

  // implements Message ----------------------------------------------

  BehaviorPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorPosition& from);
  void MergeFrom(const BehaviorPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BehaviorPosition</name>
  	<Function>
  		<name>x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 Y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BehaviorPosition</name>
  	<Function>
  		<name>y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BehaviorPosition)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void  protobuf_AddDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_AssignDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBehaviorData_2eproto();

  void InitAsDefaultInstance();
  static BehaviorPosition* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BehaviorKeyValue</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BehaviorData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BehaviorKeyValue : public ::google::protobuf::Message {
 public:
  BehaviorKeyValue();
  virtual ~BehaviorKeyValue();

  BehaviorKeyValue(const BehaviorKeyValue& from);

  inline BehaviorKeyValue& operator=(const BehaviorKeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorKeyValue& default_instance();

  void Swap(BehaviorKeyValue* other);

  // implements Message ----------------------------------------------

  BehaviorKeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorKeyValue& from);
  void MergeFrom(const BehaviorKeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BehaviorKeyValue</name>
  	<Function>
  		<name>key</name>
  		<replaceName>Key</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_key</name>
  		<replaceName>Key</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_key</name>
  		<replaceName>Key</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BehaviorKeyValue</name>
  	<Function>
  		<name>value</name>
  		<replaceName>Value</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_value</name>
  		<replaceName>Value</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_value</name>
  		<replaceName>Value</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .pb.EBehaviorDataType Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BehaviorKeyValue</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EBehaviorDataType type() const;
  inline void set_type(::pb::EBehaviorDataType value);

  // @@protoc_insertion_point(class_scope:pb.BehaviorKeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  int type_;
  friend void  protobuf_AddDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_AssignDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBehaviorData_2eproto();

  void InitAsDefaultInstance();
  static BehaviorKeyValue* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BehaviorTreeData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BehaviorData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BehaviorTreeData : public ::google::protobuf::Message {
 public:
  BehaviorTreeData();
  virtual ~BehaviorTreeData();

  BehaviorTreeData(const BehaviorTreeData& from);

  inline BehaviorTreeData& operator=(const BehaviorTreeData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorTreeData& default_instance();

  void Swap(BehaviorTreeData* other);

  // implements Message ----------------------------------------------

  BehaviorTreeData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorTreeData& from);
  void MergeFrom(const BehaviorTreeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .pb.BehaviorKeyValue Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorKeyValue& data(int index) const;
  inline ::pb::BehaviorKeyValue* mutable_data(int index);
  inline ::pb::BehaviorKeyValue* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >*
      mutable_data();

  // repeated .pb.BehaviorTreeData Child = 3;
  inline int child_size() const;
  inline void clear_child();
  static const int kChildFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>child_size</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorTreeData& child(int index) const;
  inline ::pb::BehaviorTreeData* mutable_child(int index);
  inline ::pb::BehaviorTreeData* add_child();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
      child() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
      mutable_child();

  // optional .pb.BehaviorPosition Position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorPosition& position() const;
  inline ::pb::BehaviorPosition* mutable_position();
  inline ::pb::BehaviorPosition* release_position();
  inline void set_allocated_position(::pb::BehaviorPosition* position);

  // optional int32 NodeID = 5;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>nodeid</name>
  		<replaceName>NodeID</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_nodeid</name>
  		<replaceName>NodeID</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_nodeid</name>
  		<replaceName>NodeID</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 nodeid() const;
  inline void set_nodeid(::google::protobuf::int32 value);

  // repeated int32 PreNodeIDs = 6;
  inline int prenodeids_size() const;
  inline void clear_prenodeids();
  static const int kPreNodeIDsFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>prenodeids</name>
  		<replaceName>PreNodeIDs</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_prenodeids</name>
  		<replaceName>PreNodeIDs</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_prenodeids</name>
  		<replaceName>PreNodeIDs</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_prenodeids</name>
  		<replaceName>PreNodeIDs</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>prenodeids_size</name>
  		<replaceName>PreNodeIDs</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 prenodeids(int index) const;
  inline void set_prenodeids(int index, ::google::protobuf::int32 value);
  inline void add_prenodeids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      prenodeids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_prenodeids();

  // optional .pb.EBehaviorGroupType PreNodeType = 7;
  inline bool has_prenodetype() const;
  inline void clear_prenodetype();
  static const int kPreNodeTypeFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>prenodetype</name>
  		<replaceName>PreNodeType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_prenodetype</name>
  		<replaceName>PreNodeType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_prenodetype</name>
  		<replaceName>PreNodeType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EBehaviorGroupType prenodetype() const;
  inline void set_prenodetype(::pb::EBehaviorGroupType value);

  // optional string Remark = 8;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>BehaviorTreeData</name>
  	<Function>
  		<name>remark</name>
  		<replaceName>Remark</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_remark</name>
  		<replaceName>Remark</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_remark</name>
  		<replaceName>Remark</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pb.BehaviorTreeData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_prenodetype();
  inline void clear_has_prenodetype();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue > data_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData > child_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nodeid_;
  ::pb::BehaviorPosition* position_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > prenodeids_;
  ::std::string* remark_;
  int prenodetype_;
  friend void  protobuf_AddDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_AssignDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBehaviorData_2eproto();

  void InitAsDefaultInstance();
  static BehaviorTreeData* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BehaviorRootData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BehaviorData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BehaviorRootData : public ::google::protobuf::Message {
 public:
  BehaviorRootData();
  virtual ~BehaviorRootData();

  BehaviorRootData(const BehaviorRootData& from);

  inline BehaviorRootData& operator=(const BehaviorRootData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorRootData& default_instance();

  void Swap(BehaviorRootData* other);

  // implements Message ----------------------------------------------

  BehaviorRootData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorRootData& from);
  void MergeFrom(const BehaviorRootData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EBehaviorGroupType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BehaviorRootData</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EBehaviorGroupType type() const;
  inline void set_type(::pb::EBehaviorGroupType value);

  // repeated .pb.BehaviorTreeData Trigger = 2;
  inline int trigger_size() const;
  inline void clear_trigger();
  static const int kTriggerFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BehaviorRootData</name>
  	<Function>
  		<name>trigger</name>
  		<replaceName>Trigger</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_trigger</name>
  		<replaceName>Trigger</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_trigger</name>
  		<replaceName>Trigger</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_trigger</name>
  		<replaceName>Trigger</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>trigger_size</name>
  		<replaceName>Trigger</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorTreeData& trigger(int index) const;
  inline ::pb::BehaviorTreeData* mutable_trigger(int index);
  inline ::pb::BehaviorTreeData* add_trigger();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
      trigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
      mutable_trigger();

  // repeated .pb.BehaviorTreeData Child = 3;
  inline int child_size() const;
  inline void clear_child();
  static const int kChildFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BehaviorRootData</name>
  	<Function>
  		<name>child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_child</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>child_size</name>
  		<replaceName>Child</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorTreeData& child(int index) const;
  inline ::pb::BehaviorTreeData* mutable_child(int index);
  inline ::pb::BehaviorTreeData* add_child();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
      child() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
      mutable_child();

  // optional .pb.BehaviorPosition Position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BehaviorRootData</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorPosition& position() const;
  inline ::pb::BehaviorPosition* mutable_position();
  inline ::pb::BehaviorPosition* release_position();
  inline void set_allocated_position(::pb::BehaviorPosition* position);

  // optional int32 Count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BehaviorRootData</name>
  	<Function>
  		<name>count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_count</name>
  		<replaceName>Count</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.BehaviorRootData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData > trigger_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData > child_;
  int type_;
  ::google::protobuf::int32 count_;
  ::pb::BehaviorPosition* position_;
  friend void  protobuf_AddDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_AssignDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBehaviorData_2eproto();

  void InitAsDefaultInstance();
  static BehaviorRootData* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BehaviorData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/BehaviorData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BehaviorData : public ::google::protobuf::Message {
 public:
  BehaviorData();
  virtual ~BehaviorData();

  BehaviorData(const BehaviorData& from);

  inline BehaviorData& operator=(const BehaviorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorData& default_instance();

  void Swap(BehaviorData* other);

  // implements Message ----------------------------------------------

  BehaviorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorData& from);
  void MergeFrom(const BehaviorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BehaviorData</name>
  	<Function>
  		<name>id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .pb.BehaviorRootData RootData = 2;
  inline int rootdata_size() const;
  inline void clear_rootdata();
  static const int kRootDataFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BehaviorData</name>
  	<Function>
  		<name>rootdata</name>
  		<replaceName>RootData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rootdata</name>
  		<replaceName>RootData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rootdata</name>
  		<replaceName>RootData</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rootdata</name>
  		<replaceName>RootData</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rootdata_size</name>
  		<replaceName>RootData</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorRootData& rootdata(int index) const;
  inline ::pb::BehaviorRootData* mutable_rootdata(int index);
  inline ::pb::BehaviorRootData* add_rootdata();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorRootData >&
      rootdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorRootData >*
      mutable_rootdata();

  // repeated .pb.BehaviorTreeData TreeData = 3;
  inline int treedata_size() const;
  inline void clear_treedata();
  static const int kTreeDataFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BehaviorData</name>
  	<Function>
  		<name>treedata</name>
  		<replaceName>TreeData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_treedata</name>
  		<replaceName>TreeData</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_treedata</name>
  		<replaceName>TreeData</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_treedata</name>
  		<replaceName>TreeData</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>treedata_size</name>
  		<replaceName>TreeData</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorTreeData& treedata(int index) const;
  inline ::pb::BehaviorTreeData* mutable_treedata(int index);
  inline ::pb::BehaviorTreeData* add_treedata();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
      treedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
      mutable_treedata();

  // optional bool notAllowSkip = 4;
  inline bool has_notallowskip() const;
  inline void clear_notallowskip();
  static const int kNotAllowSkipFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BehaviorData</name>
  	<Function>
  		<name>notallowskip</name>
  		<replaceName>notAllowSkip</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_notallowskip</name>
  		<replaceName>notAllowSkip</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_notallowskip</name>
  		<replaceName>notAllowSkip</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool notallowskip() const;
  inline void set_notallowskip(bool value);

  // @@protoc_insertion_point(class_scope:pb.BehaviorData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_notallowskip();
  inline void clear_has_notallowskip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorRootData > rootdata_;
  ::google::protobuf::int32 id_;
  bool notallowskip_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData > treedata_;
  friend void  protobuf_AddDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_AssignDesc_module_2fBehaviorData_2eproto();
  friend void protobuf_ShutdownFile_module_2fBehaviorData_2eproto();

  void InitAsDefaultInstance();
  static BehaviorData* default_instance_;
};
// ===================================================================


// ===================================================================

// BehaviorPosition

// optional int32 X = 1;
inline bool BehaviorPosition::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorPosition::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorPosition::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorPosition::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 BehaviorPosition::x() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorPosition.X)
  return x_;
}
inline void BehaviorPosition::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorPosition.X)
}

// optional int32 Y = 2;
inline bool BehaviorPosition::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BehaviorPosition::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BehaviorPosition::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BehaviorPosition::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 BehaviorPosition::y() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorPosition.Y)
  return y_;
}
inline void BehaviorPosition::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorPosition.Y)
}

// -------------------------------------------------------------------

// BehaviorKeyValue

// optional string Key = 1;
inline bool BehaviorKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorKeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorKeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorKeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& BehaviorKeyValue::key() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorKeyValue.Key)
  return *key_;
}
inline void BehaviorKeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BehaviorKeyValue.Key)
}
inline void BehaviorKeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BehaviorKeyValue.Key)
}
inline void BehaviorKeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BehaviorKeyValue.Key)
}
inline ::std::string* BehaviorKeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BehaviorKeyValue.Key)
  return key_;
}
inline ::std::string* BehaviorKeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BehaviorKeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BehaviorKeyValue.Key)
}

// optional string Value = 2;
inline bool BehaviorKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BehaviorKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BehaviorKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BehaviorKeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& BehaviorKeyValue::value() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorKeyValue.Value)
  return *value_;
}
inline void BehaviorKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BehaviorKeyValue.Value)
}
inline void BehaviorKeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BehaviorKeyValue.Value)
}
inline void BehaviorKeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BehaviorKeyValue.Value)
}
inline ::std::string* BehaviorKeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BehaviorKeyValue.Value)
  return value_;
}
inline ::std::string* BehaviorKeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BehaviorKeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BehaviorKeyValue.Value)
}

// optional .pb.EBehaviorDataType Type = 3;
inline bool BehaviorKeyValue::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BehaviorKeyValue::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BehaviorKeyValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BehaviorKeyValue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::EBehaviorDataType BehaviorKeyValue::type() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorKeyValue.Type)
  return static_cast< ::pb::EBehaviorDataType >(type_);
}
inline void BehaviorKeyValue::set_type(::pb::EBehaviorDataType value) {
  assert(::pb::EBehaviorDataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorKeyValue.Type)
}

// -------------------------------------------------------------------

// BehaviorTreeData

// optional int32 ID = 1;
inline bool BehaviorTreeData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorTreeData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorTreeData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorTreeData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BehaviorTreeData::id() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.ID)
  return id_;
}
inline void BehaviorTreeData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorTreeData.ID)
}

// repeated .pb.BehaviorKeyValue Data = 2;
inline int BehaviorTreeData::data_size() const {
  return data_.size();
}
inline void BehaviorTreeData::clear_data() {
  data_.Clear();
}
inline const ::pb::BehaviorKeyValue& BehaviorTreeData::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.Data)
  return data_.Get(index);
}
inline ::pb::BehaviorKeyValue* BehaviorTreeData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BehaviorTreeData.Data)
  return data_.Mutable(index);
}
inline ::pb::BehaviorKeyValue* BehaviorTreeData::add_data() {
  // @@protoc_insertion_point(field_add:pb.BehaviorTreeData.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >&
BehaviorTreeData::data() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorTreeData.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >*
BehaviorTreeData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorTreeData.Data)
  return &data_;
}

// repeated .pb.BehaviorTreeData Child = 3;
inline int BehaviorTreeData::child_size() const {
  return child_.size();
}
inline void BehaviorTreeData::clear_child() {
  child_.Clear();
}
inline const ::pb::BehaviorTreeData& BehaviorTreeData::child(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.Child)
  return child_.Get(index);
}
inline ::pb::BehaviorTreeData* BehaviorTreeData::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BehaviorTreeData.Child)
  return child_.Mutable(index);
}
inline ::pb::BehaviorTreeData* BehaviorTreeData::add_child() {
  // @@protoc_insertion_point(field_add:pb.BehaviorTreeData.Child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
BehaviorTreeData::child() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorTreeData.Child)
  return child_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
BehaviorTreeData::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorTreeData.Child)
  return &child_;
}

// optional .pb.BehaviorPosition Position = 4;
inline bool BehaviorTreeData::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BehaviorTreeData::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BehaviorTreeData::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BehaviorTreeData::clear_position() {
  if (position_ != NULL) position_->::pb::BehaviorPosition::Clear();
  clear_has_position();
}
inline const ::pb::BehaviorPosition& BehaviorTreeData::position() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::BehaviorPosition* BehaviorTreeData::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::BehaviorPosition;
  // @@protoc_insertion_point(field_mutable:pb.BehaviorTreeData.Position)
  return position_;
}
inline ::pb::BehaviorPosition* BehaviorTreeData::release_position() {
  clear_has_position();
  ::pb::BehaviorPosition* temp = position_;
  position_ = NULL;
  return temp;
}
inline void BehaviorTreeData::set_allocated_position(::pb::BehaviorPosition* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BehaviorTreeData.Position)
}

// optional int32 NodeID = 5;
inline bool BehaviorTreeData::has_nodeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BehaviorTreeData::set_has_nodeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BehaviorTreeData::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BehaviorTreeData::clear_nodeid() {
  nodeid_ = 0;
  clear_has_nodeid();
}
inline ::google::protobuf::int32 BehaviorTreeData::nodeid() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.NodeID)
  return nodeid_;
}
inline void BehaviorTreeData::set_nodeid(::google::protobuf::int32 value) {
  set_has_nodeid();
  nodeid_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorTreeData.NodeID)
}

// repeated int32 PreNodeIDs = 6;
inline int BehaviorTreeData::prenodeids_size() const {
  return prenodeids_.size();
}
inline void BehaviorTreeData::clear_prenodeids() {
  prenodeids_.Clear();
}
inline ::google::protobuf::int32 BehaviorTreeData::prenodeids(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.PreNodeIDs)
  return prenodeids_.Get(index);
}
inline void BehaviorTreeData::set_prenodeids(int index, ::google::protobuf::int32 value) {
  prenodeids_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.BehaviorTreeData.PreNodeIDs)
}
inline void BehaviorTreeData::add_prenodeids(::google::protobuf::int32 value) {
  prenodeids_.Add(value);
  // @@protoc_insertion_point(field_add:pb.BehaviorTreeData.PreNodeIDs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BehaviorTreeData::prenodeids() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorTreeData.PreNodeIDs)
  return prenodeids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BehaviorTreeData::mutable_prenodeids() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorTreeData.PreNodeIDs)
  return &prenodeids_;
}

// optional .pb.EBehaviorGroupType PreNodeType = 7;
inline bool BehaviorTreeData::has_prenodetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BehaviorTreeData::set_has_prenodetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BehaviorTreeData::clear_has_prenodetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BehaviorTreeData::clear_prenodetype() {
  prenodetype_ = 0;
  clear_has_prenodetype();
}
inline ::pb::EBehaviorGroupType BehaviorTreeData::prenodetype() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.PreNodeType)
  return static_cast< ::pb::EBehaviorGroupType >(prenodetype_);
}
inline void BehaviorTreeData::set_prenodetype(::pb::EBehaviorGroupType value) {
  assert(::pb::EBehaviorGroupType_IsValid(value));
  set_has_prenodetype();
  prenodetype_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorTreeData.PreNodeType)
}

// optional string Remark = 8;
inline bool BehaviorTreeData::has_remark() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BehaviorTreeData::set_has_remark() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BehaviorTreeData::clear_has_remark() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BehaviorTreeData::clear_remark() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& BehaviorTreeData::remark() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorTreeData.Remark)
  return *remark_;
}
inline void BehaviorTreeData::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BehaviorTreeData.Remark)
}
inline void BehaviorTreeData::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BehaviorTreeData.Remark)
}
inline void BehaviorTreeData::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BehaviorTreeData.Remark)
}
inline ::std::string* BehaviorTreeData::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BehaviorTreeData.Remark)
  return remark_;
}
inline ::std::string* BehaviorTreeData::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BehaviorTreeData::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BehaviorTreeData.Remark)
}

// -------------------------------------------------------------------

// BehaviorRootData

// optional .pb.EBehaviorGroupType Type = 1;
inline bool BehaviorRootData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorRootData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorRootData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorRootData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::EBehaviorGroupType BehaviorRootData::type() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorRootData.Type)
  return static_cast< ::pb::EBehaviorGroupType >(type_);
}
inline void BehaviorRootData::set_type(::pb::EBehaviorGroupType value) {
  assert(::pb::EBehaviorGroupType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorRootData.Type)
}

// repeated .pb.BehaviorTreeData Trigger = 2;
inline int BehaviorRootData::trigger_size() const {
  return trigger_.size();
}
inline void BehaviorRootData::clear_trigger() {
  trigger_.Clear();
}
inline const ::pb::BehaviorTreeData& BehaviorRootData::trigger(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorRootData.Trigger)
  return trigger_.Get(index);
}
inline ::pb::BehaviorTreeData* BehaviorRootData::mutable_trigger(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BehaviorRootData.Trigger)
  return trigger_.Mutable(index);
}
inline ::pb::BehaviorTreeData* BehaviorRootData::add_trigger() {
  // @@protoc_insertion_point(field_add:pb.BehaviorRootData.Trigger)
  return trigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
BehaviorRootData::trigger() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorRootData.Trigger)
  return trigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
BehaviorRootData::mutable_trigger() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorRootData.Trigger)
  return &trigger_;
}

// repeated .pb.BehaviorTreeData Child = 3;
inline int BehaviorRootData::child_size() const {
  return child_.size();
}
inline void BehaviorRootData::clear_child() {
  child_.Clear();
}
inline const ::pb::BehaviorTreeData& BehaviorRootData::child(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorRootData.Child)
  return child_.Get(index);
}
inline ::pb::BehaviorTreeData* BehaviorRootData::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BehaviorRootData.Child)
  return child_.Mutable(index);
}
inline ::pb::BehaviorTreeData* BehaviorRootData::add_child() {
  // @@protoc_insertion_point(field_add:pb.BehaviorRootData.Child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
BehaviorRootData::child() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorRootData.Child)
  return child_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
BehaviorRootData::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorRootData.Child)
  return &child_;
}

// optional .pb.BehaviorPosition Position = 4;
inline bool BehaviorRootData::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BehaviorRootData::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BehaviorRootData::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BehaviorRootData::clear_position() {
  if (position_ != NULL) position_->::pb::BehaviorPosition::Clear();
  clear_has_position();
}
inline const ::pb::BehaviorPosition& BehaviorRootData::position() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorRootData.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::BehaviorPosition* BehaviorRootData::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::BehaviorPosition;
  // @@protoc_insertion_point(field_mutable:pb.BehaviorRootData.Position)
  return position_;
}
inline ::pb::BehaviorPosition* BehaviorRootData::release_position() {
  clear_has_position();
  ::pb::BehaviorPosition* temp = position_;
  position_ = NULL;
  return temp;
}
inline void BehaviorRootData::set_allocated_position(::pb::BehaviorPosition* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BehaviorRootData.Position)
}

// optional int32 Count = 5;
inline bool BehaviorRootData::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BehaviorRootData::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BehaviorRootData::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BehaviorRootData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BehaviorRootData::count() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorRootData.Count)
  return count_;
}
inline void BehaviorRootData::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorRootData.Count)
}

// -------------------------------------------------------------------

// BehaviorData

// optional int32 ID = 1;
inline bool BehaviorData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BehaviorData::id() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorData.ID)
  return id_;
}
inline void BehaviorData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorData.ID)
}

// repeated .pb.BehaviorRootData RootData = 2;
inline int BehaviorData::rootdata_size() const {
  return rootdata_.size();
}
inline void BehaviorData::clear_rootdata() {
  rootdata_.Clear();
}
inline const ::pb::BehaviorRootData& BehaviorData::rootdata(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorData.RootData)
  return rootdata_.Get(index);
}
inline ::pb::BehaviorRootData* BehaviorData::mutable_rootdata(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BehaviorData.RootData)
  return rootdata_.Mutable(index);
}
inline ::pb::BehaviorRootData* BehaviorData::add_rootdata() {
  // @@protoc_insertion_point(field_add:pb.BehaviorData.RootData)
  return rootdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorRootData >&
BehaviorData::rootdata() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorData.RootData)
  return rootdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorRootData >*
BehaviorData::mutable_rootdata() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorData.RootData)
  return &rootdata_;
}

// repeated .pb.BehaviorTreeData TreeData = 3;
inline int BehaviorData::treedata_size() const {
  return treedata_.size();
}
inline void BehaviorData::clear_treedata() {
  treedata_.Clear();
}
inline const ::pb::BehaviorTreeData& BehaviorData::treedata(int index) const {
  // @@protoc_insertion_point(field_get:pb.BehaviorData.TreeData)
  return treedata_.Get(index);
}
inline ::pb::BehaviorTreeData* BehaviorData::mutable_treedata(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BehaviorData.TreeData)
  return treedata_.Mutable(index);
}
inline ::pb::BehaviorTreeData* BehaviorData::add_treedata() {
  // @@protoc_insertion_point(field_add:pb.BehaviorData.TreeData)
  return treedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >&
BehaviorData::treedata() const {
  // @@protoc_insertion_point(field_list:pb.BehaviorData.TreeData)
  return treedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorTreeData >*
BehaviorData::mutable_treedata() {
  // @@protoc_insertion_point(field_mutable_list:pb.BehaviorData.TreeData)
  return &treedata_;
}

// optional bool notAllowSkip = 4;
inline bool BehaviorData::has_notallowskip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BehaviorData::set_has_notallowskip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BehaviorData::clear_has_notallowskip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BehaviorData::clear_notallowskip() {
  notallowskip_ = false;
  clear_has_notallowskip();
}
inline bool BehaviorData::notallowskip() const {
  // @@protoc_insertion_point(field_get:pb.BehaviorData.notAllowSkip)
  return notallowskip_;
}
inline void BehaviorData::set_notallowskip(bool value) {
  set_has_notallowskip();
  notallowskip_ = value;
  // @@protoc_insertion_point(field_set:pb.BehaviorData.notAllowSkip)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::EBehaviorGroupType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EBehaviorGroupType>() {
  return ::pb::EBehaviorGroupType_descriptor();
}
template <> struct is_proto_enum< ::pb::EBehaviorDataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EBehaviorDataType>() {
  return ::pb::EBehaviorDataType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fBehaviorData_2eproto__INCLUDED
