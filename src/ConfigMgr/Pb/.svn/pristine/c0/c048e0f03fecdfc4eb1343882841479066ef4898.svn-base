// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/SceneConf2d.proto

#ifndef PROTOBUF_module_2fSceneConf2d_2eproto__INCLUDED
#define PROTOBUF_module_2fSceneConf2d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/SceneElementDefine.pb.h"
#include "module/Util.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

class PointElement2;
class AttachPoint2;
class BindAssetInfo;
class RectArea2;
class CustomArea2;
class GuardInfo;
class PendantInfo;
class AnimAsset2;
class StaticAsset2;
class EffectAsset2;
class AssetGroup;
class PatrolPathPoint;
class PatrolPath2;
class PatrolPathConf;
class CarrierEnt2;
class FeatureEntrance;
class SceneChunkInfo;
class Obstacle;

// ===================================================================

/*FOR2LUA
<Record>
	<name>PointElement2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PointElement2 : public ::google::protobuf::Message {
 public:
  PointElement2();
  virtual ~PointElement2();

  PointElement2(const PointElement2& from);

  inline PointElement2& operator=(const PointElement2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointElement2& default_instance();

  void Swap(PointElement2* other);

  // implements Message ----------------------------------------------

  PointElement2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointElement2& from);
  void MergeFrom(const PointElement2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ESceneElementType ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector2 Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional string SortingLayer = 4;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional uint32 SortingOrder = 5;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::uint32 value);

  // optional .pb.PbVector2 Direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& direction() const;
  inline ::pb::PbVector2* mutable_direction();
  inline ::pb::PbVector2* release_direction();
  inline void set_allocated_direction(::pb::PbVector2* direction);

  // optional .pb.PbVector2 Fake3dOffset = 7;
  inline bool has_fake3doffset() const;
  inline void clear_fake3doffset();
  static const int kFake3DOffsetFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>PointElement2</name>
  	<Function>
  		<name>fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& fake3doffset() const;
  inline ::pb::PbVector2* mutable_fake3doffset();
  inline ::pb::PbVector2* release_fake3doffset();
  inline void set_allocated_fake3doffset(::pb::PbVector2* fake3doffset);

  // @@protoc_insertion_point(class_scope:pb.PointElement2)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_fake3doffset();
  inline void clear_has_fake3doffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  int elementtype_;
  ::google::protobuf::uint32 sortingorder_;
  ::std::string* sortinglayer_;
  ::pb::PbVector2* direction_;
  ::pb::PbVector2* fake3doffset_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static PointElement2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AttachPoint2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AttachPoint2 : public ::google::protobuf::Message {
 public:
  AttachPoint2();
  virtual ~AttachPoint2();

  AttachPoint2(const AttachPoint2& from);

  inline AttachPoint2& operator=(const AttachPoint2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttachPoint2& default_instance();

  void Swap(AttachPoint2* other);

  // implements Message ----------------------------------------------

  AttachPoint2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttachPoint2& from);
  void MergeFrom(const AttachPoint2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AttachPoint2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AttachPoint2</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional .pb.PbVector2 WorldScale = 3;
  inline bool has_worldscale() const;
  inline void clear_worldscale();
  static const int kWorldScaleFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AttachPoint2</name>
  	<Function>
  		<name>worldscale</name>
  		<replaceName>WorldScale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_worldscale</name>
  		<replaceName>WorldScale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_worldscale</name>
  		<replaceName>WorldScale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_worldscale</name>
  		<replaceName>WorldScale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& worldscale() const;
  inline ::pb::PbVector2* mutable_worldscale();
  inline ::pb::PbVector2* release_worldscale();
  inline void set_allocated_worldscale(::pb::PbVector2* worldscale);

  // @@protoc_insertion_point(class_scope:pb.AttachPoint2)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_worldscale();
  inline void clear_has_worldscale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::pb::PbVector2* worldscale_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static AttachPoint2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>BindAssetInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class BindAssetInfo : public ::google::protobuf::Message {
 public:
  BindAssetInfo();
  virtual ~BindAssetInfo();

  BindAssetInfo(const BindAssetInfo& from);

  inline BindAssetInfo& operator=(const BindAssetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindAssetInfo& default_instance();

  void Swap(BindAssetInfo* other);

  // implements Message ----------------------------------------------

  BindAssetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BindAssetInfo& from);
  void MergeFrom(const BindAssetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string AssetEleName = 1;
  inline bool has_assetelename() const;
  inline void clear_assetelename();
  static const int kAssetEleNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>BindAssetInfo</name>
  	<Function>
  		<name>assetelename</name>
  		<replaceName>AssetEleName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetelename</name>
  		<replaceName>AssetEleName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetelename</name>
  		<replaceName>AssetEleName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetelename() const;
  inline void set_assetelename(const ::std::string& value);
  inline void set_assetelename(const char* value);
  inline void set_assetelename(const char* value, size_t size);
  inline ::std::string* mutable_assetelename();
  inline ::std::string* release_assetelename();
  inline void set_allocated_assetelename(::std::string* assetelename);

  // optional string ActiveMoveTargetEleName = 2;
  inline bool has_activemovetargetelename() const;
  inline void clear_activemovetargetelename();
  static const int kActiveMoveTargetEleNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>BindAssetInfo</name>
  	<Function>
  		<name>activemovetargetelename</name>
  		<replaceName>ActiveMoveTargetEleName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_activemovetargetelename</name>
  		<replaceName>ActiveMoveTargetEleName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_activemovetargetelename</name>
  		<replaceName>ActiveMoveTargetEleName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& activemovetargetelename() const;
  inline void set_activemovetargetelename(const ::std::string& value);
  inline void set_activemovetargetelename(const char* value);
  inline void set_activemovetargetelename(const char* value, size_t size);
  inline ::std::string* mutable_activemovetargetelename();
  inline ::std::string* release_activemovetargetelename();
  inline void set_allocated_activemovetargetelename(::std::string* activemovetargetelename);

  // optional float MoveSpeed = 3;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMoveSpeedFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>BindAssetInfo</name>
  	<Function>
  		<name>movespeed</name>
  		<replaceName>MoveSpeed</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_movespeed</name>
  		<replaceName>MoveSpeed</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_movespeed</name>
  		<replaceName>MoveSpeed</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float movespeed() const;
  inline void set_movespeed(float value);

  // optional string MoveAnimName = 4;
  inline bool has_moveanimname() const;
  inline void clear_moveanimname();
  static const int kMoveAnimNameFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>BindAssetInfo</name>
  	<Function>
  		<name>moveanimname</name>
  		<replaceName>MoveAnimName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_moveanimname</name>
  		<replaceName>MoveAnimName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_moveanimname</name>
  		<replaceName>MoveAnimName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& moveanimname() const;
  inline void set_moveanimname(const ::std::string& value);
  inline void set_moveanimname(const char* value);
  inline void set_moveanimname(const char* value, size_t size);
  inline ::std::string* mutable_moveanimname();
  inline ::std::string* release_moveanimname();
  inline void set_allocated_moveanimname(::std::string* moveanimname);

  // optional .pb.PbVector2 MoveEndDirection = 5;
  inline bool has_moveenddirection() const;
  inline void clear_moveenddirection();
  static const int kMoveEndDirectionFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>BindAssetInfo</name>
  	<Function>
  		<name>moveenddirection</name>
  		<replaceName>MoveEndDirection</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_moveenddirection</name>
  		<replaceName>MoveEndDirection</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_moveenddirection</name>
  		<replaceName>MoveEndDirection</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_moveenddirection</name>
  		<replaceName>MoveEndDirection</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& moveenddirection() const;
  inline ::pb::PbVector2* mutable_moveenddirection();
  inline ::pb::PbVector2* release_moveenddirection();
  inline void set_allocated_moveenddirection(::pb::PbVector2* moveenddirection);

  // optional string ArrivedAnim = 6;
  inline bool has_arrivedanim() const;
  inline void clear_arrivedanim();
  static const int kArrivedAnimFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>BindAssetInfo</name>
  	<Function>
  		<name>arrivedanim</name>
  		<replaceName>ArrivedAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_arrivedanim</name>
  		<replaceName>ArrivedAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_arrivedanim</name>
  		<replaceName>ArrivedAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& arrivedanim() const;
  inline void set_arrivedanim(const ::std::string& value);
  inline void set_arrivedanim(const char* value);
  inline void set_arrivedanim(const char* value, size_t size);
  inline ::std::string* mutable_arrivedanim();
  inline ::std::string* release_arrivedanim();
  inline void set_allocated_arrivedanim(::std::string* arrivedanim);

  // @@protoc_insertion_point(class_scope:pb.BindAssetInfo)
 private:
  inline void set_has_assetelename();
  inline void clear_has_assetelename();
  inline void set_has_activemovetargetelename();
  inline void clear_has_activemovetargetelename();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_moveanimname();
  inline void clear_has_moveanimname();
  inline void set_has_moveenddirection();
  inline void clear_has_moveenddirection();
  inline void set_has_arrivedanim();
  inline void clear_has_arrivedanim();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* assetelename_;
  ::std::string* activemovetargetelename_;
  ::std::string* moveanimname_;
  ::pb::PbVector2* moveenddirection_;
  ::std::string* arrivedanim_;
  float movespeed_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static BindAssetInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>RectArea2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class RectArea2 : public ::google::protobuf::Message {
 public:
  RectArea2();
  virtual ~RectArea2();

  RectArea2(const RectArea2& from);

  inline RectArea2& operator=(const RectArea2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectArea2& default_instance();

  void Swap(RectArea2* other);

  // implements Message ----------------------------------------------

  RectArea2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RectArea2& from);
  void MergeFrom(const RectArea2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ESceneElementType ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbRect RectInfo = 3;
  inline bool has_rectinfo() const;
  inline void clear_rectinfo();
  static const int kRectInfoFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectinfo</name>
  		<replaceName>RectInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& rectinfo() const;
  inline ::pb::PbRect* mutable_rectinfo();
  inline ::pb::PbRect* release_rectinfo();
  inline void set_allocated_rectinfo(::pb::PbRect* rectinfo);

  // required .pb.PbVector2 CenterPosition = 4;
  inline bool has_centerposition() const;
  inline void clear_centerposition();
  static const int kCenterPositionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& centerposition() const;
  inline ::pb::PbVector2* mutable_centerposition();
  inline ::pb::PbVector2* release_centerposition();
  inline void set_allocated_centerposition(::pb::PbVector2* centerposition);

  // required bool Visible = 5;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // repeated .pb.AttachPoint2 AttachPointArr = 6;
  inline int attachpointarr_size() const;
  inline void clear_attachpointarr();
  static const int kAttachPointArrFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>attachpointarr_size</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AttachPoint2& attachpointarr(int index) const;
  inline ::pb::AttachPoint2* mutable_attachpointarr(int index);
  inline ::pb::AttachPoint2* add_attachpointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
      attachpointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
      mutable_attachpointarr();

  // optional string SortingLayer = 7;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional int32 SortingOrder = 8;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::int32 value);

  // repeated .pb.BindAssetInfo ActiveBindAssetInfoArr = 9;
  inline int activebindassetinfoarr_size() const;
  inline void clear_activebindassetinfoarr();
  static const int kActiveBindAssetInfoArrFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>activebindassetinfoarr</name>
  		<replaceName>ActiveBindAssetInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_activebindassetinfoarr</name>
  		<replaceName>ActiveBindAssetInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_activebindassetinfoarr</name>
  		<replaceName>ActiveBindAssetInfoArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_activebindassetinfoarr</name>
  		<replaceName>ActiveBindAssetInfoArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>activebindassetinfoarr_size</name>
  		<replaceName>ActiveBindAssetInfoArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BindAssetInfo& activebindassetinfoarr(int index) const;
  inline ::pb::BindAssetInfo* mutable_activebindassetinfoarr(int index);
  inline ::pb::BindAssetInfo* add_activebindassetinfoarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BindAssetInfo >&
      activebindassetinfoarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BindAssetInfo >*
      mutable_activebindassetinfoarr();

  // optional int32 ConfTid = 10;
  inline bool has_conftid() const;
  inline void clear_conftid();
  static const int kConfTidFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>conftid</name>
  		<replaceName>ConfTid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_conftid</name>
  		<replaceName>ConfTid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_conftid</name>
  		<replaceName>ConfTid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 conftid() const;
  inline void set_conftid(::google::protobuf::int32 value);

  // optional string ViewElementName = 11;
  inline bool has_viewelementname() const;
  inline void clear_viewelementname();
  static const int kViewElementNameFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>RectArea2</name>
  	<Function>
  		<name>viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& viewelementname() const;
  inline void set_viewelementname(const ::std::string& value);
  inline void set_viewelementname(const char* value);
  inline void set_viewelementname(const char* value, size_t size);
  inline ::std::string* mutable_viewelementname();
  inline ::std::string* release_viewelementname();
  inline void set_allocated_viewelementname(::std::string* viewelementname);

  // @@protoc_insertion_point(class_scope:pb.RectArea2)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rectinfo();
  inline void clear_has_rectinfo();
  inline void set_has_centerposition();
  inline void clear_has_centerposition();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();
  inline void set_has_conftid();
  inline void clear_has_conftid();
  inline void set_has_viewelementname();
  inline void clear_has_viewelementname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbRect* rectinfo_;
  int elementtype_;
  bool visible_;
  ::pb::PbVector2* centerposition_;
  ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 > attachpointarr_;
  ::std::string* sortinglayer_;
  ::google::protobuf::RepeatedPtrField< ::pb::BindAssetInfo > activebindassetinfoarr_;
  ::google::protobuf::int32 sortingorder_;
  ::google::protobuf::int32 conftid_;
  ::std::string* viewelementname_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static RectArea2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CustomArea2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CustomArea2 : public ::google::protobuf::Message {
 public:
  CustomArea2();
  virtual ~CustomArea2();

  CustomArea2(const CustomArea2& from);

  inline CustomArea2& operator=(const CustomArea2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomArea2& default_instance();

  void Swap(CustomArea2* other);

  // implements Message ----------------------------------------------

  CustomArea2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomArea2& from);
  void MergeFrom(const CustomArea2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ESceneElementType ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CustomArea2</name>
  	<Function>
  		<name>elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_elementtype</name>
  		<replaceName>ElementType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ESceneElementType elementtype() const;
  inline void set_elementtype(::pb::ESceneElementType value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CustomArea2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.PbVector2 ChunkIndexArr = 3;
  inline int chunkindexarr_size() const;
  inline void clear_chunkindexarr();
  static const int kChunkIndexArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>CustomArea2</name>
  	<Function>
  		<name>chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_chunkindexarr</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>chunkindexarr_size</name>
  		<replaceName>ChunkIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& chunkindexarr(int index) const;
  inline ::pb::PbVector2* mutable_chunkindexarr(int index);
  inline ::pb::PbVector2* add_chunkindexarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >&
      chunkindexarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >*
      mutable_chunkindexarr();

  // required bool Visible = 4;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>CustomArea2</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional string ViewElementName = 5;
  inline bool has_viewelementname() const;
  inline void clear_viewelementname();
  static const int kViewElementNameFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>CustomArea2</name>
  	<Function>
  		<name>viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_viewelementname</name>
  		<replaceName>ViewElementName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& viewelementname() const;
  inline void set_viewelementname(const ::std::string& value);
  inline void set_viewelementname(const char* value);
  inline void set_viewelementname(const char* value, size_t size);
  inline ::std::string* mutable_viewelementname();
  inline ::std::string* release_viewelementname();
  inline void set_allocated_viewelementname(::std::string* viewelementname);

  // optional .pb.PbVector2 CenterPosition = 6;
  inline bool has_centerposition() const;
  inline void clear_centerposition();
  static const int kCenterPositionFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>CustomArea2</name>
  	<Function>
  		<name>centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_centerposition</name>
  		<replaceName>CenterPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& centerposition() const;
  inline ::pb::PbVector2* mutable_centerposition();
  inline ::pb::PbVector2* release_centerposition();
  inline void set_allocated_centerposition(::pb::PbVector2* centerposition);

  // @@protoc_insertion_point(class_scope:pb.CustomArea2)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_viewelementname();
  inline void clear_has_viewelementname();
  inline void set_has_centerposition();
  inline void clear_has_centerposition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int elementtype_;
  bool visible_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 > chunkindexarr_;
  ::std::string* viewelementname_;
  ::pb::PbVector2* centerposition_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static CustomArea2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>GuardInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class GuardInfo : public ::google::protobuf::Message {
 public:
  GuardInfo();
  virtual ~GuardInfo();

  GuardInfo(const GuardInfo& from);

  inline GuardInfo& operator=(const GuardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuardInfo& default_instance();

  void Swap(GuardInfo* other);

  // implements Message ----------------------------------------------

  GuardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuardInfo& from);
  void MergeFrom(const GuardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Radius = 1;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>GuardInfo</name>
  	<Function>
  		<name>radius</name>
  		<replaceName>Radius</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_radius</name>
  		<replaceName>Radius</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_radius</name>
  		<replaceName>Radius</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float radius() const;
  inline void set_radius(float value);

  // optional uint32 Degree = 2;
  inline bool has_degree() const;
  inline void clear_degree();
  static const int kDegreeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>GuardInfo</name>
  	<Function>
  		<name>degree</name>
  		<replaceName>Degree</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_degree</name>
  		<replaceName>Degree</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_degree</name>
  		<replaceName>Degree</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 degree() const;
  inline void set_degree(::google::protobuf::uint32 value);

  // optional .pb.EGuardEventType EventType = 3;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>GuardInfo</name>
  	<Function>
  		<name>eventtype</name>
  		<replaceName>EventType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_eventtype</name>
  		<replaceName>EventType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventtype</name>
  		<replaceName>EventType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EGuardEventType eventtype() const;
  inline void set_eventtype(::pb::EGuardEventType value);

  // optional uint32 EventId = 4;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>GuardInfo</name>
  	<Function>
  		<name>eventid</name>
  		<replaceName>EventId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_eventid</name>
  		<replaceName>EventId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventid</name>
  		<replaceName>EventId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 eventid() const;
  inline void set_eventid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.GuardInfo)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_degree();
  inline void clear_has_degree();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_eventid();
  inline void clear_has_eventid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float radius_;
  ::google::protobuf::uint32 degree_;
  int eventtype_;
  ::google::protobuf::uint32 eventid_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static GuardInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>PendantInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PendantInfo : public ::google::protobuf::Message {
 public:
  PendantInfo();
  virtual ~PendantInfo();

  PendantInfo(const PendantInfo& from);

  inline PendantInfo& operator=(const PendantInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PendantInfo& default_instance();

  void Swap(PendantInfo* other);

  // implements Message ----------------------------------------------

  PendantInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PendantInfo& from);
  void MergeFrom(const PendantInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PendantInfo</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string AssetPath = 2;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PendantInfo</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // optional uint32 AssetType = 3;
  inline bool has_assettype() const;
  inline void clear_assettype();
  static const int kAssetTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>PendantInfo</name>
  	<Function>
  		<name>assettype</name>
  		<replaceName>AssetType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assettype</name>
  		<replaceName>AssetType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assettype</name>
  		<replaceName>AssetType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 assettype() const;
  inline void set_assettype(::google::protobuf::uint32 value);

  // optional string AttachPointName = 4;
  inline bool has_attachpointname() const;
  inline void clear_attachpointname();
  static const int kAttachPointNameFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>PendantInfo</name>
  	<Function>
  		<name>attachpointname</name>
  		<replaceName>AttachPointName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_attachpointname</name>
  		<replaceName>AttachPointName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attachpointname</name>
  		<replaceName>AttachPointName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& attachpointname() const;
  inline void set_attachpointname(const ::std::string& value);
  inline void set_attachpointname(const char* value);
  inline void set_attachpointname(const char* value, size_t size);
  inline ::std::string* mutable_attachpointname();
  inline ::std::string* release_attachpointname();
  inline void set_allocated_attachpointname(::std::string* attachpointname);

  // optional float Scale = 5;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>PendantInfo</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float scale() const;
  inline void set_scale(float value);

  // @@protoc_insertion_point(class_scope:pb.PendantInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_assettype();
  inline void clear_has_assettype();
  inline void set_has_attachpointname();
  inline void clear_has_attachpointname();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* assetpath_;
  ::std::string* attachpointname_;
  ::google::protobuf::uint32 assettype_;
  float scale_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static PendantInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AnimAsset2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AnimAsset2 : public ::google::protobuf::Message {
 public:
  AnimAsset2();
  virtual ~AnimAsset2();

  AnimAsset2(const AnimAsset2& from);

  inline AnimAsset2& operator=(const AnimAsset2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimAsset2& default_instance();

  void Swap(AnimAsset2* other);

  // implements Message ----------------------------------------------

  AnimAsset2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimAsset2& from);
  void MergeFrom(const AnimAsset2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // required .pb.PbVector2 Scale = 3;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& scale() const;
  inline ::pb::PbVector2* mutable_scale();
  inline ::pb::PbVector2* release_scale();
  inline void set_allocated_scale(::pb::PbVector2* scale);

  // required string AssetPath = 4;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // optional string DefaultAnim = 5;
  inline bool has_defaultanim() const;
  inline void clear_defaultanim();
  static const int kDefaultAnimFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& defaultanim() const;
  inline void set_defaultanim(const ::std::string& value);
  inline void set_defaultanim(const char* value);
  inline void set_defaultanim(const char* value, size_t size);
  inline ::std::string* mutable_defaultanim();
  inline ::std::string* release_defaultanim();
  inline void set_allocated_defaultanim(::std::string* defaultanim);

  // required bool Visible = 6;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .pb.PbVector2 Direction = 7;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& direction() const;
  inline ::pb::PbVector2* mutable_direction();
  inline ::pb::PbVector2* release_direction();
  inline void set_allocated_direction(::pb::PbVector2* direction);

  // optional string SortingLayer = 8;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional uint32 SortingOrder = 9;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::uint32 value);

  // optional bool WithGuard = 10;
  inline bool has_withguard() const;
  inline void clear_withguard();
  static const int kWithGuardFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>withguard</name>
  		<replaceName>WithGuard</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_withguard</name>
  		<replaceName>WithGuard</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_withguard</name>
  		<replaceName>WithGuard</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool withguard() const;
  inline void set_withguard(bool value);

  // optional .pb.GuardInfo GuardInfo = 11;
  inline bool has_guardinfo() const;
  inline void clear_guardinfo();
  static const int kGuardInfoFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::GuardInfo& guardinfo() const;
  inline ::pb::GuardInfo* mutable_guardinfo();
  inline ::pb::GuardInfo* release_guardinfo();
  inline void set_allocated_guardinfo(::pb::GuardInfo* guardinfo);

  // repeated .pb.AttachPoint2 AttachPointArr = 12;
  inline int attachpointarr_size() const;
  inline void clear_attachpointarr();
  static const int kAttachPointArrFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>attachpointarr_size</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AttachPoint2& attachpointarr(int index) const;
  inline ::pb::AttachPoint2* mutable_attachpointarr(int index);
  inline ::pb::AttachPoint2* add_attachpointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
      attachpointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
      mutable_attachpointarr();

  // repeated .pb.PendantInfo PendantInfoArr = 13;
  inline int pendantinfoarr_size() const;
  inline void clear_pendantinfoarr();
  static const int kPendantInfoArrFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>pendantinfoarr</name>
  		<replaceName>PendantInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pendantinfoarr</name>
  		<replaceName>PendantInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pendantinfoarr</name>
  		<replaceName>PendantInfoArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pendantinfoarr</name>
  		<replaceName>PendantInfoArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pendantinfoarr_size</name>
  		<replaceName>PendantInfoArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PendantInfo& pendantinfoarr(int index) const;
  inline ::pb::PendantInfo* mutable_pendantinfoarr(int index);
  inline ::pb::PendantInfo* add_pendantinfoarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PendantInfo >&
      pendantinfoarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PendantInfo >*
      mutable_pendantinfoarr();

  // optional uint32 SpecialStyle = 14;
  inline bool has_specialstyle() const;
  inline void clear_specialstyle();
  static const int kSpecialStyleFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>specialstyle</name>
  		<replaceName>SpecialStyle</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_specialstyle</name>
  		<replaceName>SpecialStyle</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_specialstyle</name>
  		<replaceName>SpecialStyle</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 specialstyle() const;
  inline void set_specialstyle(::google::protobuf::uint32 value);

  // optional .pb.PbVector2 Fake3dOffset = 15;
  inline bool has_fake3doffset() const;
  inline void clear_fake3doffset();
  static const int kFake3DOffsetFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>AnimAsset2</name>
  	<Function>
  		<name>fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& fake3doffset() const;
  inline ::pb::PbVector2* mutable_fake3doffset();
  inline ::pb::PbVector2* release_fake3doffset();
  inline void set_allocated_fake3doffset(::pb::PbVector2* fake3doffset);

  // @@protoc_insertion_point(class_scope:pb.AnimAsset2)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_defaultanim();
  inline void clear_has_defaultanim();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();
  inline void set_has_withguard();
  inline void clear_has_withguard();
  inline void set_has_guardinfo();
  inline void clear_has_guardinfo();
  inline void set_has_specialstyle();
  inline void clear_has_specialstyle();
  inline void set_has_fake3doffset();
  inline void clear_has_fake3doffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::pb::PbVector2* scale_;
  ::std::string* assetpath_;
  ::std::string* defaultanim_;
  ::pb::PbVector2* direction_;
  ::std::string* sortinglayer_;
  bool visible_;
  bool withguard_;
  ::google::protobuf::uint32 sortingorder_;
  ::pb::GuardInfo* guardinfo_;
  ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 > attachpointarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::PendantInfo > pendantinfoarr_;
  ::pb::PbVector2* fake3doffset_;
  ::google::protobuf::uint32 specialstyle_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static AnimAsset2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>StaticAsset2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class StaticAsset2 : public ::google::protobuf::Message {
 public:
  StaticAsset2();
  virtual ~StaticAsset2();

  StaticAsset2(const StaticAsset2& from);

  inline StaticAsset2& operator=(const StaticAsset2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticAsset2& default_instance();

  void Swap(StaticAsset2* other);

  // implements Message ----------------------------------------------

  StaticAsset2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StaticAsset2& from);
  void MergeFrom(const StaticAsset2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // required .pb.PbVector2 Scale = 3;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& scale() const;
  inline ::pb::PbVector2* mutable_scale();
  inline ::pb::PbVector2* release_scale();
  inline void set_allocated_scale(::pb::PbVector2* scale);

  // required string AssetPath = 4;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // required bool Visible = 5;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional string SortingLayer = 6;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional uint32 SortingOrder = 7;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::uint32 value);

  // optional bool WithGuard = 8;
  inline bool has_withguard() const;
  inline void clear_withguard();
  static const int kWithGuardFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>withguard</name>
  		<replaceName>WithGuard</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_withguard</name>
  		<replaceName>WithGuard</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_withguard</name>
  		<replaceName>WithGuard</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool withguard() const;
  inline void set_withguard(bool value);

  // optional .pb.GuardInfo GuardInfo = 9;
  inline bool has_guardinfo() const;
  inline void clear_guardinfo();
  static const int kGuardInfoFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_guardinfo</name>
  		<replaceName>GuardInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::GuardInfo& guardinfo() const;
  inline ::pb::GuardInfo* mutable_guardinfo();
  inline ::pb::GuardInfo* release_guardinfo();
  inline void set_allocated_guardinfo(::pb::GuardInfo* guardinfo);

  // optional .pb.PbVector2 Fake3dOffset = 10;
  inline bool has_fake3doffset() const;
  inline void clear_fake3doffset();
  static const int kFake3DOffsetFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>StaticAsset2</name>
  	<Function>
  		<name>fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& fake3doffset() const;
  inline ::pb::PbVector2* mutable_fake3doffset();
  inline ::pb::PbVector2* release_fake3doffset();
  inline void set_allocated_fake3doffset(::pb::PbVector2* fake3doffset);

  // @@protoc_insertion_point(class_scope:pb.StaticAsset2)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();
  inline void set_has_withguard();
  inline void clear_has_withguard();
  inline void set_has_guardinfo();
  inline void clear_has_guardinfo();
  inline void set_has_fake3doffset();
  inline void clear_has_fake3doffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::pb::PbVector2* scale_;
  ::std::string* assetpath_;
  ::std::string* sortinglayer_;
  bool visible_;
  bool withguard_;
  ::google::protobuf::uint32 sortingorder_;
  ::pb::GuardInfo* guardinfo_;
  ::pb::PbVector2* fake3doffset_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static StaticAsset2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>EffectAsset2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class EffectAsset2 : public ::google::protobuf::Message {
 public:
  EffectAsset2();
  virtual ~EffectAsset2();

  EffectAsset2(const EffectAsset2& from);

  inline EffectAsset2& operator=(const EffectAsset2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EffectAsset2& default_instance();

  void Swap(EffectAsset2* other);

  // implements Message ----------------------------------------------

  EffectAsset2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EffectAsset2& from);
  void MergeFrom(const EffectAsset2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pb.PbVector2 Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // required string AssetPath = 3;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // required bool Visible = 4;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional string SortingLayer = 5;
  inline bool has_sortinglayer() const;
  inline void clear_sortinglayer();
  static const int kSortingLayerFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortinglayer</name>
  		<replaceName>SortingLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortinglayer() const;
  inline void set_sortinglayer(const ::std::string& value);
  inline void set_sortinglayer(const char* value);
  inline void set_sortinglayer(const char* value, size_t size);
  inline ::std::string* mutable_sortinglayer();
  inline ::std::string* release_sortinglayer();
  inline void set_allocated_sortinglayer(::std::string* sortinglayer);

  // optional uint32 SortingOrder = 6;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::uint32 value);

  // optional float Scale = 7;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float scale() const;
  inline void set_scale(float value);

  // optional .pb.PbVector2 Fake3dOffset = 8;
  inline bool has_fake3doffset() const;
  inline void clear_fake3doffset();
  static const int kFake3DOffsetFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>EffectAsset2</name>
  	<Function>
  		<name>fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& fake3doffset() const;
  inline ::pb::PbVector2* mutable_fake3doffset();
  inline ::pb::PbVector2* release_fake3doffset();
  inline void set_allocated_fake3doffset(::pb::PbVector2* fake3doffset);

  // @@protoc_insertion_point(class_scope:pb.EffectAsset2)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_sortinglayer();
  inline void clear_has_sortinglayer();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_fake3doffset();
  inline void clear_has_fake3doffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* position_;
  ::std::string* assetpath_;
  ::std::string* sortinglayer_;
  bool visible_;
  ::google::protobuf::uint32 sortingorder_;
  ::pb::PbVector2* fake3doffset_;
  float scale_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static EffectAsset2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AssetGroup</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AssetGroup : public ::google::protobuf::Message {
 public:
  AssetGroup();
  virtual ~AssetGroup();

  AssetGroup(const AssetGroup& from);

  inline AssetGroup& operator=(const AssetGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetGroup& default_instance();

  void Swap(AssetGroup* other);

  // implements Message ----------------------------------------------

  AssetGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetGroup& from);
  void MergeFrom(const AssetGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AssetGroup</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.EffectAsset2 EffectAssetArr = 2;
  inline int effectassetarr_size() const;
  inline void clear_effectassetarr();
  static const int kEffectAssetArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AssetGroup</name>
  	<Function>
  		<name>effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectassetarr_size</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectAsset2& effectassetarr(int index) const;
  inline ::pb::EffectAsset2* mutable_effectassetarr(int index);
  inline ::pb::EffectAsset2* add_effectassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
      effectassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
      mutable_effectassetarr();

  // repeated .pb.AnimAsset2 AnimAssetArr = 3;
  inline int animassetarr_size() const;
  inline void clear_animassetarr();
  static const int kAnimAssetArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AssetGroup</name>
  	<Function>
  		<name>animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>animassetarr_size</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AnimAsset2& animassetarr(int index) const;
  inline ::pb::AnimAsset2* mutable_animassetarr(int index);
  inline ::pb::AnimAsset2* add_animassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
      animassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
      mutable_animassetarr();

  // repeated .pb.StaticAsset2 StaticAssetArr = 4;
  inline int staticassetarr_size() const;
  inline void clear_staticassetarr();
  static const int kStaticAssetArrFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AssetGroup</name>
  	<Function>
  		<name>staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>staticassetarr_size</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StaticAsset2& staticassetarr(int index) const;
  inline ::pb::StaticAsset2* mutable_staticassetarr(int index);
  inline ::pb::StaticAsset2* add_staticassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
      staticassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
      mutable_staticassetarr();

  // @@protoc_insertion_point(class_scope:pb.AssetGroup)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 > effectassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 > animassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 > staticassetarr_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static AssetGroup* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>PatrolPathPoint</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PatrolPathPoint : public ::google::protobuf::Message {
 public:
  PatrolPathPoint();
  virtual ~PatrolPathPoint();

  PatrolPathPoint(const PatrolPathPoint& from);

  inline PatrolPathPoint& operator=(const PatrolPathPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatrolPathPoint& default_instance();

  void Swap(PatrolPathPoint* other);

  // implements Message ----------------------------------------------

  PatrolPathPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatrolPathPoint& from);
  void MergeFrom(const PatrolPathPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.PbVector2 Position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathPoint</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional float StayTime = 2;
  inline bool has_staytime() const;
  inline void clear_staytime();
  static const int kStayTimeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathPoint</name>
  	<Function>
  		<name>staytime</name>
  		<replaceName>StayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_staytime</name>
  		<replaceName>StayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_staytime</name>
  		<replaceName>StayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float staytime() const;
  inline void set_staytime(float value);

  // @@protoc_insertion_point(class_scope:pb.PatrolPathPoint)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_staytime();
  inline void clear_has_staytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector2* position_;
  float staytime_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static PatrolPathPoint* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>PatrolPath2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PatrolPath2 : public ::google::protobuf::Message {
 public:
  PatrolPath2();
  virtual ~PatrolPath2();

  PatrolPath2(const PatrolPath2& from);

  inline PatrolPath2& operator=(const PatrolPath2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatrolPath2& default_instance();

  void Swap(PatrolPath2* other);

  // implements Message ----------------------------------------------

  PatrolPath2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatrolPath2& from);
  void MergeFrom(const PatrolPath2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PatrolPath2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.PatrolPathPoint PointArr = 2;
  inline int pointarr_size() const;
  inline void clear_pointarr();
  static const int kPointArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PatrolPath2</name>
  	<Function>
  		<name>pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointarr</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointarr_size</name>
  		<replaceName>PointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PatrolPathPoint& pointarr(int index) const;
  inline ::pb::PatrolPathPoint* mutable_pointarr(int index);
  inline ::pb::PatrolPathPoint* add_pointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathPoint >&
      pointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathPoint >*
      mutable_pointarr();

  // @@protoc_insertion_point(class_scope:pb.PatrolPath2)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathPoint > pointarr_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static PatrolPath2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>PatrolPathConf</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class PatrolPathConf : public ::google::protobuf::Message {
 public:
  PatrolPathConf();
  virtual ~PatrolPathConf();

  PatrolPathConf(const PatrolPathConf& from);

  inline PatrolPathConf& operator=(const PatrolPathConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatrolPathConf& default_instance();

  void Swap(PatrolPathConf* other);

  // implements Message ----------------------------------------------

  PatrolPathConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatrolPathConf& from);
  void MergeFrom(const PatrolPathConf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string PatrolPathName = 2;
  inline bool has_patrolpathname() const;
  inline void clear_patrolpathname();
  static const int kPatrolPathNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>patrolpathname</name>
  		<replaceName>PatrolPathName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_patrolpathname</name>
  		<replaceName>PatrolPathName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patrolpathname</name>
  		<replaceName>PatrolPathName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& patrolpathname() const;
  inline void set_patrolpathname(const ::std::string& value);
  inline void set_patrolpathname(const char* value);
  inline void set_patrolpathname(const char* value, size_t size);
  inline ::std::string* mutable_patrolpathname();
  inline ::std::string* release_patrolpathname();
  inline void set_allocated_patrolpathname(::std::string* patrolpathname);

  // required string AnimAssetName = 3;
  inline bool has_animassetname() const;
  inline void clear_animassetname();
  static const int kAnimAssetNameFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>animassetname</name>
  		<replaceName>AnimAssetName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_animassetname</name>
  		<replaceName>AnimAssetName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animassetname</name>
  		<replaceName>AnimAssetName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& animassetname() const;
  inline void set_animassetname(const ::std::string& value);
  inline void set_animassetname(const char* value);
  inline void set_animassetname(const char* value, size_t size);
  inline ::std::string* mutable_animassetname();
  inline ::std::string* release_animassetname();
  inline void set_allocated_animassetname(::std::string* animassetname);

  // required uint32 PatrolType = 4;
  inline bool has_patroltype() const;
  inline void clear_patroltype();
  static const int kPatrolTypeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>patroltype</name>
  		<replaceName>PatrolType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_patroltype</name>
  		<replaceName>PatrolType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patroltype</name>
  		<replaceName>PatrolType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 patroltype() const;
  inline void set_patroltype(::google::protobuf::uint32 value);

  // required float PatrolSpeed = 5;
  inline bool has_patrolspeed() const;
  inline void clear_patrolspeed();
  static const int kPatrolSpeedFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>patrolspeed</name>
  		<replaceName>PatrolSpeed</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_patrolspeed</name>
  		<replaceName>PatrolSpeed</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patrolspeed</name>
  		<replaceName>PatrolSpeed</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float patrolspeed() const;
  inline void set_patrolspeed(float value);

  // required string PatrolingAnim = 6;
  inline bool has_patrolinganim() const;
  inline void clear_patrolinganim();
  static const int kPatrolingAnimFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>patrolinganim</name>
  		<replaceName>PatrolingAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_patrolinganim</name>
  		<replaceName>PatrolingAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_patrolinganim</name>
  		<replaceName>PatrolingAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& patrolinganim() const;
  inline void set_patrolinganim(const ::std::string& value);
  inline void set_patrolinganim(const char* value);
  inline void set_patrolinganim(const char* value, size_t size);
  inline ::std::string* mutable_patrolinganim();
  inline ::std::string* release_patrolinganim();
  inline void set_allocated_patrolinganim(::std::string* patrolinganim);

  // required string DefaultAnim = 7;
  inline bool has_defaultanim() const;
  inline void clear_defaultanim();
  static const int kDefaultAnimFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>PatrolPathConf</name>
  	<Function>
  		<name>defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_defaultanim</name>
  		<replaceName>DefaultAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& defaultanim() const;
  inline void set_defaultanim(const ::std::string& value);
  inline void set_defaultanim(const char* value);
  inline void set_defaultanim(const char* value, size_t size);
  inline ::std::string* mutable_defaultanim();
  inline ::std::string* release_defaultanim();
  inline void set_allocated_defaultanim(::std::string* defaultanim);

  // @@protoc_insertion_point(class_scope:pb.PatrolPathConf)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_patrolpathname();
  inline void clear_has_patrolpathname();
  inline void set_has_animassetname();
  inline void clear_has_animassetname();
  inline void set_has_patroltype();
  inline void clear_has_patroltype();
  inline void set_has_patrolspeed();
  inline void clear_has_patrolspeed();
  inline void set_has_patrolinganim();
  inline void clear_has_patrolinganim();
  inline void set_has_defaultanim();
  inline void clear_has_defaultanim();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* patrolpathname_;
  ::std::string* animassetname_;
  ::google::protobuf::uint32 patroltype_;
  float patrolspeed_;
  ::std::string* patrolinganim_;
  ::std::string* defaultanim_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static PatrolPathConf* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CarrierEnt2</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CarrierEnt2 : public ::google::protobuf::Message {
 public:
  CarrierEnt2();
  virtual ~CarrierEnt2();

  CarrierEnt2(const CarrierEnt2& from);

  inline CarrierEnt2& operator=(const CarrierEnt2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CarrierEnt2& default_instance();

  void Swap(CarrierEnt2* other);

  // implements Message ----------------------------------------------

  CarrierEnt2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CarrierEnt2& from);
  void MergeFrom(const CarrierEnt2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool Visible = 2;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .pb.PbVector2 EnterPosition = 3;
  inline bool has_enterposition() const;
  inline void clear_enterposition();
  static const int kEnterPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>enterposition</name>
  		<replaceName>EnterPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_enterposition</name>
  		<replaceName>EnterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_enterposition</name>
  		<replaceName>EnterPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_enterposition</name>
  		<replaceName>EnterPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& enterposition() const;
  inline ::pb::PbVector2* mutable_enterposition();
  inline ::pb::PbVector2* release_enterposition();
  inline void set_allocated_enterposition(::pb::PbVector2* enterposition);

  // optional .pb.PbVector2 ExistPosition = 4;
  inline bool has_existposition() const;
  inline void clear_existposition();
  static const int kExistPositionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>existposition</name>
  		<replaceName>ExistPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_existposition</name>
  		<replaceName>ExistPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_existposition</name>
  		<replaceName>ExistPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_existposition</name>
  		<replaceName>ExistPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& existposition() const;
  inline ::pb::PbVector2* mutable_existposition();
  inline ::pb::PbVector2* release_existposition();
  inline void set_allocated_existposition(::pb::PbVector2* existposition);

  // optional .pb.PbVector2 SceneUIPosition = 5;
  inline bool has_sceneuiposition() const;
  inline void clear_sceneuiposition();
  static const int kSceneUIPositionFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>sceneuiposition</name>
  		<replaceName>SceneUIPosition</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sceneuiposition</name>
  		<replaceName>SceneUIPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_sceneuiposition</name>
  		<replaceName>SceneUIPosition</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sceneuiposition</name>
  		<replaceName>SceneUIPosition</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& sceneuiposition() const;
  inline ::pb::PbVector2* mutable_sceneuiposition();
  inline ::pb::PbVector2* release_sceneuiposition();
  inline void set_allocated_sceneuiposition(::pb::PbVector2* sceneuiposition);

  // optional string AssetPath = 6;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // optional float FadeInTime = 7;
  inline bool has_fadeintime() const;
  inline void clear_fadeintime();
  static const int kFadeInTimeFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>fadeintime</name>
  		<replaceName>FadeInTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fadeintime</name>
  		<replaceName>FadeInTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fadeintime</name>
  		<replaceName>FadeInTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fadeintime() const;
  inline void set_fadeintime(float value);

  // optional string SceneUIAssetPath = 8;
  inline bool has_sceneuiassetpath() const;
  inline void clear_sceneuiassetpath();
  static const int kSceneUIAssetPathFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>sceneuiassetpath</name>
  		<replaceName>SceneUIAssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sceneuiassetpath</name>
  		<replaceName>SceneUIAssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sceneuiassetpath</name>
  		<replaceName>SceneUIAssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sceneuiassetpath() const;
  inline void set_sceneuiassetpath(const ::std::string& value);
  inline void set_sceneuiassetpath(const char* value);
  inline void set_sceneuiassetpath(const char* value, size_t size);
  inline ::std::string* mutable_sceneuiassetpath();
  inline ::std::string* release_sceneuiassetpath();
  inline void set_allocated_sceneuiassetpath(::std::string* sceneuiassetpath);

  // optional string WalkAreaName = 9;
  inline bool has_walkareaname() const;
  inline void clear_walkareaname();
  static const int kWalkAreaNameFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>walkareaname</name>
  		<replaceName>WalkAreaName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_walkareaname</name>
  		<replaceName>WalkAreaName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_walkareaname</name>
  		<replaceName>WalkAreaName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& walkareaname() const;
  inline void set_walkareaname(const ::std::string& value);
  inline void set_walkareaname(const char* value);
  inline void set_walkareaname(const char* value, size_t size);
  inline ::std::string* mutable_walkareaname();
  inline ::std::string* release_walkareaname();
  inline void set_allocated_walkareaname(::std::string* walkareaname);

  // optional float CarrierSpeed = 10;
  inline bool has_carrierspeed() const;
  inline void clear_carrierspeed();
  static const int kCarrierSpeedFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>CarrierEnt2</name>
  	<Function>
  		<name>carrierspeed</name>
  		<replaceName>CarrierSpeed</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_carrierspeed</name>
  		<replaceName>CarrierSpeed</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_carrierspeed</name>
  		<replaceName>CarrierSpeed</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float carrierspeed() const;
  inline void set_carrierspeed(float value);

  // @@protoc_insertion_point(class_scope:pb.CarrierEnt2)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_enterposition();
  inline void clear_has_enterposition();
  inline void set_has_existposition();
  inline void clear_has_existposition();
  inline void set_has_sceneuiposition();
  inline void clear_has_sceneuiposition();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_fadeintime();
  inline void clear_has_fadeintime();
  inline void set_has_sceneuiassetpath();
  inline void clear_has_sceneuiassetpath();
  inline void set_has_walkareaname();
  inline void clear_has_walkareaname();
  inline void set_has_carrierspeed();
  inline void clear_has_carrierspeed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector2* enterposition_;
  ::pb::PbVector2* existposition_;
  bool visible_;
  float fadeintime_;
  ::pb::PbVector2* sceneuiposition_;
  ::std::string* assetpath_;
  ::std::string* sceneuiassetpath_;
  ::std::string* walkareaname_;
  float carrierspeed_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static CarrierEnt2* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>FeatureEntrance</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class FeatureEntrance : public ::google::protobuf::Message {
 public:
  FeatureEntrance();
  virtual ~FeatureEntrance();

  FeatureEntrance(const FeatureEntrance& from);

  inline FeatureEntrance& operator=(const FeatureEntrance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureEntrance& default_instance();

  void Swap(FeatureEntrance* other);

  // implements Message ----------------------------------------------

  FeatureEntrance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureEntrance& from);
  void MergeFrom(const FeatureEntrance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Interactable = 1;
  inline bool has_interactable() const;
  inline void clear_interactable();
  static const int kInteractableFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>interactable</name>
  		<replaceName>Interactable</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_interactable</name>
  		<replaceName>Interactable</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_interactable</name>
  		<replaceName>Interactable</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool interactable() const;
  inline void set_interactable(bool value);

  // optional int32 FeatureEntranceId = 2;
  inline bool has_featureentranceid() const;
  inline void clear_featureentranceid();
  static const int kFeatureEntranceIdFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>featureentranceid</name>
  		<replaceName>FeatureEntranceId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_featureentranceid</name>
  		<replaceName>FeatureEntranceId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_featureentranceid</name>
  		<replaceName>FeatureEntranceId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 featureentranceid() const;
  inline void set_featureentranceid(::google::protobuf::int32 value);

  // optional .pb.PbVector2 Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& position() const;
  inline ::pb::PbVector2* mutable_position();
  inline ::pb::PbVector2* release_position();
  inline void set_allocated_position(::pb::PbVector2* position);

  // optional int32 EventFuncId = 4;
  inline bool has_eventfuncid() const;
  inline void clear_eventfuncid();
  static const int kEventFuncIdFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>eventfuncid</name>
  		<replaceName>EventFuncId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_eventfuncid</name>
  		<replaceName>EventFuncId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventfuncid</name>
  		<replaceName>EventFuncId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 eventfuncid() const;
  inline void set_eventfuncid(::google::protobuf::int32 value);

  // optional string Params = 5;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>params</name>
  		<replaceName>Params</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_params</name>
  		<replaceName>Params</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_params</name>
  		<replaceName>Params</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& params() const;
  inline void set_params(const ::std::string& value);
  inline void set_params(const char* value);
  inline void set_params(const char* value, size_t size);
  inline ::std::string* mutable_params();
  inline ::std::string* release_params();
  inline void set_allocated_params(::std::string* params);

  // optional .pb.PbVector2 Scale = 6;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& scale() const;
  inline ::pb::PbVector2* mutable_scale();
  inline ::pb::PbVector2* release_scale();
  inline void set_allocated_scale(::pb::PbVector2* scale);

  // optional string SortedLayer = 7;
  inline bool has_sortedlayer() const;
  inline void clear_sortedlayer();
  static const int kSortedLayerFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>sortedlayer</name>
  		<replaceName>SortedLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortedlayer</name>
  		<replaceName>SortedLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortedlayer</name>
  		<replaceName>SortedLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sortedlayer() const;
  inline void set_sortedlayer(const ::std::string& value);
  inline void set_sortedlayer(const char* value);
  inline void set_sortedlayer(const char* value, size_t size);
  inline ::std::string* mutable_sortedlayer();
  inline ::std::string* release_sortedlayer();
  inline void set_allocated_sortedlayer(::std::string* sortedlayer);

  // optional uint32 OrderInLayer = 8;
  inline bool has_orderinlayer() const;
  inline void clear_orderinlayer();
  static const int kOrderInLayerFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>orderinlayer</name>
  		<replaceName>OrderInLayer</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_orderinlayer</name>
  		<replaceName>OrderInLayer</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_orderinlayer</name>
  		<replaceName>OrderInLayer</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 orderinlayer() const;
  inline void set_orderinlayer(::google::protobuf::uint32 value);

  // repeated .pb.AttachPoint2 AttachPointArr = 9;
  inline int attachpointarr_size() const;
  inline void clear_attachpointarr();
  static const int kAttachPointArrFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_attachpointarr</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>attachpointarr_size</name>
  		<replaceName>AttachPointArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AttachPoint2& attachpointarr(int index) const;
  inline ::pb::AttachPoint2* mutable_attachpointarr(int index);
  inline ::pb::AttachPoint2* add_attachpointarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
      attachpointarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
      mutable_attachpointarr();

  // optional string AssetPath = 10;
  inline bool has_assetpath() const;
  inline void clear_assetpath();
  static const int kAssetPathFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_assetpath</name>
  		<replaceName>AssetPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& assetpath() const;
  inline void set_assetpath(const ::std::string& value);
  inline void set_assetpath(const char* value);
  inline void set_assetpath(const char* value, size_t size);
  inline ::std::string* mutable_assetpath();
  inline ::std::string* release_assetpath();
  inline void set_allocated_assetpath(::std::string* assetpath);

  // optional uint32 SwitchConfId = 11;
  inline bool has_switchconfid() const;
  inline void clear_switchconfid();
  static const int kSwitchConfIdFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>switchconfid</name>
  		<replaceName>SwitchConfId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_switchconfid</name>
  		<replaceName>SwitchConfId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_switchconfid</name>
  		<replaceName>SwitchConfId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 switchconfid() const;
  inline void set_switchconfid(::google::protobuf::uint32 value);

  // optional float PressScale = 12;
  inline bool has_pressscale() const;
  inline void clear_pressscale();
  static const int kPressScaleFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>pressscale</name>
  		<replaceName>PressScale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_pressscale</name>
  		<replaceName>PressScale</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pressscale</name>
  		<replaceName>PressScale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float pressscale() const;
  inline void set_pressscale(float value);

  // optional .pb.PbVector2 Fake3dOffset = 13;
  inline bool has_fake3doffset() const;
  inline void clear_fake3doffset();
  static const int kFake3DOffsetFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fake3doffset</name>
  		<replaceName>Fake3dOffset</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& fake3doffset() const;
  inline ::pb::PbVector2* mutable_fake3doffset();
  inline ::pb::PbVector2* release_fake3doffset();
  inline void set_allocated_fake3doffset(::pb::PbVector2* fake3doffset);

  // optional string EntranceName = 14;
  inline bool has_entrancename() const;
  inline void clear_entrancename();
  static const int kEntranceNameFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>FeatureEntrance</name>
  	<Function>
  		<name>entrancename</name>
  		<replaceName>EntranceName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_entrancename</name>
  		<replaceName>EntranceName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_entrancename</name>
  		<replaceName>EntranceName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& entrancename() const;
  inline void set_entrancename(const ::std::string& value);
  inline void set_entrancename(const char* value);
  inline void set_entrancename(const char* value, size_t size);
  inline ::std::string* mutable_entrancename();
  inline ::std::string* release_entrancename();
  inline void set_allocated_entrancename(::std::string* entrancename);

  // @@protoc_insertion_point(class_scope:pb.FeatureEntrance)
 private:
  inline void set_has_interactable();
  inline void clear_has_interactable();
  inline void set_has_featureentranceid();
  inline void clear_has_featureentranceid();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_eventfuncid();
  inline void clear_has_eventfuncid();
  inline void set_has_params();
  inline void clear_has_params();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_sortedlayer();
  inline void clear_has_sortedlayer();
  inline void set_has_orderinlayer();
  inline void clear_has_orderinlayer();
  inline void set_has_assetpath();
  inline void clear_has_assetpath();
  inline void set_has_switchconfid();
  inline void clear_has_switchconfid();
  inline void set_has_pressscale();
  inline void clear_has_pressscale();
  inline void set_has_fake3doffset();
  inline void clear_has_fake3doffset();
  inline void set_has_entrancename();
  inline void clear_has_entrancename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool interactable_;
  ::google::protobuf::int32 featureentranceid_;
  ::pb::PbVector2* position_;
  ::std::string* params_;
  ::pb::PbVector2* scale_;
  ::google::protobuf::int32 eventfuncid_;
  ::google::protobuf::uint32 orderinlayer_;
  ::std::string* sortedlayer_;
  ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 > attachpointarr_;
  ::std::string* assetpath_;
  ::google::protobuf::uint32 switchconfid_;
  float pressscale_;
  ::pb::PbVector2* fake3doffset_;
  ::std::string* entrancename_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static FeatureEntrance* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SceneChunkInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SceneChunkInfo : public ::google::protobuf::Message {
 public:
  SceneChunkInfo();
  virtual ~SceneChunkInfo();

  SceneChunkInfo(const SceneChunkInfo& from);

  inline SceneChunkInfo& operator=(const SceneChunkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneChunkInfo& default_instance();

  void Swap(SceneChunkInfo* other);

  // implements Message ----------------------------------------------

  SceneChunkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneChunkInfo& from);
  void MergeFrom(const SceneChunkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.PbVector2 CoordinateOrigin = 1;
  inline bool has_coordinateorigin() const;
  inline void clear_coordinateorigin();
  static const int kCoordinateOriginFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SceneChunkInfo</name>
  	<Function>
  		<name>coordinateorigin</name>
  		<replaceName>CoordinateOrigin</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_coordinateorigin</name>
  		<replaceName>CoordinateOrigin</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_coordinateorigin</name>
  		<replaceName>CoordinateOrigin</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_coordinateorigin</name>
  		<replaceName>CoordinateOrigin</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& coordinateorigin() const;
  inline ::pb::PbVector2* mutable_coordinateorigin();
  inline ::pb::PbVector2* release_coordinateorigin();
  inline void set_allocated_coordinateorigin(::pb::PbVector2* coordinateorigin);

  // required .pb.PbVector2 UnitChunkInfo = 2;
  inline bool has_unitchunkinfo() const;
  inline void clear_unitchunkinfo();
  static const int kUnitChunkInfoFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SceneChunkInfo</name>
  	<Function>
  		<name>unitchunkinfo</name>
  		<replaceName>UnitChunkInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_unitchunkinfo</name>
  		<replaceName>UnitChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_unitchunkinfo</name>
  		<replaceName>UnitChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_unitchunkinfo</name>
  		<replaceName>UnitChunkInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& unitchunkinfo() const;
  inline ::pb::PbVector2* mutable_unitchunkinfo();
  inline ::pb::PbVector2* release_unitchunkinfo();
  inline void set_allocated_unitchunkinfo(::pb::PbVector2* unitchunkinfo);

  // @@protoc_insertion_point(class_scope:pb.SceneChunkInfo)
 private:
  inline void set_has_coordinateorigin();
  inline void clear_has_coordinateorigin();
  inline void set_has_unitchunkinfo();
  inline void clear_has_unitchunkinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector2* coordinateorigin_;
  ::pb::PbVector2* unitchunkinfo_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static SceneChunkInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>Obstacle</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConf2d.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class Obstacle : public ::google::protobuf::Message {
 public:
  Obstacle();
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();

  void Swap(Obstacle* other);

  // implements Message ----------------------------------------------

  Obstacle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>Obstacle</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool Visible = 2;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>Obstacle</name>
  	<Function>
  		<name>visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_visible</name>
  		<replaceName>Visible</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:pb.Obstacle)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  bool visible_;
  friend void  protobuf_AddDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConf2d_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConf2d_2eproto();

  void InitAsDefaultInstance();
  static Obstacle* default_instance_;
};
// ===================================================================


// ===================================================================

// PointElement2

// required .pb.ESceneElementType ElementType = 1;
inline bool PointElement2::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointElement2::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointElement2::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointElement2::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType PointElement2::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void PointElement2::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.PointElement2.ElementType)
}

// required string Name = 2;
inline bool PointElement2::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointElement2::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointElement2::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointElement2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PointElement2::name() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.Name)
  return *name_;
}
inline void PointElement2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PointElement2.Name)
}
inline void PointElement2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PointElement2.Name)
}
inline void PointElement2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PointElement2.Name)
}
inline ::std::string* PointElement2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PointElement2.Name)
  return name_;
}
inline ::std::string* PointElement2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PointElement2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement2.Name)
}

// required .pb.PbVector2 Position = 3;
inline bool PointElement2::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointElement2::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointElement2::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointElement2::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& PointElement2::position() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* PointElement2::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.PointElement2.Position)
  return position_;
}
inline ::pb::PbVector2* PointElement2::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PointElement2::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement2.Position)
}

// optional string SortingLayer = 4;
inline bool PointElement2::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointElement2::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointElement2::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointElement2::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& PointElement2::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.SortingLayer)
  return *sortinglayer_;
}
inline void PointElement2::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PointElement2.SortingLayer)
}
inline void PointElement2::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PointElement2.SortingLayer)
}
inline void PointElement2::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PointElement2.SortingLayer)
}
inline ::std::string* PointElement2::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PointElement2.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* PointElement2::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PointElement2::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement2.SortingLayer)
}

// optional uint32 SortingOrder = 5;
inline bool PointElement2::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PointElement2::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PointElement2::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PointElement2::clear_sortingorder() {
  sortingorder_ = 0u;
  clear_has_sortingorder();
}
inline ::google::protobuf::uint32 PointElement2::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.SortingOrder)
  return sortingorder_;
}
inline void PointElement2::set_sortingorder(::google::protobuf::uint32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.PointElement2.SortingOrder)
}

// optional .pb.PbVector2 Direction = 6;
inline bool PointElement2::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PointElement2::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PointElement2::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PointElement2::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector2::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector2& PointElement2::direction() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector2* PointElement2::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.PointElement2.Direction)
  return direction_;
}
inline ::pb::PbVector2* PointElement2::release_direction() {
  clear_has_direction();
  ::pb::PbVector2* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void PointElement2::set_allocated_direction(::pb::PbVector2* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement2.Direction)
}

// optional .pb.PbVector2 Fake3dOffset = 7;
inline bool PointElement2::has_fake3doffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PointElement2::set_has_fake3doffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PointElement2::clear_has_fake3doffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PointElement2::clear_fake3doffset() {
  if (fake3doffset_ != NULL) fake3doffset_->::pb::PbVector2::Clear();
  clear_has_fake3doffset();
}
inline const ::pb::PbVector2& PointElement2::fake3doffset() const {
  // @@protoc_insertion_point(field_get:pb.PointElement2.Fake3dOffset)
  return fake3doffset_ != NULL ? *fake3doffset_ : *default_instance_->fake3doffset_;
}
inline ::pb::PbVector2* PointElement2::mutable_fake3doffset() {
  set_has_fake3doffset();
  if (fake3doffset_ == NULL) fake3doffset_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.PointElement2.Fake3dOffset)
  return fake3doffset_;
}
inline ::pb::PbVector2* PointElement2::release_fake3doffset() {
  clear_has_fake3doffset();
  ::pb::PbVector2* temp = fake3doffset_;
  fake3doffset_ = NULL;
  return temp;
}
inline void PointElement2::set_allocated_fake3doffset(::pb::PbVector2* fake3doffset) {
  delete fake3doffset_;
  fake3doffset_ = fake3doffset;
  if (fake3doffset) {
    set_has_fake3doffset();
  } else {
    clear_has_fake3doffset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PointElement2.Fake3dOffset)
}

// -------------------------------------------------------------------

// AttachPoint2

// optional string Name = 1;
inline bool AttachPoint2::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachPoint2::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachPoint2::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachPoint2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AttachPoint2::name() const {
  // @@protoc_insertion_point(field_get:pb.AttachPoint2.Name)
  return *name_;
}
inline void AttachPoint2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AttachPoint2.Name)
}
inline void AttachPoint2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AttachPoint2.Name)
}
inline void AttachPoint2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AttachPoint2.Name)
}
inline ::std::string* AttachPoint2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AttachPoint2.Name)
  return name_;
}
inline ::std::string* AttachPoint2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AttachPoint2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AttachPoint2.Name)
}

// optional .pb.PbVector2 Position = 2;
inline bool AttachPoint2::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttachPoint2::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttachPoint2::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttachPoint2::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& AttachPoint2::position() const {
  // @@protoc_insertion_point(field_get:pb.AttachPoint2.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* AttachPoint2::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AttachPoint2.Position)
  return position_;
}
inline ::pb::PbVector2* AttachPoint2::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void AttachPoint2::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AttachPoint2.Position)
}

// optional .pb.PbVector2 WorldScale = 3;
inline bool AttachPoint2::has_worldscale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttachPoint2::set_has_worldscale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttachPoint2::clear_has_worldscale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttachPoint2::clear_worldscale() {
  if (worldscale_ != NULL) worldscale_->::pb::PbVector2::Clear();
  clear_has_worldscale();
}
inline const ::pb::PbVector2& AttachPoint2::worldscale() const {
  // @@protoc_insertion_point(field_get:pb.AttachPoint2.WorldScale)
  return worldscale_ != NULL ? *worldscale_ : *default_instance_->worldscale_;
}
inline ::pb::PbVector2* AttachPoint2::mutable_worldscale() {
  set_has_worldscale();
  if (worldscale_ == NULL) worldscale_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AttachPoint2.WorldScale)
  return worldscale_;
}
inline ::pb::PbVector2* AttachPoint2::release_worldscale() {
  clear_has_worldscale();
  ::pb::PbVector2* temp = worldscale_;
  worldscale_ = NULL;
  return temp;
}
inline void AttachPoint2::set_allocated_worldscale(::pb::PbVector2* worldscale) {
  delete worldscale_;
  worldscale_ = worldscale;
  if (worldscale) {
    set_has_worldscale();
  } else {
    clear_has_worldscale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AttachPoint2.WorldScale)
}

// -------------------------------------------------------------------

// BindAssetInfo

// optional string AssetEleName = 1;
inline bool BindAssetInfo::has_assetelename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindAssetInfo::set_has_assetelename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindAssetInfo::clear_has_assetelename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindAssetInfo::clear_assetelename() {
  if (assetelename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetelename_->clear();
  }
  clear_has_assetelename();
}
inline const ::std::string& BindAssetInfo::assetelename() const {
  // @@protoc_insertion_point(field_get:pb.BindAssetInfo.AssetEleName)
  return *assetelename_;
}
inline void BindAssetInfo::set_assetelename(const ::std::string& value) {
  set_has_assetelename();
  if (assetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetelename_ = new ::std::string;
  }
  assetelename_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BindAssetInfo.AssetEleName)
}
inline void BindAssetInfo::set_assetelename(const char* value) {
  set_has_assetelename();
  if (assetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetelename_ = new ::std::string;
  }
  assetelename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BindAssetInfo.AssetEleName)
}
inline void BindAssetInfo::set_assetelename(const char* value, size_t size) {
  set_has_assetelename();
  if (assetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetelename_ = new ::std::string;
  }
  assetelename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BindAssetInfo.AssetEleName)
}
inline ::std::string* BindAssetInfo::mutable_assetelename() {
  set_has_assetelename();
  if (assetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetelename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BindAssetInfo.AssetEleName)
  return assetelename_;
}
inline ::std::string* BindAssetInfo::release_assetelename() {
  clear_has_assetelename();
  if (assetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetelename_;
    assetelename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindAssetInfo::set_allocated_assetelename(::std::string* assetelename) {
  if (assetelename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetelename_;
  }
  if (assetelename) {
    set_has_assetelename();
    assetelename_ = assetelename;
  } else {
    clear_has_assetelename();
    assetelename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BindAssetInfo.AssetEleName)
}

// optional string ActiveMoveTargetEleName = 2;
inline bool BindAssetInfo::has_activemovetargetelename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindAssetInfo::set_has_activemovetargetelename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindAssetInfo::clear_has_activemovetargetelename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindAssetInfo::clear_activemovetargetelename() {
  if (activemovetargetelename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activemovetargetelename_->clear();
  }
  clear_has_activemovetargetelename();
}
inline const ::std::string& BindAssetInfo::activemovetargetelename() const {
  // @@protoc_insertion_point(field_get:pb.BindAssetInfo.ActiveMoveTargetEleName)
  return *activemovetargetelename_;
}
inline void BindAssetInfo::set_activemovetargetelename(const ::std::string& value) {
  set_has_activemovetargetelename();
  if (activemovetargetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activemovetargetelename_ = new ::std::string;
  }
  activemovetargetelename_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BindAssetInfo.ActiveMoveTargetEleName)
}
inline void BindAssetInfo::set_activemovetargetelename(const char* value) {
  set_has_activemovetargetelename();
  if (activemovetargetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activemovetargetelename_ = new ::std::string;
  }
  activemovetargetelename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BindAssetInfo.ActiveMoveTargetEleName)
}
inline void BindAssetInfo::set_activemovetargetelename(const char* value, size_t size) {
  set_has_activemovetargetelename();
  if (activemovetargetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activemovetargetelename_ = new ::std::string;
  }
  activemovetargetelename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BindAssetInfo.ActiveMoveTargetEleName)
}
inline ::std::string* BindAssetInfo::mutable_activemovetargetelename() {
  set_has_activemovetargetelename();
  if (activemovetargetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activemovetargetelename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BindAssetInfo.ActiveMoveTargetEleName)
  return activemovetargetelename_;
}
inline ::std::string* BindAssetInfo::release_activemovetargetelename() {
  clear_has_activemovetargetelename();
  if (activemovetargetelename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = activemovetargetelename_;
    activemovetargetelename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindAssetInfo::set_allocated_activemovetargetelename(::std::string* activemovetargetelename) {
  if (activemovetargetelename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete activemovetargetelename_;
  }
  if (activemovetargetelename) {
    set_has_activemovetargetelename();
    activemovetargetelename_ = activemovetargetelename;
  } else {
    clear_has_activemovetargetelename();
    activemovetargetelename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BindAssetInfo.ActiveMoveTargetEleName)
}

// optional float MoveSpeed = 3;
inline bool BindAssetInfo::has_movespeed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindAssetInfo::set_has_movespeed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindAssetInfo::clear_has_movespeed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindAssetInfo::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline float BindAssetInfo::movespeed() const {
  // @@protoc_insertion_point(field_get:pb.BindAssetInfo.MoveSpeed)
  return movespeed_;
}
inline void BindAssetInfo::set_movespeed(float value) {
  set_has_movespeed();
  movespeed_ = value;
  // @@protoc_insertion_point(field_set:pb.BindAssetInfo.MoveSpeed)
}

// optional string MoveAnimName = 4;
inline bool BindAssetInfo::has_moveanimname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindAssetInfo::set_has_moveanimname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindAssetInfo::clear_has_moveanimname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindAssetInfo::clear_moveanimname() {
  if (moveanimname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moveanimname_->clear();
  }
  clear_has_moveanimname();
}
inline const ::std::string& BindAssetInfo::moveanimname() const {
  // @@protoc_insertion_point(field_get:pb.BindAssetInfo.MoveAnimName)
  return *moveanimname_;
}
inline void BindAssetInfo::set_moveanimname(const ::std::string& value) {
  set_has_moveanimname();
  if (moveanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moveanimname_ = new ::std::string;
  }
  moveanimname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BindAssetInfo.MoveAnimName)
}
inline void BindAssetInfo::set_moveanimname(const char* value) {
  set_has_moveanimname();
  if (moveanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moveanimname_ = new ::std::string;
  }
  moveanimname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BindAssetInfo.MoveAnimName)
}
inline void BindAssetInfo::set_moveanimname(const char* value, size_t size) {
  set_has_moveanimname();
  if (moveanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moveanimname_ = new ::std::string;
  }
  moveanimname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BindAssetInfo.MoveAnimName)
}
inline ::std::string* BindAssetInfo::mutable_moveanimname() {
  set_has_moveanimname();
  if (moveanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moveanimname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BindAssetInfo.MoveAnimName)
  return moveanimname_;
}
inline ::std::string* BindAssetInfo::release_moveanimname() {
  clear_has_moveanimname();
  if (moveanimname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = moveanimname_;
    moveanimname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindAssetInfo::set_allocated_moveanimname(::std::string* moveanimname) {
  if (moveanimname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete moveanimname_;
  }
  if (moveanimname) {
    set_has_moveanimname();
    moveanimname_ = moveanimname;
  } else {
    clear_has_moveanimname();
    moveanimname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BindAssetInfo.MoveAnimName)
}

// optional .pb.PbVector2 MoveEndDirection = 5;
inline bool BindAssetInfo::has_moveenddirection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindAssetInfo::set_has_moveenddirection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindAssetInfo::clear_has_moveenddirection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindAssetInfo::clear_moveenddirection() {
  if (moveenddirection_ != NULL) moveenddirection_->::pb::PbVector2::Clear();
  clear_has_moveenddirection();
}
inline const ::pb::PbVector2& BindAssetInfo::moveenddirection() const {
  // @@protoc_insertion_point(field_get:pb.BindAssetInfo.MoveEndDirection)
  return moveenddirection_ != NULL ? *moveenddirection_ : *default_instance_->moveenddirection_;
}
inline ::pb::PbVector2* BindAssetInfo::mutable_moveenddirection() {
  set_has_moveenddirection();
  if (moveenddirection_ == NULL) moveenddirection_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.BindAssetInfo.MoveEndDirection)
  return moveenddirection_;
}
inline ::pb::PbVector2* BindAssetInfo::release_moveenddirection() {
  clear_has_moveenddirection();
  ::pb::PbVector2* temp = moveenddirection_;
  moveenddirection_ = NULL;
  return temp;
}
inline void BindAssetInfo::set_allocated_moveenddirection(::pb::PbVector2* moveenddirection) {
  delete moveenddirection_;
  moveenddirection_ = moveenddirection;
  if (moveenddirection) {
    set_has_moveenddirection();
  } else {
    clear_has_moveenddirection();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BindAssetInfo.MoveEndDirection)
}

// optional string ArrivedAnim = 6;
inline bool BindAssetInfo::has_arrivedanim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindAssetInfo::set_has_arrivedanim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindAssetInfo::clear_has_arrivedanim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindAssetInfo::clear_arrivedanim() {
  if (arrivedanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arrivedanim_->clear();
  }
  clear_has_arrivedanim();
}
inline const ::std::string& BindAssetInfo::arrivedanim() const {
  // @@protoc_insertion_point(field_get:pb.BindAssetInfo.ArrivedAnim)
  return *arrivedanim_;
}
inline void BindAssetInfo::set_arrivedanim(const ::std::string& value) {
  set_has_arrivedanim();
  if (arrivedanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arrivedanim_ = new ::std::string;
  }
  arrivedanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.BindAssetInfo.ArrivedAnim)
}
inline void BindAssetInfo::set_arrivedanim(const char* value) {
  set_has_arrivedanim();
  if (arrivedanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arrivedanim_ = new ::std::string;
  }
  arrivedanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BindAssetInfo.ArrivedAnim)
}
inline void BindAssetInfo::set_arrivedanim(const char* value, size_t size) {
  set_has_arrivedanim();
  if (arrivedanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arrivedanim_ = new ::std::string;
  }
  arrivedanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BindAssetInfo.ArrivedAnim)
}
inline ::std::string* BindAssetInfo::mutable_arrivedanim() {
  set_has_arrivedanim();
  if (arrivedanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arrivedanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.BindAssetInfo.ArrivedAnim)
  return arrivedanim_;
}
inline ::std::string* BindAssetInfo::release_arrivedanim() {
  clear_has_arrivedanim();
  if (arrivedanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = arrivedanim_;
    arrivedanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindAssetInfo::set_allocated_arrivedanim(::std::string* arrivedanim) {
  if (arrivedanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete arrivedanim_;
  }
  if (arrivedanim) {
    set_has_arrivedanim();
    arrivedanim_ = arrivedanim;
  } else {
    clear_has_arrivedanim();
    arrivedanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.BindAssetInfo.ArrivedAnim)
}

// -------------------------------------------------------------------

// RectArea2

// required .pb.ESceneElementType ElementType = 1;
inline bool RectArea2::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RectArea2::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RectArea2::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RectArea2::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType RectArea2::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void RectArea2::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.RectArea2.ElementType)
}

// required string Name = 2;
inline bool RectArea2::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RectArea2::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RectArea2::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RectArea2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RectArea2::name() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.Name)
  return *name_;
}
inline void RectArea2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.RectArea2.Name)
}
inline void RectArea2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.RectArea2.Name)
}
inline void RectArea2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.RectArea2.Name)
}
inline ::std::string* RectArea2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.Name)
  return name_;
}
inline ::std::string* RectArea2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RectArea2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea2.Name)
}

// required .pb.PbRect RectInfo = 3;
inline bool RectArea2::has_rectinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RectArea2::set_has_rectinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RectArea2::clear_has_rectinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RectArea2::clear_rectinfo() {
  if (rectinfo_ != NULL) rectinfo_->::pb::PbRect::Clear();
  clear_has_rectinfo();
}
inline const ::pb::PbRect& RectArea2::rectinfo() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.RectInfo)
  return rectinfo_ != NULL ? *rectinfo_ : *default_instance_->rectinfo_;
}
inline ::pb::PbRect* RectArea2::mutable_rectinfo() {
  set_has_rectinfo();
  if (rectinfo_ == NULL) rectinfo_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.RectInfo)
  return rectinfo_;
}
inline ::pb::PbRect* RectArea2::release_rectinfo() {
  clear_has_rectinfo();
  ::pb::PbRect* temp = rectinfo_;
  rectinfo_ = NULL;
  return temp;
}
inline void RectArea2::set_allocated_rectinfo(::pb::PbRect* rectinfo) {
  delete rectinfo_;
  rectinfo_ = rectinfo;
  if (rectinfo) {
    set_has_rectinfo();
  } else {
    clear_has_rectinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea2.RectInfo)
}

// required .pb.PbVector2 CenterPosition = 4;
inline bool RectArea2::has_centerposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RectArea2::set_has_centerposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RectArea2::clear_has_centerposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RectArea2::clear_centerposition() {
  if (centerposition_ != NULL) centerposition_->::pb::PbVector2::Clear();
  clear_has_centerposition();
}
inline const ::pb::PbVector2& RectArea2::centerposition() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.CenterPosition)
  return centerposition_ != NULL ? *centerposition_ : *default_instance_->centerposition_;
}
inline ::pb::PbVector2* RectArea2::mutable_centerposition() {
  set_has_centerposition();
  if (centerposition_ == NULL) centerposition_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.CenterPosition)
  return centerposition_;
}
inline ::pb::PbVector2* RectArea2::release_centerposition() {
  clear_has_centerposition();
  ::pb::PbVector2* temp = centerposition_;
  centerposition_ = NULL;
  return temp;
}
inline void RectArea2::set_allocated_centerposition(::pb::PbVector2* centerposition) {
  delete centerposition_;
  centerposition_ = centerposition;
  if (centerposition) {
    set_has_centerposition();
  } else {
    clear_has_centerposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea2.CenterPosition)
}

// required bool Visible = 5;
inline bool RectArea2::has_visible() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RectArea2::set_has_visible() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RectArea2::clear_has_visible() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RectArea2::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool RectArea2::visible() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.Visible)
  return visible_;
}
inline void RectArea2::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.RectArea2.Visible)
}

// repeated .pb.AttachPoint2 AttachPointArr = 6;
inline int RectArea2::attachpointarr_size() const {
  return attachpointarr_.size();
}
inline void RectArea2::clear_attachpointarr() {
  attachpointarr_.Clear();
}
inline const ::pb::AttachPoint2& RectArea2::attachpointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.AttachPointArr)
  return attachpointarr_.Get(index);
}
inline ::pb::AttachPoint2* RectArea2::mutable_attachpointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.AttachPointArr)
  return attachpointarr_.Mutable(index);
}
inline ::pb::AttachPoint2* RectArea2::add_attachpointarr() {
  // @@protoc_insertion_point(field_add:pb.RectArea2.AttachPointArr)
  return attachpointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
RectArea2::attachpointarr() const {
  // @@protoc_insertion_point(field_list:pb.RectArea2.AttachPointArr)
  return attachpointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
RectArea2::mutable_attachpointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.RectArea2.AttachPointArr)
  return &attachpointarr_;
}

// optional string SortingLayer = 7;
inline bool RectArea2::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RectArea2::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RectArea2::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RectArea2::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& RectArea2::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.SortingLayer)
  return *sortinglayer_;
}
inline void RectArea2::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.RectArea2.SortingLayer)
}
inline void RectArea2::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.RectArea2.SortingLayer)
}
inline void RectArea2::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.RectArea2.SortingLayer)
}
inline ::std::string* RectArea2::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* RectArea2::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RectArea2::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea2.SortingLayer)
}

// optional int32 SortingOrder = 8;
inline bool RectArea2::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RectArea2::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RectArea2::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RectArea2::clear_sortingorder() {
  sortingorder_ = 0;
  clear_has_sortingorder();
}
inline ::google::protobuf::int32 RectArea2::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.SortingOrder)
  return sortingorder_;
}
inline void RectArea2::set_sortingorder(::google::protobuf::int32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.RectArea2.SortingOrder)
}

// repeated .pb.BindAssetInfo ActiveBindAssetInfoArr = 9;
inline int RectArea2::activebindassetinfoarr_size() const {
  return activebindassetinfoarr_.size();
}
inline void RectArea2::clear_activebindassetinfoarr() {
  activebindassetinfoarr_.Clear();
}
inline const ::pb::BindAssetInfo& RectArea2::activebindassetinfoarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.ActiveBindAssetInfoArr)
  return activebindassetinfoarr_.Get(index);
}
inline ::pb::BindAssetInfo* RectArea2::mutable_activebindassetinfoarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.ActiveBindAssetInfoArr)
  return activebindassetinfoarr_.Mutable(index);
}
inline ::pb::BindAssetInfo* RectArea2::add_activebindassetinfoarr() {
  // @@protoc_insertion_point(field_add:pb.RectArea2.ActiveBindAssetInfoArr)
  return activebindassetinfoarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BindAssetInfo >&
RectArea2::activebindassetinfoarr() const {
  // @@protoc_insertion_point(field_list:pb.RectArea2.ActiveBindAssetInfoArr)
  return activebindassetinfoarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BindAssetInfo >*
RectArea2::mutable_activebindassetinfoarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.RectArea2.ActiveBindAssetInfoArr)
  return &activebindassetinfoarr_;
}

// optional int32 ConfTid = 10;
inline bool RectArea2::has_conftid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RectArea2::set_has_conftid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RectArea2::clear_has_conftid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RectArea2::clear_conftid() {
  conftid_ = 0;
  clear_has_conftid();
}
inline ::google::protobuf::int32 RectArea2::conftid() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.ConfTid)
  return conftid_;
}
inline void RectArea2::set_conftid(::google::protobuf::int32 value) {
  set_has_conftid();
  conftid_ = value;
  // @@protoc_insertion_point(field_set:pb.RectArea2.ConfTid)
}

// optional string ViewElementName = 11;
inline bool RectArea2::has_viewelementname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RectArea2::set_has_viewelementname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RectArea2::clear_has_viewelementname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RectArea2::clear_viewelementname() {
  if (viewelementname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_->clear();
  }
  clear_has_viewelementname();
}
inline const ::std::string& RectArea2::viewelementname() const {
  // @@protoc_insertion_point(field_get:pb.RectArea2.ViewElementName)
  return *viewelementname_;
}
inline void RectArea2::set_viewelementname(const ::std::string& value) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.RectArea2.ViewElementName)
}
inline void RectArea2::set_viewelementname(const char* value) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.RectArea2.ViewElementName)
}
inline void RectArea2::set_viewelementname(const char* value, size_t size) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.RectArea2.ViewElementName)
}
inline ::std::string* RectArea2::mutable_viewelementname() {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.RectArea2.ViewElementName)
  return viewelementname_;
}
inline ::std::string* RectArea2::release_viewelementname() {
  clear_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = viewelementname_;
    viewelementname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RectArea2::set_allocated_viewelementname(::std::string* viewelementname) {
  if (viewelementname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete viewelementname_;
  }
  if (viewelementname) {
    set_has_viewelementname();
    viewelementname_ = viewelementname;
  } else {
    clear_has_viewelementname();
    viewelementname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.RectArea2.ViewElementName)
}

// -------------------------------------------------------------------

// CustomArea2

// required .pb.ESceneElementType ElementType = 1;
inline bool CustomArea2::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomArea2::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomArea2::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomArea2::clear_elementtype() {
  elementtype_ = 1;
  clear_has_elementtype();
}
inline ::pb::ESceneElementType CustomArea2::elementtype() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea2.ElementType)
  return static_cast< ::pb::ESceneElementType >(elementtype_);
}
inline void CustomArea2::set_elementtype(::pb::ESceneElementType value) {
  assert(::pb::ESceneElementType_IsValid(value));
  set_has_elementtype();
  elementtype_ = value;
  // @@protoc_insertion_point(field_set:pb.CustomArea2.ElementType)
}

// required string Name = 2;
inline bool CustomArea2::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomArea2::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomArea2::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomArea2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CustomArea2::name() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea2.Name)
  return *name_;
}
inline void CustomArea2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CustomArea2.Name)
}
inline void CustomArea2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CustomArea2.Name)
}
inline void CustomArea2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CustomArea2.Name)
}
inline ::std::string* CustomArea2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CustomArea2.Name)
  return name_;
}
inline ::std::string* CustomArea2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CustomArea2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CustomArea2.Name)
}

// repeated .pb.PbVector2 ChunkIndexArr = 3;
inline int CustomArea2::chunkindexarr_size() const {
  return chunkindexarr_.size();
}
inline void CustomArea2::clear_chunkindexarr() {
  chunkindexarr_.Clear();
}
inline const ::pb::PbVector2& CustomArea2::chunkindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.CustomArea2.ChunkIndexArr)
  return chunkindexarr_.Get(index);
}
inline ::pb::PbVector2* CustomArea2::mutable_chunkindexarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.CustomArea2.ChunkIndexArr)
  return chunkindexarr_.Mutable(index);
}
inline ::pb::PbVector2* CustomArea2::add_chunkindexarr() {
  // @@protoc_insertion_point(field_add:pb.CustomArea2.ChunkIndexArr)
  return chunkindexarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >&
CustomArea2::chunkindexarr() const {
  // @@protoc_insertion_point(field_list:pb.CustomArea2.ChunkIndexArr)
  return chunkindexarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2 >*
CustomArea2::mutable_chunkindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.CustomArea2.ChunkIndexArr)
  return &chunkindexarr_;
}

// required bool Visible = 4;
inline bool CustomArea2::has_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CustomArea2::set_has_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CustomArea2::clear_has_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CustomArea2::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CustomArea2::visible() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea2.Visible)
  return visible_;
}
inline void CustomArea2::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.CustomArea2.Visible)
}

// optional string ViewElementName = 5;
inline bool CustomArea2::has_viewelementname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CustomArea2::set_has_viewelementname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CustomArea2::clear_has_viewelementname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CustomArea2::clear_viewelementname() {
  if (viewelementname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_->clear();
  }
  clear_has_viewelementname();
}
inline const ::std::string& CustomArea2::viewelementname() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea2.ViewElementName)
  return *viewelementname_;
}
inline void CustomArea2::set_viewelementname(const ::std::string& value) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CustomArea2.ViewElementName)
}
inline void CustomArea2::set_viewelementname(const char* value) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CustomArea2.ViewElementName)
}
inline void CustomArea2::set_viewelementname(const char* value, size_t size) {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  viewelementname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CustomArea2.ViewElementName)
}
inline ::std::string* CustomArea2::mutable_viewelementname() {
  set_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    viewelementname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CustomArea2.ViewElementName)
  return viewelementname_;
}
inline ::std::string* CustomArea2::release_viewelementname() {
  clear_has_viewelementname();
  if (viewelementname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = viewelementname_;
    viewelementname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CustomArea2::set_allocated_viewelementname(::std::string* viewelementname) {
  if (viewelementname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete viewelementname_;
  }
  if (viewelementname) {
    set_has_viewelementname();
    viewelementname_ = viewelementname;
  } else {
    clear_has_viewelementname();
    viewelementname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CustomArea2.ViewElementName)
}

// optional .pb.PbVector2 CenterPosition = 6;
inline bool CustomArea2::has_centerposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CustomArea2::set_has_centerposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CustomArea2::clear_has_centerposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CustomArea2::clear_centerposition() {
  if (centerposition_ != NULL) centerposition_->::pb::PbVector2::Clear();
  clear_has_centerposition();
}
inline const ::pb::PbVector2& CustomArea2::centerposition() const {
  // @@protoc_insertion_point(field_get:pb.CustomArea2.CenterPosition)
  return centerposition_ != NULL ? *centerposition_ : *default_instance_->centerposition_;
}
inline ::pb::PbVector2* CustomArea2::mutable_centerposition() {
  set_has_centerposition();
  if (centerposition_ == NULL) centerposition_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.CustomArea2.CenterPosition)
  return centerposition_;
}
inline ::pb::PbVector2* CustomArea2::release_centerposition() {
  clear_has_centerposition();
  ::pb::PbVector2* temp = centerposition_;
  centerposition_ = NULL;
  return temp;
}
inline void CustomArea2::set_allocated_centerposition(::pb::PbVector2* centerposition) {
  delete centerposition_;
  centerposition_ = centerposition;
  if (centerposition) {
    set_has_centerposition();
  } else {
    clear_has_centerposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CustomArea2.CenterPosition)
}

// -------------------------------------------------------------------

// GuardInfo

// optional float Radius = 1;
inline bool GuardInfo::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuardInfo::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuardInfo::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuardInfo::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float GuardInfo::radius() const {
  // @@protoc_insertion_point(field_get:pb.GuardInfo.Radius)
  return radius_;
}
inline void GuardInfo::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:pb.GuardInfo.Radius)
}

// optional uint32 Degree = 2;
inline bool GuardInfo::has_degree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuardInfo::set_has_degree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuardInfo::clear_has_degree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuardInfo::clear_degree() {
  degree_ = 0u;
  clear_has_degree();
}
inline ::google::protobuf::uint32 GuardInfo::degree() const {
  // @@protoc_insertion_point(field_get:pb.GuardInfo.Degree)
  return degree_;
}
inline void GuardInfo::set_degree(::google::protobuf::uint32 value) {
  set_has_degree();
  degree_ = value;
  // @@protoc_insertion_point(field_set:pb.GuardInfo.Degree)
}

// optional .pb.EGuardEventType EventType = 3;
inline bool GuardInfo::has_eventtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuardInfo::set_has_eventtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuardInfo::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuardInfo::clear_eventtype() {
  eventtype_ = 1;
  clear_has_eventtype();
}
inline ::pb::EGuardEventType GuardInfo::eventtype() const {
  // @@protoc_insertion_point(field_get:pb.GuardInfo.EventType)
  return static_cast< ::pb::EGuardEventType >(eventtype_);
}
inline void GuardInfo::set_eventtype(::pb::EGuardEventType value) {
  assert(::pb::EGuardEventType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
  // @@protoc_insertion_point(field_set:pb.GuardInfo.EventType)
}

// optional uint32 EventId = 4;
inline bool GuardInfo::has_eventid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuardInfo::set_has_eventid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuardInfo::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuardInfo::clear_eventid() {
  eventid_ = 0u;
  clear_has_eventid();
}
inline ::google::protobuf::uint32 GuardInfo::eventid() const {
  // @@protoc_insertion_point(field_get:pb.GuardInfo.EventId)
  return eventid_;
}
inline void GuardInfo::set_eventid(::google::protobuf::uint32 value) {
  set_has_eventid();
  eventid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuardInfo.EventId)
}

// -------------------------------------------------------------------

// PendantInfo

// optional string Name = 1;
inline bool PendantInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PendantInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PendantInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PendantInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PendantInfo::name() const {
  // @@protoc_insertion_point(field_get:pb.PendantInfo.Name)
  return *name_;
}
inline void PendantInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PendantInfo.Name)
}
inline void PendantInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PendantInfo.Name)
}
inline void PendantInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PendantInfo.Name)
}
inline ::std::string* PendantInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PendantInfo.Name)
  return name_;
}
inline ::std::string* PendantInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PendantInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PendantInfo.Name)
}

// optional string AssetPath = 2;
inline bool PendantInfo::has_assetpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PendantInfo::set_has_assetpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PendantInfo::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PendantInfo::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& PendantInfo::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.PendantInfo.AssetPath)
  return *assetpath_;
}
inline void PendantInfo::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PendantInfo.AssetPath)
}
inline void PendantInfo::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PendantInfo.AssetPath)
}
inline void PendantInfo::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PendantInfo.AssetPath)
}
inline ::std::string* PendantInfo::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PendantInfo.AssetPath)
  return assetpath_;
}
inline ::std::string* PendantInfo::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PendantInfo::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PendantInfo.AssetPath)
}

// optional uint32 AssetType = 3;
inline bool PendantInfo::has_assettype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PendantInfo::set_has_assettype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PendantInfo::clear_has_assettype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PendantInfo::clear_assettype() {
  assettype_ = 0u;
  clear_has_assettype();
}
inline ::google::protobuf::uint32 PendantInfo::assettype() const {
  // @@protoc_insertion_point(field_get:pb.PendantInfo.AssetType)
  return assettype_;
}
inline void PendantInfo::set_assettype(::google::protobuf::uint32 value) {
  set_has_assettype();
  assettype_ = value;
  // @@protoc_insertion_point(field_set:pb.PendantInfo.AssetType)
}

// optional string AttachPointName = 4;
inline bool PendantInfo::has_attachpointname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PendantInfo::set_has_attachpointname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PendantInfo::clear_has_attachpointname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PendantInfo::clear_attachpointname() {
  if (attachpointname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachpointname_->clear();
  }
  clear_has_attachpointname();
}
inline const ::std::string& PendantInfo::attachpointname() const {
  // @@protoc_insertion_point(field_get:pb.PendantInfo.AttachPointName)
  return *attachpointname_;
}
inline void PendantInfo::set_attachpointname(const ::std::string& value) {
  set_has_attachpointname();
  if (attachpointname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachpointname_ = new ::std::string;
  }
  attachpointname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PendantInfo.AttachPointName)
}
inline void PendantInfo::set_attachpointname(const char* value) {
  set_has_attachpointname();
  if (attachpointname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachpointname_ = new ::std::string;
  }
  attachpointname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PendantInfo.AttachPointName)
}
inline void PendantInfo::set_attachpointname(const char* value, size_t size) {
  set_has_attachpointname();
  if (attachpointname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachpointname_ = new ::std::string;
  }
  attachpointname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PendantInfo.AttachPointName)
}
inline ::std::string* PendantInfo::mutable_attachpointname() {
  set_has_attachpointname();
  if (attachpointname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachpointname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PendantInfo.AttachPointName)
  return attachpointname_;
}
inline ::std::string* PendantInfo::release_attachpointname() {
  clear_has_attachpointname();
  if (attachpointname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attachpointname_;
    attachpointname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PendantInfo::set_allocated_attachpointname(::std::string* attachpointname) {
  if (attachpointname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attachpointname_;
  }
  if (attachpointname) {
    set_has_attachpointname();
    attachpointname_ = attachpointname;
  } else {
    clear_has_attachpointname();
    attachpointname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PendantInfo.AttachPointName)
}

// optional float Scale = 5;
inline bool PendantInfo::has_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PendantInfo::set_has_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PendantInfo::clear_has_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PendantInfo::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float PendantInfo::scale() const {
  // @@protoc_insertion_point(field_get:pb.PendantInfo.Scale)
  return scale_;
}
inline void PendantInfo::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:pb.PendantInfo.Scale)
}

// -------------------------------------------------------------------

// AnimAsset2

// required string Name = 1;
inline bool AnimAsset2::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimAsset2::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimAsset2::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimAsset2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AnimAsset2::name() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.Name)
  return *name_;
}
inline void AnimAsset2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.Name)
}
inline void AnimAsset2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset2.Name)
}
inline void AnimAsset2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset2.Name)
}
inline ::std::string* AnimAsset2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.Name)
  return name_;
}
inline ::std::string* AnimAsset2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.Name)
}

// required .pb.PbVector2 Position = 2;
inline bool AnimAsset2::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimAsset2::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimAsset2::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimAsset2::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& AnimAsset2::position() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* AnimAsset2::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.Position)
  return position_;
}
inline ::pb::PbVector2* AnimAsset2::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void AnimAsset2::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.Position)
}

// required .pb.PbVector2 Scale = 3;
inline bool AnimAsset2::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimAsset2::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimAsset2::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimAsset2::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector2::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector2& AnimAsset2::scale() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector2* AnimAsset2::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.Scale)
  return scale_;
}
inline ::pb::PbVector2* AnimAsset2::release_scale() {
  clear_has_scale();
  ::pb::PbVector2* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void AnimAsset2::set_allocated_scale(::pb::PbVector2* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.Scale)
}

// required string AssetPath = 4;
inline bool AnimAsset2::has_assetpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimAsset2::set_has_assetpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimAsset2::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimAsset2::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& AnimAsset2::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.AssetPath)
  return *assetpath_;
}
inline void AnimAsset2::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.AssetPath)
}
inline void AnimAsset2::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset2.AssetPath)
}
inline void AnimAsset2::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset2.AssetPath)
}
inline ::std::string* AnimAsset2::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.AssetPath)
  return assetpath_;
}
inline ::std::string* AnimAsset2::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset2::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.AssetPath)
}

// optional string DefaultAnim = 5;
inline bool AnimAsset2::has_defaultanim() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnimAsset2::set_has_defaultanim() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnimAsset2::clear_has_defaultanim() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnimAsset2::clear_defaultanim() {
  if (defaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_->clear();
  }
  clear_has_defaultanim();
}
inline const ::std::string& AnimAsset2::defaultanim() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.DefaultAnim)
  return *defaultanim_;
}
inline void AnimAsset2::set_defaultanim(const ::std::string& value) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.DefaultAnim)
}
inline void AnimAsset2::set_defaultanim(const char* value) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset2.DefaultAnim)
}
inline void AnimAsset2::set_defaultanim(const char* value, size_t size) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset2.DefaultAnim)
}
inline ::std::string* AnimAsset2::mutable_defaultanim() {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.DefaultAnim)
  return defaultanim_;
}
inline ::std::string* AnimAsset2::release_defaultanim() {
  clear_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = defaultanim_;
    defaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset2::set_allocated_defaultanim(::std::string* defaultanim) {
  if (defaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete defaultanim_;
  }
  if (defaultanim) {
    set_has_defaultanim();
    defaultanim_ = defaultanim;
  } else {
    clear_has_defaultanim();
    defaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.DefaultAnim)
}

// required bool Visible = 6;
inline bool AnimAsset2::has_visible() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnimAsset2::set_has_visible() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnimAsset2::clear_has_visible() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnimAsset2::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool AnimAsset2::visible() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.Visible)
  return visible_;
}
inline void AnimAsset2::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.Visible)
}

// optional .pb.PbVector2 Direction = 7;
inline bool AnimAsset2::has_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnimAsset2::set_has_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnimAsset2::clear_has_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnimAsset2::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector2::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector2& AnimAsset2::direction() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector2* AnimAsset2::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.Direction)
  return direction_;
}
inline ::pb::PbVector2* AnimAsset2::release_direction() {
  clear_has_direction();
  ::pb::PbVector2* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void AnimAsset2::set_allocated_direction(::pb::PbVector2* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.Direction)
}

// optional string SortingLayer = 8;
inline bool AnimAsset2::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AnimAsset2::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AnimAsset2::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AnimAsset2::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& AnimAsset2::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.SortingLayer)
  return *sortinglayer_;
}
inline void AnimAsset2::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.SortingLayer)
}
inline void AnimAsset2::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnimAsset2.SortingLayer)
}
inline void AnimAsset2::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnimAsset2.SortingLayer)
}
inline ::std::string* AnimAsset2::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* AnimAsset2::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnimAsset2::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.SortingLayer)
}

// optional uint32 SortingOrder = 9;
inline bool AnimAsset2::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AnimAsset2::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AnimAsset2::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AnimAsset2::clear_sortingorder() {
  sortingorder_ = 0u;
  clear_has_sortingorder();
}
inline ::google::protobuf::uint32 AnimAsset2::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.SortingOrder)
  return sortingorder_;
}
inline void AnimAsset2::set_sortingorder(::google::protobuf::uint32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.SortingOrder)
}

// optional bool WithGuard = 10;
inline bool AnimAsset2::has_withguard() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AnimAsset2::set_has_withguard() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AnimAsset2::clear_has_withguard() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AnimAsset2::clear_withguard() {
  withguard_ = false;
  clear_has_withguard();
}
inline bool AnimAsset2::withguard() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.WithGuard)
  return withguard_;
}
inline void AnimAsset2::set_withguard(bool value) {
  set_has_withguard();
  withguard_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.WithGuard)
}

// optional .pb.GuardInfo GuardInfo = 11;
inline bool AnimAsset2::has_guardinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AnimAsset2::set_has_guardinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AnimAsset2::clear_has_guardinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AnimAsset2::clear_guardinfo() {
  if (guardinfo_ != NULL) guardinfo_->::pb::GuardInfo::Clear();
  clear_has_guardinfo();
}
inline const ::pb::GuardInfo& AnimAsset2::guardinfo() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.GuardInfo)
  return guardinfo_ != NULL ? *guardinfo_ : *default_instance_->guardinfo_;
}
inline ::pb::GuardInfo* AnimAsset2::mutable_guardinfo() {
  set_has_guardinfo();
  if (guardinfo_ == NULL) guardinfo_ = new ::pb::GuardInfo;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.GuardInfo)
  return guardinfo_;
}
inline ::pb::GuardInfo* AnimAsset2::release_guardinfo() {
  clear_has_guardinfo();
  ::pb::GuardInfo* temp = guardinfo_;
  guardinfo_ = NULL;
  return temp;
}
inline void AnimAsset2::set_allocated_guardinfo(::pb::GuardInfo* guardinfo) {
  delete guardinfo_;
  guardinfo_ = guardinfo;
  if (guardinfo) {
    set_has_guardinfo();
  } else {
    clear_has_guardinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.GuardInfo)
}

// repeated .pb.AttachPoint2 AttachPointArr = 12;
inline int AnimAsset2::attachpointarr_size() const {
  return attachpointarr_.size();
}
inline void AnimAsset2::clear_attachpointarr() {
  attachpointarr_.Clear();
}
inline const ::pb::AttachPoint2& AnimAsset2::attachpointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.AttachPointArr)
  return attachpointarr_.Get(index);
}
inline ::pb::AttachPoint2* AnimAsset2::mutable_attachpointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.AttachPointArr)
  return attachpointarr_.Mutable(index);
}
inline ::pb::AttachPoint2* AnimAsset2::add_attachpointarr() {
  // @@protoc_insertion_point(field_add:pb.AnimAsset2.AttachPointArr)
  return attachpointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
AnimAsset2::attachpointarr() const {
  // @@protoc_insertion_point(field_list:pb.AnimAsset2.AttachPointArr)
  return attachpointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
AnimAsset2::mutable_attachpointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimAsset2.AttachPointArr)
  return &attachpointarr_;
}

// repeated .pb.PendantInfo PendantInfoArr = 13;
inline int AnimAsset2::pendantinfoarr_size() const {
  return pendantinfoarr_.size();
}
inline void AnimAsset2::clear_pendantinfoarr() {
  pendantinfoarr_.Clear();
}
inline const ::pb::PendantInfo& AnimAsset2::pendantinfoarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.PendantInfoArr)
  return pendantinfoarr_.Get(index);
}
inline ::pb::PendantInfo* AnimAsset2::mutable_pendantinfoarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.PendantInfoArr)
  return pendantinfoarr_.Mutable(index);
}
inline ::pb::PendantInfo* AnimAsset2::add_pendantinfoarr() {
  // @@protoc_insertion_point(field_add:pb.AnimAsset2.PendantInfoArr)
  return pendantinfoarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PendantInfo >&
AnimAsset2::pendantinfoarr() const {
  // @@protoc_insertion_point(field_list:pb.AnimAsset2.PendantInfoArr)
  return pendantinfoarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PendantInfo >*
AnimAsset2::mutable_pendantinfoarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AnimAsset2.PendantInfoArr)
  return &pendantinfoarr_;
}

// optional uint32 SpecialStyle = 14;
inline bool AnimAsset2::has_specialstyle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AnimAsset2::set_has_specialstyle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AnimAsset2::clear_has_specialstyle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AnimAsset2::clear_specialstyle() {
  specialstyle_ = 0u;
  clear_has_specialstyle();
}
inline ::google::protobuf::uint32 AnimAsset2::specialstyle() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.SpecialStyle)
  return specialstyle_;
}
inline void AnimAsset2::set_specialstyle(::google::protobuf::uint32 value) {
  set_has_specialstyle();
  specialstyle_ = value;
  // @@protoc_insertion_point(field_set:pb.AnimAsset2.SpecialStyle)
}

// optional .pb.PbVector2 Fake3dOffset = 15;
inline bool AnimAsset2::has_fake3doffset() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AnimAsset2::set_has_fake3doffset() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AnimAsset2::clear_has_fake3doffset() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AnimAsset2::clear_fake3doffset() {
  if (fake3doffset_ != NULL) fake3doffset_->::pb::PbVector2::Clear();
  clear_has_fake3doffset();
}
inline const ::pb::PbVector2& AnimAsset2::fake3doffset() const {
  // @@protoc_insertion_point(field_get:pb.AnimAsset2.Fake3dOffset)
  return fake3doffset_ != NULL ? *fake3doffset_ : *default_instance_->fake3doffset_;
}
inline ::pb::PbVector2* AnimAsset2::mutable_fake3doffset() {
  set_has_fake3doffset();
  if (fake3doffset_ == NULL) fake3doffset_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.AnimAsset2.Fake3dOffset)
  return fake3doffset_;
}
inline ::pb::PbVector2* AnimAsset2::release_fake3doffset() {
  clear_has_fake3doffset();
  ::pb::PbVector2* temp = fake3doffset_;
  fake3doffset_ = NULL;
  return temp;
}
inline void AnimAsset2::set_allocated_fake3doffset(::pb::PbVector2* fake3doffset) {
  delete fake3doffset_;
  fake3doffset_ = fake3doffset;
  if (fake3doffset) {
    set_has_fake3doffset();
  } else {
    clear_has_fake3doffset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnimAsset2.Fake3dOffset)
}

// -------------------------------------------------------------------

// StaticAsset2

// required string Name = 1;
inline bool StaticAsset2::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StaticAsset2::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StaticAsset2::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StaticAsset2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StaticAsset2::name() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.Name)
  return *name_;
}
inline void StaticAsset2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.StaticAsset2.Name)
}
inline void StaticAsset2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StaticAsset2.Name)
}
inline void StaticAsset2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StaticAsset2.Name)
}
inline ::std::string* StaticAsset2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.Name)
  return name_;
}
inline ::std::string* StaticAsset2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StaticAsset2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.Name)
}

// required .pb.PbVector2 Position = 2;
inline bool StaticAsset2::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StaticAsset2::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StaticAsset2::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StaticAsset2::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& StaticAsset2::position() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* StaticAsset2::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.Position)
  return position_;
}
inline ::pb::PbVector2* StaticAsset2::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void StaticAsset2::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.Position)
}

// required .pb.PbVector2 Scale = 3;
inline bool StaticAsset2::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StaticAsset2::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StaticAsset2::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StaticAsset2::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector2::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector2& StaticAsset2::scale() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector2* StaticAsset2::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.Scale)
  return scale_;
}
inline ::pb::PbVector2* StaticAsset2::release_scale() {
  clear_has_scale();
  ::pb::PbVector2* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void StaticAsset2::set_allocated_scale(::pb::PbVector2* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.Scale)
}

// required string AssetPath = 4;
inline bool StaticAsset2::has_assetpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StaticAsset2::set_has_assetpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StaticAsset2::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StaticAsset2::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& StaticAsset2::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.AssetPath)
  return *assetpath_;
}
inline void StaticAsset2::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.StaticAsset2.AssetPath)
}
inline void StaticAsset2::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StaticAsset2.AssetPath)
}
inline void StaticAsset2::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StaticAsset2.AssetPath)
}
inline ::std::string* StaticAsset2::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.AssetPath)
  return assetpath_;
}
inline ::std::string* StaticAsset2::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StaticAsset2::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.AssetPath)
}

// required bool Visible = 5;
inline bool StaticAsset2::has_visible() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StaticAsset2::set_has_visible() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StaticAsset2::clear_has_visible() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StaticAsset2::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool StaticAsset2::visible() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.Visible)
  return visible_;
}
inline void StaticAsset2::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.StaticAsset2.Visible)
}

// optional string SortingLayer = 6;
inline bool StaticAsset2::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StaticAsset2::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StaticAsset2::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StaticAsset2::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& StaticAsset2::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.SortingLayer)
  return *sortinglayer_;
}
inline void StaticAsset2::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.StaticAsset2.SortingLayer)
}
inline void StaticAsset2::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StaticAsset2.SortingLayer)
}
inline void StaticAsset2::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StaticAsset2.SortingLayer)
}
inline ::std::string* StaticAsset2::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* StaticAsset2::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StaticAsset2::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.SortingLayer)
}

// optional uint32 SortingOrder = 7;
inline bool StaticAsset2::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StaticAsset2::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StaticAsset2::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StaticAsset2::clear_sortingorder() {
  sortingorder_ = 0u;
  clear_has_sortingorder();
}
inline ::google::protobuf::uint32 StaticAsset2::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.SortingOrder)
  return sortingorder_;
}
inline void StaticAsset2::set_sortingorder(::google::protobuf::uint32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.StaticAsset2.SortingOrder)
}

// optional bool WithGuard = 8;
inline bool StaticAsset2::has_withguard() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StaticAsset2::set_has_withguard() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StaticAsset2::clear_has_withguard() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StaticAsset2::clear_withguard() {
  withguard_ = false;
  clear_has_withguard();
}
inline bool StaticAsset2::withguard() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.WithGuard)
  return withguard_;
}
inline void StaticAsset2::set_withguard(bool value) {
  set_has_withguard();
  withguard_ = value;
  // @@protoc_insertion_point(field_set:pb.StaticAsset2.WithGuard)
}

// optional .pb.GuardInfo GuardInfo = 9;
inline bool StaticAsset2::has_guardinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StaticAsset2::set_has_guardinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StaticAsset2::clear_has_guardinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StaticAsset2::clear_guardinfo() {
  if (guardinfo_ != NULL) guardinfo_->::pb::GuardInfo::Clear();
  clear_has_guardinfo();
}
inline const ::pb::GuardInfo& StaticAsset2::guardinfo() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.GuardInfo)
  return guardinfo_ != NULL ? *guardinfo_ : *default_instance_->guardinfo_;
}
inline ::pb::GuardInfo* StaticAsset2::mutable_guardinfo() {
  set_has_guardinfo();
  if (guardinfo_ == NULL) guardinfo_ = new ::pb::GuardInfo;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.GuardInfo)
  return guardinfo_;
}
inline ::pb::GuardInfo* StaticAsset2::release_guardinfo() {
  clear_has_guardinfo();
  ::pb::GuardInfo* temp = guardinfo_;
  guardinfo_ = NULL;
  return temp;
}
inline void StaticAsset2::set_allocated_guardinfo(::pb::GuardInfo* guardinfo) {
  delete guardinfo_;
  guardinfo_ = guardinfo;
  if (guardinfo) {
    set_has_guardinfo();
  } else {
    clear_has_guardinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.GuardInfo)
}

// optional .pb.PbVector2 Fake3dOffset = 10;
inline bool StaticAsset2::has_fake3doffset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StaticAsset2::set_has_fake3doffset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StaticAsset2::clear_has_fake3doffset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StaticAsset2::clear_fake3doffset() {
  if (fake3doffset_ != NULL) fake3doffset_->::pb::PbVector2::Clear();
  clear_has_fake3doffset();
}
inline const ::pb::PbVector2& StaticAsset2::fake3doffset() const {
  // @@protoc_insertion_point(field_get:pb.StaticAsset2.Fake3dOffset)
  return fake3doffset_ != NULL ? *fake3doffset_ : *default_instance_->fake3doffset_;
}
inline ::pb::PbVector2* StaticAsset2::mutable_fake3doffset() {
  set_has_fake3doffset();
  if (fake3doffset_ == NULL) fake3doffset_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.StaticAsset2.Fake3dOffset)
  return fake3doffset_;
}
inline ::pb::PbVector2* StaticAsset2::release_fake3doffset() {
  clear_has_fake3doffset();
  ::pb::PbVector2* temp = fake3doffset_;
  fake3doffset_ = NULL;
  return temp;
}
inline void StaticAsset2::set_allocated_fake3doffset(::pb::PbVector2* fake3doffset) {
  delete fake3doffset_;
  fake3doffset_ = fake3doffset;
  if (fake3doffset) {
    set_has_fake3doffset();
  } else {
    clear_has_fake3doffset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.StaticAsset2.Fake3dOffset)
}

// -------------------------------------------------------------------

// EffectAsset2

// required string Name = 1;
inline bool EffectAsset2::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectAsset2::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectAsset2::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectAsset2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EffectAsset2::name() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.Name)
  return *name_;
}
inline void EffectAsset2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectAsset2.Name)
}
inline void EffectAsset2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectAsset2.Name)
}
inline void EffectAsset2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectAsset2.Name)
}
inline ::std::string* EffectAsset2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset2.Name)
  return name_;
}
inline ::std::string* EffectAsset2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectAsset2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset2.Name)
}

// required .pb.PbVector2 Position = 2;
inline bool EffectAsset2::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectAsset2::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectAsset2::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectAsset2::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& EffectAsset2::position() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* EffectAsset2::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset2.Position)
  return position_;
}
inline ::pb::PbVector2* EffectAsset2::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void EffectAsset2::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset2.Position)
}

// required string AssetPath = 3;
inline bool EffectAsset2::has_assetpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectAsset2::set_has_assetpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EffectAsset2::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EffectAsset2::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& EffectAsset2::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.AssetPath)
  return *assetpath_;
}
inline void EffectAsset2::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectAsset2.AssetPath)
}
inline void EffectAsset2::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectAsset2.AssetPath)
}
inline void EffectAsset2::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectAsset2.AssetPath)
}
inline ::std::string* EffectAsset2::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset2.AssetPath)
  return assetpath_;
}
inline ::std::string* EffectAsset2::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectAsset2::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset2.AssetPath)
}

// required bool Visible = 4;
inline bool EffectAsset2::has_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EffectAsset2::set_has_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EffectAsset2::clear_has_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EffectAsset2::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool EffectAsset2::visible() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.Visible)
  return visible_;
}
inline void EffectAsset2::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectAsset2.Visible)
}

// optional string SortingLayer = 5;
inline bool EffectAsset2::has_sortinglayer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EffectAsset2::set_has_sortinglayer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EffectAsset2::clear_has_sortinglayer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EffectAsset2::clear_sortinglayer() {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_->clear();
  }
  clear_has_sortinglayer();
}
inline const ::std::string& EffectAsset2::sortinglayer() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.SortingLayer)
  return *sortinglayer_;
}
inline void EffectAsset2::set_sortinglayer(const ::std::string& value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EffectAsset2.SortingLayer)
}
inline void EffectAsset2::set_sortinglayer(const char* value) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EffectAsset2.SortingLayer)
}
inline void EffectAsset2::set_sortinglayer(const char* value, size_t size) {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  sortinglayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EffectAsset2.SortingLayer)
}
inline ::std::string* EffectAsset2::mutable_sortinglayer() {
  set_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortinglayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset2.SortingLayer)
  return sortinglayer_;
}
inline ::std::string* EffectAsset2::release_sortinglayer() {
  clear_has_sortinglayer();
  if (sortinglayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortinglayer_;
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EffectAsset2::set_allocated_sortinglayer(::std::string* sortinglayer) {
  if (sortinglayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortinglayer_;
  }
  if (sortinglayer) {
    set_has_sortinglayer();
    sortinglayer_ = sortinglayer;
  } else {
    clear_has_sortinglayer();
    sortinglayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset2.SortingLayer)
}

// optional uint32 SortingOrder = 6;
inline bool EffectAsset2::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EffectAsset2::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EffectAsset2::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EffectAsset2::clear_sortingorder() {
  sortingorder_ = 0u;
  clear_has_sortingorder();
}
inline ::google::protobuf::uint32 EffectAsset2::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.SortingOrder)
  return sortingorder_;
}
inline void EffectAsset2::set_sortingorder(::google::protobuf::uint32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectAsset2.SortingOrder)
}

// optional float Scale = 7;
inline bool EffectAsset2::has_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EffectAsset2::set_has_scale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EffectAsset2::clear_has_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EffectAsset2::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float EffectAsset2::scale() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.Scale)
  return scale_;
}
inline void EffectAsset2::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:pb.EffectAsset2.Scale)
}

// optional .pb.PbVector2 Fake3dOffset = 8;
inline bool EffectAsset2::has_fake3doffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EffectAsset2::set_has_fake3doffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EffectAsset2::clear_has_fake3doffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EffectAsset2::clear_fake3doffset() {
  if (fake3doffset_ != NULL) fake3doffset_->::pb::PbVector2::Clear();
  clear_has_fake3doffset();
}
inline const ::pb::PbVector2& EffectAsset2::fake3doffset() const {
  // @@protoc_insertion_point(field_get:pb.EffectAsset2.Fake3dOffset)
  return fake3doffset_ != NULL ? *fake3doffset_ : *default_instance_->fake3doffset_;
}
inline ::pb::PbVector2* EffectAsset2::mutable_fake3doffset() {
  set_has_fake3doffset();
  if (fake3doffset_ == NULL) fake3doffset_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.EffectAsset2.Fake3dOffset)
  return fake3doffset_;
}
inline ::pb::PbVector2* EffectAsset2::release_fake3doffset() {
  clear_has_fake3doffset();
  ::pb::PbVector2* temp = fake3doffset_;
  fake3doffset_ = NULL;
  return temp;
}
inline void EffectAsset2::set_allocated_fake3doffset(::pb::PbVector2* fake3doffset) {
  delete fake3doffset_;
  fake3doffset_ = fake3doffset;
  if (fake3doffset) {
    set_has_fake3doffset();
  } else {
    clear_has_fake3doffset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EffectAsset2.Fake3dOffset)
}

// -------------------------------------------------------------------

// AssetGroup

// optional string Name = 1;
inline bool AssetGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssetGroup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssetGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssetGroup::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AssetGroup::name() const {
  // @@protoc_insertion_point(field_get:pb.AssetGroup.Name)
  return *name_;
}
inline void AssetGroup::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AssetGroup.Name)
}
inline void AssetGroup::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AssetGroup.Name)
}
inline void AssetGroup::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AssetGroup.Name)
}
inline ::std::string* AssetGroup::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AssetGroup.Name)
  return name_;
}
inline ::std::string* AssetGroup::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssetGroup::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AssetGroup.Name)
}

// repeated .pb.EffectAsset2 EffectAssetArr = 2;
inline int AssetGroup::effectassetarr_size() const {
  return effectassetarr_.size();
}
inline void AssetGroup::clear_effectassetarr() {
  effectassetarr_.Clear();
}
inline const ::pb::EffectAsset2& AssetGroup::effectassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AssetGroup.EffectAssetArr)
  return effectassetarr_.Get(index);
}
inline ::pb::EffectAsset2* AssetGroup::mutable_effectassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AssetGroup.EffectAssetArr)
  return effectassetarr_.Mutable(index);
}
inline ::pb::EffectAsset2* AssetGroup::add_effectassetarr() {
  // @@protoc_insertion_point(field_add:pb.AssetGroup.EffectAssetArr)
  return effectassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
AssetGroup::effectassetarr() const {
  // @@protoc_insertion_point(field_list:pb.AssetGroup.EffectAssetArr)
  return effectassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
AssetGroup::mutable_effectassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AssetGroup.EffectAssetArr)
  return &effectassetarr_;
}

// repeated .pb.AnimAsset2 AnimAssetArr = 3;
inline int AssetGroup::animassetarr_size() const {
  return animassetarr_.size();
}
inline void AssetGroup::clear_animassetarr() {
  animassetarr_.Clear();
}
inline const ::pb::AnimAsset2& AssetGroup::animassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AssetGroup.AnimAssetArr)
  return animassetarr_.Get(index);
}
inline ::pb::AnimAsset2* AssetGroup::mutable_animassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AssetGroup.AnimAssetArr)
  return animassetarr_.Mutable(index);
}
inline ::pb::AnimAsset2* AssetGroup::add_animassetarr() {
  // @@protoc_insertion_point(field_add:pb.AssetGroup.AnimAssetArr)
  return animassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
AssetGroup::animassetarr() const {
  // @@protoc_insertion_point(field_list:pb.AssetGroup.AnimAssetArr)
  return animassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
AssetGroup::mutable_animassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AssetGroup.AnimAssetArr)
  return &animassetarr_;
}

// repeated .pb.StaticAsset2 StaticAssetArr = 4;
inline int AssetGroup::staticassetarr_size() const {
  return staticassetarr_.size();
}
inline void AssetGroup::clear_staticassetarr() {
  staticassetarr_.Clear();
}
inline const ::pb::StaticAsset2& AssetGroup::staticassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AssetGroup.StaticAssetArr)
  return staticassetarr_.Get(index);
}
inline ::pb::StaticAsset2* AssetGroup::mutable_staticassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AssetGroup.StaticAssetArr)
  return staticassetarr_.Mutable(index);
}
inline ::pb::StaticAsset2* AssetGroup::add_staticassetarr() {
  // @@protoc_insertion_point(field_add:pb.AssetGroup.StaticAssetArr)
  return staticassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
AssetGroup::staticassetarr() const {
  // @@protoc_insertion_point(field_list:pb.AssetGroup.StaticAssetArr)
  return staticassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
AssetGroup::mutable_staticassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AssetGroup.StaticAssetArr)
  return &staticassetarr_;
}

// -------------------------------------------------------------------

// PatrolPathPoint

// optional .pb.PbVector2 Position = 1;
inline bool PatrolPathPoint::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatrolPathPoint::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatrolPathPoint::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatrolPathPoint::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& PatrolPathPoint::position() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathPoint.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* PatrolPathPoint::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.PatrolPathPoint.Position)
  return position_;
}
inline ::pb::PbVector2* PatrolPathPoint::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PatrolPathPoint::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPathPoint.Position)
}

// optional float StayTime = 2;
inline bool PatrolPathPoint::has_staytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PatrolPathPoint::set_has_staytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PatrolPathPoint::clear_has_staytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PatrolPathPoint::clear_staytime() {
  staytime_ = 0;
  clear_has_staytime();
}
inline float PatrolPathPoint::staytime() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathPoint.StayTime)
  return staytime_;
}
inline void PatrolPathPoint::set_staytime(float value) {
  set_has_staytime();
  staytime_ = value;
  // @@protoc_insertion_point(field_set:pb.PatrolPathPoint.StayTime)
}

// -------------------------------------------------------------------

// PatrolPath2

// optional string Name = 1;
inline bool PatrolPath2::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatrolPath2::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatrolPath2::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatrolPath2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PatrolPath2::name() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPath2.Name)
  return *name_;
}
inline void PatrolPath2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PatrolPath2.Name)
}
inline void PatrolPath2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PatrolPath2.Name)
}
inline void PatrolPath2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PatrolPath2.Name)
}
inline ::std::string* PatrolPath2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PatrolPath2.Name)
  return name_;
}
inline ::std::string* PatrolPath2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PatrolPath2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPath2.Name)
}

// repeated .pb.PatrolPathPoint PointArr = 2;
inline int PatrolPath2::pointarr_size() const {
  return pointarr_.size();
}
inline void PatrolPath2::clear_pointarr() {
  pointarr_.Clear();
}
inline const ::pb::PatrolPathPoint& PatrolPath2::pointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.PatrolPath2.PointArr)
  return pointarr_.Get(index);
}
inline ::pb::PatrolPathPoint* PatrolPath2::mutable_pointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PatrolPath2.PointArr)
  return pointarr_.Mutable(index);
}
inline ::pb::PatrolPathPoint* PatrolPath2::add_pointarr() {
  // @@protoc_insertion_point(field_add:pb.PatrolPath2.PointArr)
  return pointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathPoint >&
PatrolPath2::pointarr() const {
  // @@protoc_insertion_point(field_list:pb.PatrolPath2.PointArr)
  return pointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PatrolPathPoint >*
PatrolPath2::mutable_pointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.PatrolPath2.PointArr)
  return &pointarr_;
}

// -------------------------------------------------------------------

// PatrolPathConf

// required string Name = 1;
inline bool PatrolPathConf::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatrolPathConf::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatrolPathConf::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatrolPathConf::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PatrolPathConf::name() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.Name)
  return *name_;
}
inline void PatrolPathConf::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.Name)
}
inline void PatrolPathConf::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PatrolPathConf.Name)
}
inline void PatrolPathConf::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PatrolPathConf.Name)
}
inline ::std::string* PatrolPathConf::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PatrolPathConf.Name)
  return name_;
}
inline ::std::string* PatrolPathConf::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PatrolPathConf::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPathConf.Name)
}

// required string PatrolPathName = 2;
inline bool PatrolPathConf::has_patrolpathname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PatrolPathConf::set_has_patrolpathname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PatrolPathConf::clear_has_patrolpathname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PatrolPathConf::clear_patrolpathname() {
  if (patrolpathname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolpathname_->clear();
  }
  clear_has_patrolpathname();
}
inline const ::std::string& PatrolPathConf::patrolpathname() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.PatrolPathName)
  return *patrolpathname_;
}
inline void PatrolPathConf::set_patrolpathname(const ::std::string& value) {
  set_has_patrolpathname();
  if (patrolpathname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolpathname_ = new ::std::string;
  }
  patrolpathname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.PatrolPathName)
}
inline void PatrolPathConf::set_patrolpathname(const char* value) {
  set_has_patrolpathname();
  if (patrolpathname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolpathname_ = new ::std::string;
  }
  patrolpathname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PatrolPathConf.PatrolPathName)
}
inline void PatrolPathConf::set_patrolpathname(const char* value, size_t size) {
  set_has_patrolpathname();
  if (patrolpathname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolpathname_ = new ::std::string;
  }
  patrolpathname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PatrolPathConf.PatrolPathName)
}
inline ::std::string* PatrolPathConf::mutable_patrolpathname() {
  set_has_patrolpathname();
  if (patrolpathname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolpathname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PatrolPathConf.PatrolPathName)
  return patrolpathname_;
}
inline ::std::string* PatrolPathConf::release_patrolpathname() {
  clear_has_patrolpathname();
  if (patrolpathname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = patrolpathname_;
    patrolpathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PatrolPathConf::set_allocated_patrolpathname(::std::string* patrolpathname) {
  if (patrolpathname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patrolpathname_;
  }
  if (patrolpathname) {
    set_has_patrolpathname();
    patrolpathname_ = patrolpathname;
  } else {
    clear_has_patrolpathname();
    patrolpathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPathConf.PatrolPathName)
}

// required string AnimAssetName = 3;
inline bool PatrolPathConf::has_animassetname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PatrolPathConf::set_has_animassetname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PatrolPathConf::clear_has_animassetname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PatrolPathConf::clear_animassetname() {
  if (animassetname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animassetname_->clear();
  }
  clear_has_animassetname();
}
inline const ::std::string& PatrolPathConf::animassetname() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.AnimAssetName)
  return *animassetname_;
}
inline void PatrolPathConf::set_animassetname(const ::std::string& value) {
  set_has_animassetname();
  if (animassetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animassetname_ = new ::std::string;
  }
  animassetname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.AnimAssetName)
}
inline void PatrolPathConf::set_animassetname(const char* value) {
  set_has_animassetname();
  if (animassetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animassetname_ = new ::std::string;
  }
  animassetname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PatrolPathConf.AnimAssetName)
}
inline void PatrolPathConf::set_animassetname(const char* value, size_t size) {
  set_has_animassetname();
  if (animassetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animassetname_ = new ::std::string;
  }
  animassetname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PatrolPathConf.AnimAssetName)
}
inline ::std::string* PatrolPathConf::mutable_animassetname() {
  set_has_animassetname();
  if (animassetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    animassetname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PatrolPathConf.AnimAssetName)
  return animassetname_;
}
inline ::std::string* PatrolPathConf::release_animassetname() {
  clear_has_animassetname();
  if (animassetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = animassetname_;
    animassetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PatrolPathConf::set_allocated_animassetname(::std::string* animassetname) {
  if (animassetname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete animassetname_;
  }
  if (animassetname) {
    set_has_animassetname();
    animassetname_ = animassetname;
  } else {
    clear_has_animassetname();
    animassetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPathConf.AnimAssetName)
}

// required uint32 PatrolType = 4;
inline bool PatrolPathConf::has_patroltype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PatrolPathConf::set_has_patroltype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PatrolPathConf::clear_has_patroltype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PatrolPathConf::clear_patroltype() {
  patroltype_ = 0u;
  clear_has_patroltype();
}
inline ::google::protobuf::uint32 PatrolPathConf::patroltype() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.PatrolType)
  return patroltype_;
}
inline void PatrolPathConf::set_patroltype(::google::protobuf::uint32 value) {
  set_has_patroltype();
  patroltype_ = value;
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.PatrolType)
}

// required float PatrolSpeed = 5;
inline bool PatrolPathConf::has_patrolspeed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PatrolPathConf::set_has_patrolspeed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PatrolPathConf::clear_has_patrolspeed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PatrolPathConf::clear_patrolspeed() {
  patrolspeed_ = 0;
  clear_has_patrolspeed();
}
inline float PatrolPathConf::patrolspeed() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.PatrolSpeed)
  return patrolspeed_;
}
inline void PatrolPathConf::set_patrolspeed(float value) {
  set_has_patrolspeed();
  patrolspeed_ = value;
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.PatrolSpeed)
}

// required string PatrolingAnim = 6;
inline bool PatrolPathConf::has_patrolinganim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PatrolPathConf::set_has_patrolinganim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PatrolPathConf::clear_has_patrolinganim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PatrolPathConf::clear_patrolinganim() {
  if (patrolinganim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolinganim_->clear();
  }
  clear_has_patrolinganim();
}
inline const ::std::string& PatrolPathConf::patrolinganim() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.PatrolingAnim)
  return *patrolinganim_;
}
inline void PatrolPathConf::set_patrolinganim(const ::std::string& value) {
  set_has_patrolinganim();
  if (patrolinganim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolinganim_ = new ::std::string;
  }
  patrolinganim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.PatrolingAnim)
}
inline void PatrolPathConf::set_patrolinganim(const char* value) {
  set_has_patrolinganim();
  if (patrolinganim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolinganim_ = new ::std::string;
  }
  patrolinganim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PatrolPathConf.PatrolingAnim)
}
inline void PatrolPathConf::set_patrolinganim(const char* value, size_t size) {
  set_has_patrolinganim();
  if (patrolinganim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolinganim_ = new ::std::string;
  }
  patrolinganim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PatrolPathConf.PatrolingAnim)
}
inline ::std::string* PatrolPathConf::mutable_patrolinganim() {
  set_has_patrolinganim();
  if (patrolinganim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrolinganim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PatrolPathConf.PatrolingAnim)
  return patrolinganim_;
}
inline ::std::string* PatrolPathConf::release_patrolinganim() {
  clear_has_patrolinganim();
  if (patrolinganim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = patrolinganim_;
    patrolinganim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PatrolPathConf::set_allocated_patrolinganim(::std::string* patrolinganim) {
  if (patrolinganim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patrolinganim_;
  }
  if (patrolinganim) {
    set_has_patrolinganim();
    patrolinganim_ = patrolinganim;
  } else {
    clear_has_patrolinganim();
    patrolinganim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPathConf.PatrolingAnim)
}

// required string DefaultAnim = 7;
inline bool PatrolPathConf::has_defaultanim() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PatrolPathConf::set_has_defaultanim() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PatrolPathConf::clear_has_defaultanim() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PatrolPathConf::clear_defaultanim() {
  if (defaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_->clear();
  }
  clear_has_defaultanim();
}
inline const ::std::string& PatrolPathConf::defaultanim() const {
  // @@protoc_insertion_point(field_get:pb.PatrolPathConf.DefaultAnim)
  return *defaultanim_;
}
inline void PatrolPathConf::set_defaultanim(const ::std::string& value) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PatrolPathConf.DefaultAnim)
}
inline void PatrolPathConf::set_defaultanim(const char* value) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PatrolPathConf.DefaultAnim)
}
inline void PatrolPathConf::set_defaultanim(const char* value, size_t size) {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  defaultanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PatrolPathConf.DefaultAnim)
}
inline ::std::string* PatrolPathConf::mutable_defaultanim() {
  set_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PatrolPathConf.DefaultAnim)
  return defaultanim_;
}
inline ::std::string* PatrolPathConf::release_defaultanim() {
  clear_has_defaultanim();
  if (defaultanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = defaultanim_;
    defaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PatrolPathConf::set_allocated_defaultanim(::std::string* defaultanim) {
  if (defaultanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete defaultanim_;
  }
  if (defaultanim) {
    set_has_defaultanim();
    defaultanim_ = defaultanim;
  } else {
    clear_has_defaultanim();
    defaultanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PatrolPathConf.DefaultAnim)
}

// -------------------------------------------------------------------

// CarrierEnt2

// optional string Name = 1;
inline bool CarrierEnt2::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CarrierEnt2::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CarrierEnt2::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CarrierEnt2::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CarrierEnt2::name() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.Name)
  return *name_;
}
inline void CarrierEnt2::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.Name)
}
inline void CarrierEnt2::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CarrierEnt2.Name)
}
inline void CarrierEnt2::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CarrierEnt2.Name)
}
inline ::std::string* CarrierEnt2::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.Name)
  return name_;
}
inline ::std::string* CarrierEnt2::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CarrierEnt2::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.Name)
}

// optional bool Visible = 2;
inline bool CarrierEnt2::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CarrierEnt2::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CarrierEnt2::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CarrierEnt2::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CarrierEnt2::visible() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.Visible)
  return visible_;
}
inline void CarrierEnt2::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.Visible)
}

// optional .pb.PbVector2 EnterPosition = 3;
inline bool CarrierEnt2::has_enterposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CarrierEnt2::set_has_enterposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CarrierEnt2::clear_has_enterposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CarrierEnt2::clear_enterposition() {
  if (enterposition_ != NULL) enterposition_->::pb::PbVector2::Clear();
  clear_has_enterposition();
}
inline const ::pb::PbVector2& CarrierEnt2::enterposition() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.EnterPosition)
  return enterposition_ != NULL ? *enterposition_ : *default_instance_->enterposition_;
}
inline ::pb::PbVector2* CarrierEnt2::mutable_enterposition() {
  set_has_enterposition();
  if (enterposition_ == NULL) enterposition_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.EnterPosition)
  return enterposition_;
}
inline ::pb::PbVector2* CarrierEnt2::release_enterposition() {
  clear_has_enterposition();
  ::pb::PbVector2* temp = enterposition_;
  enterposition_ = NULL;
  return temp;
}
inline void CarrierEnt2::set_allocated_enterposition(::pb::PbVector2* enterposition) {
  delete enterposition_;
  enterposition_ = enterposition;
  if (enterposition) {
    set_has_enterposition();
  } else {
    clear_has_enterposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.EnterPosition)
}

// optional .pb.PbVector2 ExistPosition = 4;
inline bool CarrierEnt2::has_existposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CarrierEnt2::set_has_existposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CarrierEnt2::clear_has_existposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CarrierEnt2::clear_existposition() {
  if (existposition_ != NULL) existposition_->::pb::PbVector2::Clear();
  clear_has_existposition();
}
inline const ::pb::PbVector2& CarrierEnt2::existposition() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.ExistPosition)
  return existposition_ != NULL ? *existposition_ : *default_instance_->existposition_;
}
inline ::pb::PbVector2* CarrierEnt2::mutable_existposition() {
  set_has_existposition();
  if (existposition_ == NULL) existposition_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.ExistPosition)
  return existposition_;
}
inline ::pb::PbVector2* CarrierEnt2::release_existposition() {
  clear_has_existposition();
  ::pb::PbVector2* temp = existposition_;
  existposition_ = NULL;
  return temp;
}
inline void CarrierEnt2::set_allocated_existposition(::pb::PbVector2* existposition) {
  delete existposition_;
  existposition_ = existposition;
  if (existposition) {
    set_has_existposition();
  } else {
    clear_has_existposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.ExistPosition)
}

// optional .pb.PbVector2 SceneUIPosition = 5;
inline bool CarrierEnt2::has_sceneuiposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CarrierEnt2::set_has_sceneuiposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CarrierEnt2::clear_has_sceneuiposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CarrierEnt2::clear_sceneuiposition() {
  if (sceneuiposition_ != NULL) sceneuiposition_->::pb::PbVector2::Clear();
  clear_has_sceneuiposition();
}
inline const ::pb::PbVector2& CarrierEnt2::sceneuiposition() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.SceneUIPosition)
  return sceneuiposition_ != NULL ? *sceneuiposition_ : *default_instance_->sceneuiposition_;
}
inline ::pb::PbVector2* CarrierEnt2::mutable_sceneuiposition() {
  set_has_sceneuiposition();
  if (sceneuiposition_ == NULL) sceneuiposition_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.SceneUIPosition)
  return sceneuiposition_;
}
inline ::pb::PbVector2* CarrierEnt2::release_sceneuiposition() {
  clear_has_sceneuiposition();
  ::pb::PbVector2* temp = sceneuiposition_;
  sceneuiposition_ = NULL;
  return temp;
}
inline void CarrierEnt2::set_allocated_sceneuiposition(::pb::PbVector2* sceneuiposition) {
  delete sceneuiposition_;
  sceneuiposition_ = sceneuiposition;
  if (sceneuiposition) {
    set_has_sceneuiposition();
  } else {
    clear_has_sceneuiposition();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.SceneUIPosition)
}

// optional string AssetPath = 6;
inline bool CarrierEnt2::has_assetpath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CarrierEnt2::set_has_assetpath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CarrierEnt2::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CarrierEnt2::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& CarrierEnt2::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.AssetPath)
  return *assetpath_;
}
inline void CarrierEnt2::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.AssetPath)
}
inline void CarrierEnt2::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CarrierEnt2.AssetPath)
}
inline void CarrierEnt2::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CarrierEnt2.AssetPath)
}
inline ::std::string* CarrierEnt2::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.AssetPath)
  return assetpath_;
}
inline ::std::string* CarrierEnt2::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CarrierEnt2::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.AssetPath)
}

// optional float FadeInTime = 7;
inline bool CarrierEnt2::has_fadeintime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CarrierEnt2::set_has_fadeintime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CarrierEnt2::clear_has_fadeintime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CarrierEnt2::clear_fadeintime() {
  fadeintime_ = 0;
  clear_has_fadeintime();
}
inline float CarrierEnt2::fadeintime() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.FadeInTime)
  return fadeintime_;
}
inline void CarrierEnt2::set_fadeintime(float value) {
  set_has_fadeintime();
  fadeintime_ = value;
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.FadeInTime)
}

// optional string SceneUIAssetPath = 8;
inline bool CarrierEnt2::has_sceneuiassetpath() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CarrierEnt2::set_has_sceneuiassetpath() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CarrierEnt2::clear_has_sceneuiassetpath() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CarrierEnt2::clear_sceneuiassetpath() {
  if (sceneuiassetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneuiassetpath_->clear();
  }
  clear_has_sceneuiassetpath();
}
inline const ::std::string& CarrierEnt2::sceneuiassetpath() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.SceneUIAssetPath)
  return *sceneuiassetpath_;
}
inline void CarrierEnt2::set_sceneuiassetpath(const ::std::string& value) {
  set_has_sceneuiassetpath();
  if (sceneuiassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneuiassetpath_ = new ::std::string;
  }
  sceneuiassetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.SceneUIAssetPath)
}
inline void CarrierEnt2::set_sceneuiassetpath(const char* value) {
  set_has_sceneuiassetpath();
  if (sceneuiassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneuiassetpath_ = new ::std::string;
  }
  sceneuiassetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CarrierEnt2.SceneUIAssetPath)
}
inline void CarrierEnt2::set_sceneuiassetpath(const char* value, size_t size) {
  set_has_sceneuiassetpath();
  if (sceneuiassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneuiassetpath_ = new ::std::string;
  }
  sceneuiassetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CarrierEnt2.SceneUIAssetPath)
}
inline ::std::string* CarrierEnt2::mutable_sceneuiassetpath() {
  set_has_sceneuiassetpath();
  if (sceneuiassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneuiassetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.SceneUIAssetPath)
  return sceneuiassetpath_;
}
inline ::std::string* CarrierEnt2::release_sceneuiassetpath() {
  clear_has_sceneuiassetpath();
  if (sceneuiassetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sceneuiassetpath_;
    sceneuiassetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CarrierEnt2::set_allocated_sceneuiassetpath(::std::string* sceneuiassetpath) {
  if (sceneuiassetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sceneuiassetpath_;
  }
  if (sceneuiassetpath) {
    set_has_sceneuiassetpath();
    sceneuiassetpath_ = sceneuiassetpath;
  } else {
    clear_has_sceneuiassetpath();
    sceneuiassetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.SceneUIAssetPath)
}

// optional string WalkAreaName = 9;
inline bool CarrierEnt2::has_walkareaname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CarrierEnt2::set_has_walkareaname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CarrierEnt2::clear_has_walkareaname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CarrierEnt2::clear_walkareaname() {
  if (walkareaname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    walkareaname_->clear();
  }
  clear_has_walkareaname();
}
inline const ::std::string& CarrierEnt2::walkareaname() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.WalkAreaName)
  return *walkareaname_;
}
inline void CarrierEnt2::set_walkareaname(const ::std::string& value) {
  set_has_walkareaname();
  if (walkareaname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    walkareaname_ = new ::std::string;
  }
  walkareaname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.WalkAreaName)
}
inline void CarrierEnt2::set_walkareaname(const char* value) {
  set_has_walkareaname();
  if (walkareaname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    walkareaname_ = new ::std::string;
  }
  walkareaname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CarrierEnt2.WalkAreaName)
}
inline void CarrierEnt2::set_walkareaname(const char* value, size_t size) {
  set_has_walkareaname();
  if (walkareaname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    walkareaname_ = new ::std::string;
  }
  walkareaname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CarrierEnt2.WalkAreaName)
}
inline ::std::string* CarrierEnt2::mutable_walkareaname() {
  set_has_walkareaname();
  if (walkareaname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    walkareaname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CarrierEnt2.WalkAreaName)
  return walkareaname_;
}
inline ::std::string* CarrierEnt2::release_walkareaname() {
  clear_has_walkareaname();
  if (walkareaname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = walkareaname_;
    walkareaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CarrierEnt2::set_allocated_walkareaname(::std::string* walkareaname) {
  if (walkareaname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete walkareaname_;
  }
  if (walkareaname) {
    set_has_walkareaname();
    walkareaname_ = walkareaname;
  } else {
    clear_has_walkareaname();
    walkareaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CarrierEnt2.WalkAreaName)
}

// optional float CarrierSpeed = 10;
inline bool CarrierEnt2::has_carrierspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CarrierEnt2::set_has_carrierspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CarrierEnt2::clear_has_carrierspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CarrierEnt2::clear_carrierspeed() {
  carrierspeed_ = 0;
  clear_has_carrierspeed();
}
inline float CarrierEnt2::carrierspeed() const {
  // @@protoc_insertion_point(field_get:pb.CarrierEnt2.CarrierSpeed)
  return carrierspeed_;
}
inline void CarrierEnt2::set_carrierspeed(float value) {
  set_has_carrierspeed();
  carrierspeed_ = value;
  // @@protoc_insertion_point(field_set:pb.CarrierEnt2.CarrierSpeed)
}

// -------------------------------------------------------------------

// FeatureEntrance

// optional bool Interactable = 1;
inline bool FeatureEntrance::has_interactable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureEntrance::set_has_interactable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureEntrance::clear_has_interactable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureEntrance::clear_interactable() {
  interactable_ = false;
  clear_has_interactable();
}
inline bool FeatureEntrance::interactable() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.Interactable)
  return interactable_;
}
inline void FeatureEntrance::set_interactable(bool value) {
  set_has_interactable();
  interactable_ = value;
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.Interactable)
}

// optional int32 FeatureEntranceId = 2;
inline bool FeatureEntrance::has_featureentranceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureEntrance::set_has_featureentranceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureEntrance::clear_has_featureentranceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureEntrance::clear_featureentranceid() {
  featureentranceid_ = 0;
  clear_has_featureentranceid();
}
inline ::google::protobuf::int32 FeatureEntrance::featureentranceid() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.FeatureEntranceId)
  return featureentranceid_;
}
inline void FeatureEntrance::set_featureentranceid(::google::protobuf::int32 value) {
  set_has_featureentranceid();
  featureentranceid_ = value;
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.FeatureEntranceId)
}

// optional .pb.PbVector2 Position = 3;
inline bool FeatureEntrance::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureEntrance::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureEntrance::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureEntrance::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector2::Clear();
  clear_has_position();
}
inline const ::pb::PbVector2& FeatureEntrance::position() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector2* FeatureEntrance::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.Position)
  return position_;
}
inline ::pb::PbVector2* FeatureEntrance::release_position() {
  clear_has_position();
  ::pb::PbVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void FeatureEntrance::set_allocated_position(::pb::PbVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.Position)
}

// optional int32 EventFuncId = 4;
inline bool FeatureEntrance::has_eventfuncid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeatureEntrance::set_has_eventfuncid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeatureEntrance::clear_has_eventfuncid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeatureEntrance::clear_eventfuncid() {
  eventfuncid_ = 0;
  clear_has_eventfuncid();
}
inline ::google::protobuf::int32 FeatureEntrance::eventfuncid() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.EventFuncId)
  return eventfuncid_;
}
inline void FeatureEntrance::set_eventfuncid(::google::protobuf::int32 value) {
  set_has_eventfuncid();
  eventfuncid_ = value;
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.EventFuncId)
}

// optional string Params = 5;
inline bool FeatureEntrance::has_params() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureEntrance::set_has_params() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureEntrance::clear_has_params() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeatureEntrance::clear_params() {
  if (params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_->clear();
  }
  clear_has_params();
}
inline const ::std::string& FeatureEntrance::params() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.Params)
  return *params_;
}
inline void FeatureEntrance::set_params(const ::std::string& value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  params_->assign(value);
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.Params)
}
inline void FeatureEntrance::set_params(const char* value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  params_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.FeatureEntrance.Params)
}
inline void FeatureEntrance::set_params(const char* value, size_t size) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  params_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.FeatureEntrance.Params)
}
inline ::std::string* FeatureEntrance::mutable_params() {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.Params)
  return params_;
}
inline ::std::string* FeatureEntrance::release_params() {
  clear_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = params_;
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FeatureEntrance::set_allocated_params(::std::string* params) {
  if (params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete params_;
  }
  if (params) {
    set_has_params();
    params_ = params;
  } else {
    clear_has_params();
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.Params)
}

// optional .pb.PbVector2 Scale = 6;
inline bool FeatureEntrance::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeatureEntrance::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeatureEntrance::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeatureEntrance::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector2::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector2& FeatureEntrance::scale() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector2* FeatureEntrance::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.Scale)
  return scale_;
}
inline ::pb::PbVector2* FeatureEntrance::release_scale() {
  clear_has_scale();
  ::pb::PbVector2* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void FeatureEntrance::set_allocated_scale(::pb::PbVector2* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.Scale)
}

// optional string SortedLayer = 7;
inline bool FeatureEntrance::has_sortedlayer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeatureEntrance::set_has_sortedlayer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeatureEntrance::clear_has_sortedlayer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FeatureEntrance::clear_sortedlayer() {
  if (sortedlayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortedlayer_->clear();
  }
  clear_has_sortedlayer();
}
inline const ::std::string& FeatureEntrance::sortedlayer() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.SortedLayer)
  return *sortedlayer_;
}
inline void FeatureEntrance::set_sortedlayer(const ::std::string& value) {
  set_has_sortedlayer();
  if (sortedlayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortedlayer_ = new ::std::string;
  }
  sortedlayer_->assign(value);
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.SortedLayer)
}
inline void FeatureEntrance::set_sortedlayer(const char* value) {
  set_has_sortedlayer();
  if (sortedlayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortedlayer_ = new ::std::string;
  }
  sortedlayer_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.FeatureEntrance.SortedLayer)
}
inline void FeatureEntrance::set_sortedlayer(const char* value, size_t size) {
  set_has_sortedlayer();
  if (sortedlayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortedlayer_ = new ::std::string;
  }
  sortedlayer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.FeatureEntrance.SortedLayer)
}
inline ::std::string* FeatureEntrance::mutable_sortedlayer() {
  set_has_sortedlayer();
  if (sortedlayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sortedlayer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.SortedLayer)
  return sortedlayer_;
}
inline ::std::string* FeatureEntrance::release_sortedlayer() {
  clear_has_sortedlayer();
  if (sortedlayer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sortedlayer_;
    sortedlayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FeatureEntrance::set_allocated_sortedlayer(::std::string* sortedlayer) {
  if (sortedlayer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sortedlayer_;
  }
  if (sortedlayer) {
    set_has_sortedlayer();
    sortedlayer_ = sortedlayer;
  } else {
    clear_has_sortedlayer();
    sortedlayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.SortedLayer)
}

// optional uint32 OrderInLayer = 8;
inline bool FeatureEntrance::has_orderinlayer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FeatureEntrance::set_has_orderinlayer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FeatureEntrance::clear_has_orderinlayer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FeatureEntrance::clear_orderinlayer() {
  orderinlayer_ = 0u;
  clear_has_orderinlayer();
}
inline ::google::protobuf::uint32 FeatureEntrance::orderinlayer() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.OrderInLayer)
  return orderinlayer_;
}
inline void FeatureEntrance::set_orderinlayer(::google::protobuf::uint32 value) {
  set_has_orderinlayer();
  orderinlayer_ = value;
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.OrderInLayer)
}

// repeated .pb.AttachPoint2 AttachPointArr = 9;
inline int FeatureEntrance::attachpointarr_size() const {
  return attachpointarr_.size();
}
inline void FeatureEntrance::clear_attachpointarr() {
  attachpointarr_.Clear();
}
inline const ::pb::AttachPoint2& FeatureEntrance::attachpointarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.AttachPointArr)
  return attachpointarr_.Get(index);
}
inline ::pb::AttachPoint2* FeatureEntrance::mutable_attachpointarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.AttachPointArr)
  return attachpointarr_.Mutable(index);
}
inline ::pb::AttachPoint2* FeatureEntrance::add_attachpointarr() {
  // @@protoc_insertion_point(field_add:pb.FeatureEntrance.AttachPointArr)
  return attachpointarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >&
FeatureEntrance::attachpointarr() const {
  // @@protoc_insertion_point(field_list:pb.FeatureEntrance.AttachPointArr)
  return attachpointarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AttachPoint2 >*
FeatureEntrance::mutable_attachpointarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.FeatureEntrance.AttachPointArr)
  return &attachpointarr_;
}

// optional string AssetPath = 10;
inline bool FeatureEntrance::has_assetpath() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FeatureEntrance::set_has_assetpath() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FeatureEntrance::clear_has_assetpath() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FeatureEntrance::clear_assetpath() {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_->clear();
  }
  clear_has_assetpath();
}
inline const ::std::string& FeatureEntrance::assetpath() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.AssetPath)
  return *assetpath_;
}
inline void FeatureEntrance::set_assetpath(const ::std::string& value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.AssetPath)
}
inline void FeatureEntrance::set_assetpath(const char* value) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.FeatureEntrance.AssetPath)
}
inline void FeatureEntrance::set_assetpath(const char* value, size_t size) {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  assetpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.FeatureEntrance.AssetPath)
}
inline ::std::string* FeatureEntrance::mutable_assetpath() {
  set_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assetpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.AssetPath)
  return assetpath_;
}
inline ::std::string* FeatureEntrance::release_assetpath() {
  clear_has_assetpath();
  if (assetpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assetpath_;
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FeatureEntrance::set_allocated_assetpath(::std::string* assetpath) {
  if (assetpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assetpath_;
  }
  if (assetpath) {
    set_has_assetpath();
    assetpath_ = assetpath;
  } else {
    clear_has_assetpath();
    assetpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.AssetPath)
}

// optional uint32 SwitchConfId = 11;
inline bool FeatureEntrance::has_switchconfid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FeatureEntrance::set_has_switchconfid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FeatureEntrance::clear_has_switchconfid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FeatureEntrance::clear_switchconfid() {
  switchconfid_ = 0u;
  clear_has_switchconfid();
}
inline ::google::protobuf::uint32 FeatureEntrance::switchconfid() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.SwitchConfId)
  return switchconfid_;
}
inline void FeatureEntrance::set_switchconfid(::google::protobuf::uint32 value) {
  set_has_switchconfid();
  switchconfid_ = value;
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.SwitchConfId)
}

// optional float PressScale = 12;
inline bool FeatureEntrance::has_pressscale() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FeatureEntrance::set_has_pressscale() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FeatureEntrance::clear_has_pressscale() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FeatureEntrance::clear_pressscale() {
  pressscale_ = 0;
  clear_has_pressscale();
}
inline float FeatureEntrance::pressscale() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.PressScale)
  return pressscale_;
}
inline void FeatureEntrance::set_pressscale(float value) {
  set_has_pressscale();
  pressscale_ = value;
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.PressScale)
}

// optional .pb.PbVector2 Fake3dOffset = 13;
inline bool FeatureEntrance::has_fake3doffset() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FeatureEntrance::set_has_fake3doffset() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FeatureEntrance::clear_has_fake3doffset() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FeatureEntrance::clear_fake3doffset() {
  if (fake3doffset_ != NULL) fake3doffset_->::pb::PbVector2::Clear();
  clear_has_fake3doffset();
}
inline const ::pb::PbVector2& FeatureEntrance::fake3doffset() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.Fake3dOffset)
  return fake3doffset_ != NULL ? *fake3doffset_ : *default_instance_->fake3doffset_;
}
inline ::pb::PbVector2* FeatureEntrance::mutable_fake3doffset() {
  set_has_fake3doffset();
  if (fake3doffset_ == NULL) fake3doffset_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.Fake3dOffset)
  return fake3doffset_;
}
inline ::pb::PbVector2* FeatureEntrance::release_fake3doffset() {
  clear_has_fake3doffset();
  ::pb::PbVector2* temp = fake3doffset_;
  fake3doffset_ = NULL;
  return temp;
}
inline void FeatureEntrance::set_allocated_fake3doffset(::pb::PbVector2* fake3doffset) {
  delete fake3doffset_;
  fake3doffset_ = fake3doffset;
  if (fake3doffset) {
    set_has_fake3doffset();
  } else {
    clear_has_fake3doffset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.Fake3dOffset)
}

// optional string EntranceName = 14;
inline bool FeatureEntrance::has_entrancename() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FeatureEntrance::set_has_entrancename() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FeatureEntrance::clear_has_entrancename() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FeatureEntrance::clear_entrancename() {
  if (entrancename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entrancename_->clear();
  }
  clear_has_entrancename();
}
inline const ::std::string& FeatureEntrance::entrancename() const {
  // @@protoc_insertion_point(field_get:pb.FeatureEntrance.EntranceName)
  return *entrancename_;
}
inline void FeatureEntrance::set_entrancename(const ::std::string& value) {
  set_has_entrancename();
  if (entrancename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entrancename_ = new ::std::string;
  }
  entrancename_->assign(value);
  // @@protoc_insertion_point(field_set:pb.FeatureEntrance.EntranceName)
}
inline void FeatureEntrance::set_entrancename(const char* value) {
  set_has_entrancename();
  if (entrancename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entrancename_ = new ::std::string;
  }
  entrancename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.FeatureEntrance.EntranceName)
}
inline void FeatureEntrance::set_entrancename(const char* value, size_t size) {
  set_has_entrancename();
  if (entrancename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entrancename_ = new ::std::string;
  }
  entrancename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.FeatureEntrance.EntranceName)
}
inline ::std::string* FeatureEntrance::mutable_entrancename() {
  set_has_entrancename();
  if (entrancename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entrancename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.FeatureEntrance.EntranceName)
  return entrancename_;
}
inline ::std::string* FeatureEntrance::release_entrancename() {
  clear_has_entrancename();
  if (entrancename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = entrancename_;
    entrancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FeatureEntrance::set_allocated_entrancename(::std::string* entrancename) {
  if (entrancename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entrancename_;
  }
  if (entrancename) {
    set_has_entrancename();
    entrancename_ = entrancename;
  } else {
    clear_has_entrancename();
    entrancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.FeatureEntrance.EntranceName)
}

// -------------------------------------------------------------------

// SceneChunkInfo

// required .pb.PbVector2 CoordinateOrigin = 1;
inline bool SceneChunkInfo::has_coordinateorigin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneChunkInfo::set_has_coordinateorigin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneChunkInfo::clear_has_coordinateorigin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneChunkInfo::clear_coordinateorigin() {
  if (coordinateorigin_ != NULL) coordinateorigin_->::pb::PbVector2::Clear();
  clear_has_coordinateorigin();
}
inline const ::pb::PbVector2& SceneChunkInfo::coordinateorigin() const {
  // @@protoc_insertion_point(field_get:pb.SceneChunkInfo.CoordinateOrigin)
  return coordinateorigin_ != NULL ? *coordinateorigin_ : *default_instance_->coordinateorigin_;
}
inline ::pb::PbVector2* SceneChunkInfo::mutable_coordinateorigin() {
  set_has_coordinateorigin();
  if (coordinateorigin_ == NULL) coordinateorigin_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.SceneChunkInfo.CoordinateOrigin)
  return coordinateorigin_;
}
inline ::pb::PbVector2* SceneChunkInfo::release_coordinateorigin() {
  clear_has_coordinateorigin();
  ::pb::PbVector2* temp = coordinateorigin_;
  coordinateorigin_ = NULL;
  return temp;
}
inline void SceneChunkInfo::set_allocated_coordinateorigin(::pb::PbVector2* coordinateorigin) {
  delete coordinateorigin_;
  coordinateorigin_ = coordinateorigin;
  if (coordinateorigin) {
    set_has_coordinateorigin();
  } else {
    clear_has_coordinateorigin();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneChunkInfo.CoordinateOrigin)
}

// required .pb.PbVector2 UnitChunkInfo = 2;
inline bool SceneChunkInfo::has_unitchunkinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneChunkInfo::set_has_unitchunkinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneChunkInfo::clear_has_unitchunkinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneChunkInfo::clear_unitchunkinfo() {
  if (unitchunkinfo_ != NULL) unitchunkinfo_->::pb::PbVector2::Clear();
  clear_has_unitchunkinfo();
}
inline const ::pb::PbVector2& SceneChunkInfo::unitchunkinfo() const {
  // @@protoc_insertion_point(field_get:pb.SceneChunkInfo.UnitChunkInfo)
  return unitchunkinfo_ != NULL ? *unitchunkinfo_ : *default_instance_->unitchunkinfo_;
}
inline ::pb::PbVector2* SceneChunkInfo::mutable_unitchunkinfo() {
  set_has_unitchunkinfo();
  if (unitchunkinfo_ == NULL) unitchunkinfo_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.SceneChunkInfo.UnitChunkInfo)
  return unitchunkinfo_;
}
inline ::pb::PbVector2* SceneChunkInfo::release_unitchunkinfo() {
  clear_has_unitchunkinfo();
  ::pb::PbVector2* temp = unitchunkinfo_;
  unitchunkinfo_ = NULL;
  return temp;
}
inline void SceneChunkInfo::set_allocated_unitchunkinfo(::pb::PbVector2* unitchunkinfo) {
  delete unitchunkinfo_;
  unitchunkinfo_ = unitchunkinfo;
  if (unitchunkinfo) {
    set_has_unitchunkinfo();
  } else {
    clear_has_unitchunkinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneChunkInfo.UnitChunkInfo)
}

// -------------------------------------------------------------------

// Obstacle

// optional string Name = 1;
inline bool Obstacle::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacle::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacle::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacle::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Obstacle::name() const {
  // @@protoc_insertion_point(field_get:pb.Obstacle.Name)
  return *name_;
}
inline void Obstacle::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Obstacle.Name)
}
inline void Obstacle::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Obstacle.Name)
}
inline void Obstacle::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Obstacle.Name)
}
inline ::std::string* Obstacle::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Obstacle.Name)
  return name_;
}
inline ::std::string* Obstacle::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Obstacle::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Obstacle.Name)
}

// optional bool Visible = 2;
inline bool Obstacle::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacle::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacle::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacle::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool Obstacle::visible() const {
  // @@protoc_insertion_point(field_get:pb.Obstacle.Visible)
  return visible_;
}
inline void Obstacle::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:pb.Obstacle.Visible)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fSceneConf2d_2eproto__INCLUDED
