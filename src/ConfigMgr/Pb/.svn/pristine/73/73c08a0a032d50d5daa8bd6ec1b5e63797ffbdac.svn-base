// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/GuideData.proto

#ifndef PROTOBUF_module_2fGuideData_2eproto__INCLUDED
#define PROTOBUF_module_2fGuideData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fGuideData_2eproto();
void protobuf_AssignDesc_module_2fGuideData_2eproto();
void protobuf_ShutdownFile_module_2fGuideData_2eproto();

class RewardInfo;
class GuideData;
class GuideParagraph;
class GuideStepRes;
class ScrollInfo;
class ExtraInfo;
class GuideStep;

enum EGuideStepType {
  NormalLayer = 0,
  NormalScene = 1,
  WaitBehaviorFinish = 2,
  WaitStrongholdBattleBegin = 3,
  WaitStrongholdBattleFinish = 4,
  WaitDialog = 5,
  WaitRageSkillReady = 6,
  InteractiveUI = 7,
  LayerDragFunc = 8,
  DestinyActive = 9,
  WaitBehaviorBegin = 10,
  InteractiveObjTrigger = 11,
  MainCityEntrance = 12,
  WaitNetReq = 13,
  WaitFuncOpen = 14,
  InteractiveObjClick = 15,
  SubLayer = 16,
  RageSkill = 17,
  RageSkillModal = 18
};
bool EGuideStepType_IsValid(int value);
const EGuideStepType EGuideStepType_MIN = NormalLayer;
const EGuideStepType EGuideStepType_MAX = RageSkillModal;
const int EGuideStepType_ARRAYSIZE = EGuideStepType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGuideStepType_descriptor();
inline const ::std::string& EGuideStepType_Name(EGuideStepType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGuideStepType_descriptor(), value);
}
inline bool EGuideStepType_Parse(
    const ::std::string& name, EGuideStepType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGuideStepType>(
    EGuideStepType_descriptor(), name, value);
}
enum EGuideGirlType {
  GuideGirlSmall = 0,
  GuideGirlBig = 1,
  GuideGirlNone = 2
};
bool EGuideGirlType_IsValid(int value);
const EGuideGirlType EGuideGirlType_MIN = GuideGirlSmall;
const EGuideGirlType EGuideGirlType_MAX = GuideGirlNone;
const int EGuideGirlType_ARRAYSIZE = EGuideGirlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGuideGirlType_descriptor();
inline const ::std::string& EGuideGirlType_Name(EGuideGirlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGuideGirlType_descriptor(), value);
}
inline bool EGuideGirlType_Parse(
    const ::std::string& name, EGuideGirlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGuideGirlType>(
    EGuideGirlType_descriptor(), name, value);
}
enum EEffectType {
  Type1 = 0,
  Type2 = 1
};
bool EEffectType_IsValid(int value);
const EEffectType EEffectType_MIN = Type1;
const EEffectType EEffectType_MAX = Type2;
const int EEffectType_ARRAYSIZE = EEffectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEffectType_descriptor();
inline const ::std::string& EEffectType_Name(EEffectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEffectType_descriptor(), value);
}
inline bool EEffectType_Parse(
    const ::std::string& name, EEffectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEffectType>(
    EEffectType_descriptor(), name, value);
}
// ===================================================================

/*FOR2LUA
<Record>
	<name>RewardInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class RewardInfo : public ::google::protobuf::Message {
 public:
  RewardInfo();
  virtual ~RewardInfo();

  RewardInfo(const RewardInfo& from);

  inline RewardInfo& operator=(const RewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardInfo& default_instance();

  void Swap(RewardInfo* other);

  // implements Message ----------------------------------------------

  RewardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RewardInfo& from);
  void MergeFrom(const RewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RewardType = 1;
  inline bool has_rewardtype() const;
  inline void clear_rewardtype();
  static const int kRewardTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>RewardInfo</name>
  	<Function>
  		<name>rewardtype</name>
  		<replaceName>RewardType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rewardtype</name>
  		<replaceName>RewardType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rewardtype</name>
  		<replaceName>RewardType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 rewardtype() const;
  inline void set_rewardtype(::google::protobuf::int32 value);

  // optional int32 RewardNum = 2;
  inline bool has_rewardnum() const;
  inline void clear_rewardnum();
  static const int kRewardNumFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>RewardInfo</name>
  	<Function>
  		<name>rewardnum</name>
  		<replaceName>RewardNum</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rewardnum</name>
  		<replaceName>RewardNum</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rewardnum</name>
  		<replaceName>RewardNum</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 rewardnum() const;
  inline void set_rewardnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.RewardInfo)
 private:
  inline void set_has_rewardtype();
  inline void clear_has_rewardtype();
  inline void set_has_rewardnum();
  inline void clear_has_rewardnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 rewardtype_;
  ::google::protobuf::int32 rewardnum_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static RewardInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>GuideData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class GuideData : public ::google::protobuf::Message {
 public:
  GuideData();
  virtual ~GuideData();

  GuideData(const GuideData& from);

  inline GuideData& operator=(const GuideData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideData& default_instance();

  void Swap(GuideData* other);

  // implements Message ----------------------------------------------

  GuideData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideData& from);
  void MergeFrom(const GuideData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>id</name>
  		<replaceName>id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string LayerPath = 2;
  inline bool has_layerpath() const;
  inline void clear_layerpath();
  static const int kLayerPathFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>layerpath</name>
  		<replaceName>LayerPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_layerpath</name>
  		<replaceName>LayerPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_layerpath</name>
  		<replaceName>LayerPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& layerpath() const;
  inline void set_layerpath(const ::std::string& value);
  inline void set_layerpath(const char* value);
  inline void set_layerpath(const char* value, size_t size);
  inline ::std::string* mutable_layerpath();
  inline ::std::string* release_layerpath();
  inline void set_allocated_layerpath(::std::string* layerpath);

  // optional string SceneName = 3;
  inline bool has_scenename() const;
  inline void clear_scenename();
  static const int kSceneNameFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>scenename</name>
  		<replaceName>SceneName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scenename</name>
  		<replaceName>SceneName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scenename</name>
  		<replaceName>SceneName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& scenename() const;
  inline void set_scenename(const ::std::string& value);
  inline void set_scenename(const char* value);
  inline void set_scenename(const char* value, size_t size);
  inline ::std::string* mutable_scenename();
  inline ::std::string* release_scenename();
  inline void set_allocated_scenename(::std::string* scenename);

  // optional int32 UserLevel = 4;
  inline bool has_userlevel() const;
  inline void clear_userlevel();
  static const int kUserLevelFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>userlevel</name>
  		<replaceName>UserLevel</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_userlevel</name>
  		<replaceName>UserLevel</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_userlevel</name>
  		<replaceName>UserLevel</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 userlevel() const;
  inline void set_userlevel(::google::protobuf::int32 value);

  // optional int32 PreId = 5;
  inline bool has_preid() const;
  inline void clear_preid();
  static const int kPreIdFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>preid</name>
  		<replaceName>PreId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_preid</name>
  		<replaceName>PreId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_preid</name>
  		<replaceName>PreId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 preid() const;
  inline void set_preid(::google::protobuf::int32 value);

  // optional int32 EquipType = 6;
  inline bool has_equiptype() const;
  inline void clear_equiptype();
  static const int kEquipTypeFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>equiptype</name>
  		<replaceName>EquipType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_equiptype</name>
  		<replaceName>EquipType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_equiptype</name>
  		<replaceName>EquipType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 equiptype() const;
  inline void set_equiptype(::google::protobuf::int32 value);

  // optional .pb.RewardInfo RewardInfo = 7;
  inline bool has_rewardinfo() const;
  inline void clear_rewardinfo();
  static const int kRewardInfoFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::RewardInfo& rewardinfo() const;
  inline ::pb::RewardInfo* mutable_rewardinfo();
  inline ::pb::RewardInfo* release_rewardinfo();
  inline void set_allocated_rewardinfo(::pb::RewardInfo* rewardinfo);

  // optional int32 StrongholdId = 8;
  inline bool has_strongholdid() const;
  inline void clear_strongholdid();
  static const int kStrongholdIdFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>strongholdid</name>
  		<replaceName>StrongholdId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_strongholdid</name>
  		<replaceName>StrongholdId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_strongholdid</name>
  		<replaceName>StrongholdId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 strongholdid() const;
  inline void set_strongholdid(::google::protobuf::int32 value);

  // optional bool Skip = 9;
  inline bool has_skip() const;
  inline void clear_skip();
  static const int kSkipFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>skip</name>
  		<replaceName>Skip</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_skip</name>
  		<replaceName>Skip</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_skip</name>
  		<replaceName>Skip</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool skip() const;
  inline void set_skip(bool value);

  // repeated .pb.GuideParagraph ParagraphArr = 10;
  inline int paragrapharr_size() const;
  inline void clear_paragrapharr();
  static const int kParagraphArrFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>paragrapharr</name>
  		<replaceName>ParagraphArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_paragrapharr</name>
  		<replaceName>ParagraphArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_paragrapharr</name>
  		<replaceName>ParagraphArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_paragrapharr</name>
  		<replaceName>ParagraphArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>paragrapharr_size</name>
  		<replaceName>ParagraphArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::GuideParagraph& paragrapharr(int index) const;
  inline ::pb::GuideParagraph* mutable_paragrapharr(int index);
  inline ::pb::GuideParagraph* add_paragrapharr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::GuideParagraph >&
      paragrapharr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::GuideParagraph >*
      mutable_paragrapharr();

  // optional string Desc = 11;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string SceneConfName = 12;
  inline bool has_sceneconfname() const;
  inline void clear_sceneconfname();
  static const int kSceneConfNameFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>sceneconfname</name>
  		<replaceName>SceneConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sceneconfname</name>
  		<replaceName>SceneConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sceneconfname</name>
  		<replaceName>SceneConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sceneconfname() const;
  inline void set_sceneconfname(const ::std::string& value);
  inline void set_sceneconfname(const char* value);
  inline void set_sceneconfname(const char* value, size_t size);
  inline ::std::string* mutable_sceneconfname();
  inline ::std::string* release_sceneconfname();
  inline void set_allocated_sceneconfname(::std::string* sceneconfname);

  // repeated int32 ItemInfo = 13;
  inline int iteminfo_size() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>iteminfo</name>
  		<replaceName>ItemInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_iteminfo</name>
  		<replaceName>ItemInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_iteminfo</name>
  		<replaceName>ItemInfo</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_iteminfo</name>
  		<replaceName>ItemInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>iteminfo_size</name>
  		<replaceName>ItemInfo</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 iteminfo(int index) const;
  inline void set_iteminfo(int index, ::google::protobuf::int32 value);
  inline void add_iteminfo(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      iteminfo() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_iteminfo();

  // optional int32 MutexId = 14;
  inline bool has_mutexid() const;
  inline void clear_mutexid();
  static const int kMutexIdFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>mutexid</name>
  		<replaceName>MutexId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mutexid</name>
  		<replaceName>MutexId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mutexid</name>
  		<replaceName>MutexId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 mutexid() const;
  inline void set_mutexid(::google::protobuf::int32 value);

  // optional int32 UserLevelLimit = 15;
  inline bool has_userlevellimit() const;
  inline void clear_userlevellimit();
  static const int kUserLevelLimitFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>userlevellimit</name>
  		<replaceName>UserLevelLimit</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_userlevellimit</name>
  		<replaceName>UserLevelLimit</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_userlevellimit</name>
  		<replaceName>UserLevelLimit</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 userlevellimit() const;
  inline void set_userlevellimit(::google::protobuf::int32 value);

  // optional int32 DialogId = 16;
  inline bool has_dialogid() const;
  inline void clear_dialogid();
  static const int kDialogIdFieldNumber = 16;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>dialogid</name>
  		<replaceName>DialogId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_dialogid</name>
  		<replaceName>DialogId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_dialogid</name>
  		<replaceName>DialogId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 dialogid() const;
  inline void set_dialogid(::google::protobuf::int32 value);

  // optional int32 RelationId = 17;
  inline bool has_relationid() const;
  inline void clear_relationid();
  static const int kRelationIdFieldNumber = 17;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>relationid</name>
  		<replaceName>RelationId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_relationid</name>
  		<replaceName>RelationId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_relationid</name>
  		<replaceName>RelationId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 relationid() const;
  inline void set_relationid(::google::protobuf::int32 value);

  // optional int32 TriggerStronghold = 18;
  inline bool has_triggerstronghold() const;
  inline void clear_triggerstronghold();
  static const int kTriggerStrongholdFieldNumber = 18;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>triggerstronghold</name>
  		<replaceName>TriggerStronghold</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggerstronghold</name>
  		<replaceName>TriggerStronghold</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggerstronghold</name>
  		<replaceName>TriggerStronghold</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 triggerstronghold() const;
  inline void set_triggerstronghold(::google::protobuf::int32 value);

  // optional int32 TriggerSkillId = 19;
  inline bool has_triggerskillid() const;
  inline void clear_triggerskillid();
  static const int kTriggerSkillIdFieldNumber = 19;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>triggerskillid</name>
  		<replaceName>TriggerSkillId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_triggerskillid</name>
  		<replaceName>TriggerSkillId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggerskillid</name>
  		<replaceName>TriggerSkillId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 triggerskillid() const;
  inline void set_triggerskillid(::google::protobuf::int32 value);

  // optional bool NoForce = 20;
  inline bool has_noforce() const;
  inline void clear_noforce();
  static const int kNoForceFieldNumber = 20;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>noforce</name>
  		<replaceName>NoForce</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_noforce</name>
  		<replaceName>NoForce</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_noforce</name>
  		<replaceName>NoForce</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool noforce() const;
  inline void set_noforce(bool value);

  // optional int32 BeastStrongholdId = 21;
  inline bool has_beaststrongholdid() const;
  inline void clear_beaststrongholdid();
  static const int kBeastStrongholdIdFieldNumber = 21;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>beaststrongholdid</name>
  		<replaceName>BeastStrongholdId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_beaststrongholdid</name>
  		<replaceName>BeastStrongholdId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_beaststrongholdid</name>
  		<replaceName>BeastStrongholdId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 beaststrongholdid() const;
  inline void set_beaststrongholdid(::google::protobuf::int32 value);

  // optional bool TDPlotEnd = 22;
  inline bool has_tdplotend() const;
  inline void clear_tdplotend();
  static const int kTDPlotEndFieldNumber = 22;
  /*FOR2LUA
  <Record>
  	<name>GuideData</name>
  	<Function>
  		<name>tdplotend</name>
  		<replaceName>TDPlotEnd</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_tdplotend</name>
  		<replaceName>TDPlotEnd</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_tdplotend</name>
  		<replaceName>TDPlotEnd</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool tdplotend() const;
  inline void set_tdplotend(bool value);

  // @@protoc_insertion_point(class_scope:pb.GuideData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_layerpath();
  inline void clear_has_layerpath();
  inline void set_has_scenename();
  inline void clear_has_scenename();
  inline void set_has_userlevel();
  inline void clear_has_userlevel();
  inline void set_has_preid();
  inline void clear_has_preid();
  inline void set_has_equiptype();
  inline void clear_has_equiptype();
  inline void set_has_rewardinfo();
  inline void clear_has_rewardinfo();
  inline void set_has_strongholdid();
  inline void clear_has_strongholdid();
  inline void set_has_skip();
  inline void clear_has_skip();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_sceneconfname();
  inline void clear_has_sceneconfname();
  inline void set_has_mutexid();
  inline void clear_has_mutexid();
  inline void set_has_userlevellimit();
  inline void clear_has_userlevellimit();
  inline void set_has_dialogid();
  inline void clear_has_dialogid();
  inline void set_has_relationid();
  inline void clear_has_relationid();
  inline void set_has_triggerstronghold();
  inline void clear_has_triggerstronghold();
  inline void set_has_triggerskillid();
  inline void clear_has_triggerskillid();
  inline void set_has_noforce();
  inline void clear_has_noforce();
  inline void set_has_beaststrongholdid();
  inline void clear_has_beaststrongholdid();
  inline void set_has_tdplotend();
  inline void clear_has_tdplotend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* layerpath_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 userlevel_;
  ::std::string* scenename_;
  ::google::protobuf::int32 preid_;
  ::google::protobuf::int32 equiptype_;
  ::pb::RewardInfo* rewardinfo_;
  ::google::protobuf::RepeatedPtrField< ::pb::GuideParagraph > paragrapharr_;
  ::std::string* desc_;
  ::google::protobuf::int32 strongholdid_;
  ::google::protobuf::int32 mutexid_;
  ::std::string* sceneconfname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > iteminfo_;
  ::google::protobuf::int32 userlevellimit_;
  ::google::protobuf::int32 dialogid_;
  ::google::protobuf::int32 relationid_;
  bool skip_;
  bool noforce_;
  bool tdplotend_;
  ::google::protobuf::int32 triggerstronghold_;
  ::google::protobuf::int32 triggerskillid_;
  ::google::protobuf::int32 beaststrongholdid_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static GuideData* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>GuideParagraph</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class GuideParagraph : public ::google::protobuf::Message {
 public:
  GuideParagraph();
  virtual ~GuideParagraph();

  GuideParagraph(const GuideParagraph& from);

  inline GuideParagraph& operator=(const GuideParagraph& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideParagraph& default_instance();

  void Swap(GuideParagraph* other);

  // implements Message ----------------------------------------------

  GuideParagraph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideParagraph& from);
  void MergeFrom(const GuideParagraph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>GuideParagraph</name>
  	<Function>
  		<name>id</name>
  		<replaceName>id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .pb.GuideStep StepArr = 2;
  inline int steparr_size() const;
  inline void clear_steparr();
  static const int kStepArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>GuideParagraph</name>
  	<Function>
  		<name>steparr</name>
  		<replaceName>StepArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_steparr</name>
  		<replaceName>StepArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_steparr</name>
  		<replaceName>StepArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_steparr</name>
  		<replaceName>StepArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>steparr_size</name>
  		<replaceName>StepArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::GuideStep& steparr(int index) const;
  inline ::pb::GuideStep* mutable_steparr(int index);
  inline ::pb::GuideStep* add_steparr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::GuideStep >&
      steparr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::GuideStep >*
      mutable_steparr();

  // optional bool FinishOnce = 3;
  inline bool has_finishonce() const;
  inline void clear_finishonce();
  static const int kFinishOnceFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>GuideParagraph</name>
  	<Function>
  		<name>finishonce</name>
  		<replaceName>FinishOnce</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_finishonce</name>
  		<replaceName>FinishOnce</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_finishonce</name>
  		<replaceName>FinishOnce</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool finishonce() const;
  inline void set_finishonce(bool value);

  // optional bool RunOnce = 4;
  inline bool has_runonce() const;
  inline void clear_runonce();
  static const int kRunOnceFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>GuideParagraph</name>
  	<Function>
  		<name>runonce</name>
  		<replaceName>RunOnce</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_runonce</name>
  		<replaceName>RunOnce</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_runonce</name>
  		<replaceName>RunOnce</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool runonce() const;
  inline void set_runonce(bool value);

  // optional string Desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>GuideParagraph</name>
  	<Function>
  		<name>desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:pb.GuideParagraph)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_finishonce();
  inline void clear_has_finishonce();
  inline void set_has_runonce();
  inline void clear_has_runonce();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::GuideStep > steparr_;
  ::google::protobuf::int32 id_;
  bool finishonce_;
  bool runonce_;
  ::std::string* desc_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static GuideParagraph* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>GuideStepRes</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class GuideStepRes : public ::google::protobuf::Message {
 public:
  GuideStepRes();
  virtual ~GuideStepRes();

  GuideStepRes(const GuideStepRes& from);

  inline GuideStepRes& operator=(const GuideStepRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideStepRes& default_instance();

  void Swap(GuideStepRes* other);

  // implements Message ----------------------------------------------

  GuideStepRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideStepRes& from);
  void MergeFrom(const GuideStepRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Insert = 1;
  inline bool has_insert() const;
  inline void clear_insert();
  static const int kInsertFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>insert</name>
  		<replaceName>Insert</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_insert</name>
  		<replaceName>Insert</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_insert</name>
  		<replaceName>Insert</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool insert() const;
  inline void set_insert(bool value);

  // optional .pb.PbVector2 GirlPos = 2;
  inline bool has_girlpos() const;
  inline void clear_girlpos();
  static const int kGirlPosFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>girlpos</name>
  		<replaceName>GirlPos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_girlpos</name>
  		<replaceName>GirlPos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_girlpos</name>
  		<replaceName>GirlPos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_girlpos</name>
  		<replaceName>GirlPos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& girlpos() const;
  inline ::pb::PbVector2* mutable_girlpos();
  inline ::pb::PbVector2* release_girlpos();
  inline void set_allocated_girlpos(::pb::PbVector2* girlpos);

  // optional .pb.PbVector2 BoxPos = 3;
  inline bool has_boxpos() const;
  inline void clear_boxpos();
  static const int kBoxPosFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>boxpos</name>
  		<replaceName>BoxPos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_boxpos</name>
  		<replaceName>BoxPos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_boxpos</name>
  		<replaceName>BoxPos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_boxpos</name>
  		<replaceName>BoxPos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2& boxpos() const;
  inline ::pb::PbVector2* mutable_boxpos();
  inline ::pb::PbVector2* release_boxpos();
  inline void set_allocated_boxpos(::pb::PbVector2* boxpos);

  // optional bool GirlFlip = 4;
  inline bool has_girlflip() const;
  inline void clear_girlflip();
  static const int kGirlFlipFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>girlflip</name>
  		<replaceName>GirlFlip</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_girlflip</name>
  		<replaceName>GirlFlip</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_girlflip</name>
  		<replaceName>GirlFlip</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool girlflip() const;
  inline void set_girlflip(bool value);

  // optional bool BoxFlip = 5;
  inline bool has_boxflip() const;
  inline void clear_boxflip();
  static const int kBoxFlipFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>boxflip</name>
  		<replaceName>BoxFlip</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_boxflip</name>
  		<replaceName>BoxFlip</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_boxflip</name>
  		<replaceName>BoxFlip</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool boxflip() const;
  inline void set_boxflip(bool value);

  // optional int32 BoxLocalized = 6;
  inline bool has_boxlocalized() const;
  inline void clear_boxlocalized();
  static const int kBoxLocalizedFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>boxlocalized</name>
  		<replaceName>BoxLocalized</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_boxlocalized</name>
  		<replaceName>BoxLocalized</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_boxlocalized</name>
  		<replaceName>BoxLocalized</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 boxlocalized() const;
  inline void set_boxlocalized(::google::protobuf::int32 value);

  // optional .pb.EGuideGirlType GirlType = 7;
  inline bool has_girltype() const;
  inline void clear_girltype();
  static const int kGirlTypeFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>girltype</name>
  		<replaceName>GirlType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_girltype</name>
  		<replaceName>GirlType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_girltype</name>
  		<replaceName>GirlType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EGuideGirlType girltype() const;
  inline void set_girltype(::pb::EGuideGirlType value);

  // optional .pb.EEffectType EffectType = 8;
  inline bool has_effecttype() const;
  inline void clear_effecttype();
  static const int kEffectTypeFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>GuideStepRes</name>
  	<Function>
  		<name>effecttype</name>
  		<replaceName>EffectType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_effecttype</name>
  		<replaceName>EffectType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effecttype</name>
  		<replaceName>EffectType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EEffectType effecttype() const;
  inline void set_effecttype(::pb::EEffectType value);

  // @@protoc_insertion_point(class_scope:pb.GuideStepRes)
 private:
  inline void set_has_insert();
  inline void clear_has_insert();
  inline void set_has_girlpos();
  inline void clear_has_girlpos();
  inline void set_has_boxpos();
  inline void clear_has_boxpos();
  inline void set_has_girlflip();
  inline void clear_has_girlflip();
  inline void set_has_boxflip();
  inline void clear_has_boxflip();
  inline void set_has_boxlocalized();
  inline void clear_has_boxlocalized();
  inline void set_has_girltype();
  inline void clear_has_girltype();
  inline void set_has_effecttype();
  inline void clear_has_effecttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector2* girlpos_;
  ::pb::PbVector2* boxpos_;
  bool insert_;
  bool girlflip_;
  bool boxflip_;
  ::google::protobuf::int32 boxlocalized_;
  int girltype_;
  int effecttype_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static GuideStepRes* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>ScrollInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class ScrollInfo : public ::google::protobuf::Message {
 public:
  ScrollInfo();
  virtual ~ScrollInfo();

  ScrollInfo(const ScrollInfo& from);

  inline ScrollInfo& operator=(const ScrollInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScrollInfo& default_instance();

  void Swap(ScrollInfo* other);

  // implements Message ----------------------------------------------

  ScrollInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScrollInfo& from);
  void MergeFrom(const ScrollInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ScrollPath = 1;
  inline bool has_scrollpath() const;
  inline void clear_scrollpath();
  static const int kScrollPathFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>ScrollInfo</name>
  	<Function>
  		<name>scrollpath</name>
  		<replaceName>ScrollPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scrollpath</name>
  		<replaceName>ScrollPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scrollpath</name>
  		<replaceName>ScrollPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& scrollpath() const;
  inline void set_scrollpath(const ::std::string& value);
  inline void set_scrollpath(const char* value);
  inline void set_scrollpath(const char* value, size_t size);
  inline ::std::string* mutable_scrollpath();
  inline ::std::string* release_scrollpath();
  inline void set_allocated_scrollpath(::std::string* scrollpath);

  // optional int32 GroupIndex = 2;
  inline bool has_groupindex() const;
  inline void clear_groupindex();
  static const int kGroupIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>ScrollInfo</name>
  	<Function>
  		<name>groupindex</name>
  		<replaceName>GroupIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_groupindex</name>
  		<replaceName>GroupIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_groupindex</name>
  		<replaceName>GroupIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 groupindex() const;
  inline void set_groupindex(::google::protobuf::int32 value);

  // optional int32 ItemIndex = 3;
  inline bool has_itemindex() const;
  inline void clear_itemindex();
  static const int kItemIndexFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>ScrollInfo</name>
  	<Function>
  		<name>itemindex</name>
  		<replaceName>ItemIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_itemindex</name>
  		<replaceName>ItemIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_itemindex</name>
  		<replaceName>ItemIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 itemindex() const;
  inline void set_itemindex(::google::protobuf::int32 value);

  // optional int32 ScrollType = 4;
  inline bool has_scrolltype() const;
  inline void clear_scrolltype();
  static const int kScrollTypeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>ScrollInfo</name>
  	<Function>
  		<name>scrolltype</name>
  		<replaceName>ScrollType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scrolltype</name>
  		<replaceName>ScrollType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scrolltype</name>
  		<replaceName>ScrollType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 scrolltype() const;
  inline void set_scrolltype(::google::protobuf::int32 value);

  // optional int32 NeedScroll = 5;
  inline bool has_needscroll() const;
  inline void clear_needscroll();
  static const int kNeedScrollFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>ScrollInfo</name>
  	<Function>
  		<name>needscroll</name>
  		<replaceName>NeedScroll</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_needscroll</name>
  		<replaceName>NeedScroll</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_needscroll</name>
  		<replaceName>NeedScroll</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 needscroll() const;
  inline void set_needscroll(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.ScrollInfo)
 private:
  inline void set_has_scrollpath();
  inline void clear_has_scrollpath();
  inline void set_has_groupindex();
  inline void clear_has_groupindex();
  inline void set_has_itemindex();
  inline void clear_has_itemindex();
  inline void set_has_scrolltype();
  inline void clear_has_scrolltype();
  inline void set_has_needscroll();
  inline void clear_has_needscroll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* scrollpath_;
  ::google::protobuf::int32 groupindex_;
  ::google::protobuf::int32 itemindex_;
  ::google::protobuf::int32 scrolltype_;
  ::google::protobuf::int32 needscroll_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static ScrollInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>ExtraInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class ExtraInfo : public ::google::protobuf::Message {
 public:
  ExtraInfo();
  virtual ~ExtraInfo();

  ExtraInfo(const ExtraInfo& from);

  inline ExtraInfo& operator=(const ExtraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraInfo& default_instance();

  void Swap(ExtraInfo* other);

  // implements Message ----------------------------------------------

  ExtraInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraInfo& from);
  void MergeFrom(const ExtraInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool LockUITouchMove = 1;
  inline bool has_lockuitouchmove() const;
  inline void clear_lockuitouchmove();
  static const int kLockUITouchMoveFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>lockuitouchmove</name>
  		<replaceName>LockUITouchMove</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_lockuitouchmove</name>
  		<replaceName>LockUITouchMove</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_lockuitouchmove</name>
  		<replaceName>LockUITouchMove</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool lockuitouchmove() const;
  inline void set_lockuitouchmove(bool value);

  // optional bool UseLayerModal = 2;
  inline bool has_uselayermodal() const;
  inline void clear_uselayermodal();
  static const int kUseLayerModalFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>uselayermodal</name>
  		<replaceName>UseLayerModal</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_uselayermodal</name>
  		<replaceName>UseLayerModal</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_uselayermodal</name>
  		<replaceName>UseLayerModal</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool uselayermodal() const;
  inline void set_uselayermodal(bool value);

  // optional bool OnlyMark = 3;
  inline bool has_onlymark() const;
  inline void clear_onlymark();
  static const int kOnlyMarkFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>onlymark</name>
  		<replaceName>OnlyMark</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_onlymark</name>
  		<replaceName>OnlyMark</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_onlymark</name>
  		<replaceName>OnlyMark</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool onlymark() const;
  inline void set_onlymark(bool value);

  // optional bool LookAtBuilding = 4;
  inline bool has_lookatbuilding() const;
  inline void clear_lookatbuilding();
  static const int kLookAtBuildingFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>lookatbuilding</name>
  		<replaceName>LookAtBuilding</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_lookatbuilding</name>
  		<replaceName>LookAtBuilding</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_lookatbuilding</name>
  		<replaceName>LookAtBuilding</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool lookatbuilding() const;
  inline void set_lookatbuilding(bool value);

  // optional int32 MoveSpeed = 6;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMoveSpeedFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>movespeed</name>
  		<replaceName>MoveSpeed</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_movespeed</name>
  		<replaceName>MoveSpeed</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_movespeed</name>
  		<replaceName>MoveSpeed</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 movespeed() const;
  inline void set_movespeed(::google::protobuf::int32 value);

  // optional string ReqFuncName = 7;
  inline bool has_reqfuncname() const;
  inline void clear_reqfuncname();
  static const int kReqFuncNameFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>reqfuncname</name>
  		<replaceName>ReqFuncName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_reqfuncname</name>
  		<replaceName>ReqFuncName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_reqfuncname</name>
  		<replaceName>ReqFuncName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& reqfuncname() const;
  inline void set_reqfuncname(const ::std::string& value);
  inline void set_reqfuncname(const char* value);
  inline void set_reqfuncname(const char* value, size_t size);
  inline ::std::string* mutable_reqfuncname();
  inline ::std::string* release_reqfuncname();
  inline void set_allocated_reqfuncname(::std::string* reqfuncname);

  // optional float LimitTime = 8;
  inline bool has_limittime() const;
  inline void clear_limittime();
  static const int kLimitTimeFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>limittime</name>
  		<replaceName>LimitTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_limittime</name>
  		<replaceName>LimitTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_limittime</name>
  		<replaceName>LimitTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float limittime() const;
  inline void set_limittime(float value);

  // optional string FuncOpenAnim = 9;
  inline bool has_funcopenanim() const;
  inline void clear_funcopenanim();
  static const int kFuncOpenAnimFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>funcopenanim</name>
  		<replaceName>FuncOpenAnim</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_funcopenanim</name>
  		<replaceName>FuncOpenAnim</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_funcopenanim</name>
  		<replaceName>FuncOpenAnim</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& funcopenanim() const;
  inline void set_funcopenanim(const ::std::string& value);
  inline void set_funcopenanim(const char* value);
  inline void set_funcopenanim(const char* value, size_t size);
  inline ::std::string* mutable_funcopenanim();
  inline ::std::string* release_funcopenanim();
  inline void set_allocated_funcopenanim(::std::string* funcopenanim);

  // optional string DragEndWidget = 10;
  inline bool has_dragendwidget() const;
  inline void clear_dragendwidget();
  static const int kDragEndWidgetFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>dragendwidget</name>
  		<replaceName>DragEndWidget</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_dragendwidget</name>
  		<replaceName>DragEndWidget</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_dragendwidget</name>
  		<replaceName>DragEndWidget</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& dragendwidget() const;
  inline void set_dragendwidget(const ::std::string& value);
  inline void set_dragendwidget(const char* value);
  inline void set_dragendwidget(const char* value, size_t size);
  inline ::std::string* mutable_dragendwidget();
  inline ::std::string* release_dragendwidget();
  inline void set_allocated_dragendwidget(::std::string* dragendwidget);

  // optional string MainLayerPath = 11;
  inline bool has_mainlayerpath() const;
  inline void clear_mainlayerpath();
  static const int kMainLayerPathFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>ExtraInfo</name>
  	<Function>
  		<name>mainlayerpath</name>
  		<replaceName>MainLayerPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mainlayerpath</name>
  		<replaceName>MainLayerPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mainlayerpath</name>
  		<replaceName>MainLayerPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& mainlayerpath() const;
  inline void set_mainlayerpath(const ::std::string& value);
  inline void set_mainlayerpath(const char* value);
  inline void set_mainlayerpath(const char* value, size_t size);
  inline ::std::string* mutable_mainlayerpath();
  inline ::std::string* release_mainlayerpath();
  inline void set_allocated_mainlayerpath(::std::string* mainlayerpath);

  // @@protoc_insertion_point(class_scope:pb.ExtraInfo)
 private:
  inline void set_has_lockuitouchmove();
  inline void clear_has_lockuitouchmove();
  inline void set_has_uselayermodal();
  inline void clear_has_uselayermodal();
  inline void set_has_onlymark();
  inline void clear_has_onlymark();
  inline void set_has_lookatbuilding();
  inline void clear_has_lookatbuilding();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_reqfuncname();
  inline void clear_has_reqfuncname();
  inline void set_has_limittime();
  inline void clear_has_limittime();
  inline void set_has_funcopenanim();
  inline void clear_has_funcopenanim();
  inline void set_has_dragendwidget();
  inline void clear_has_dragendwidget();
  inline void set_has_mainlayerpath();
  inline void clear_has_mainlayerpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool lockuitouchmove_;
  bool uselayermodal_;
  bool onlymark_;
  bool lookatbuilding_;
  ::google::protobuf::int32 movespeed_;
  ::std::string* reqfuncname_;
  ::std::string* funcopenanim_;
  ::std::string* dragendwidget_;
  ::std::string* mainlayerpath_;
  float limittime_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static ExtraInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>GuideStep</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/GuideData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class GuideStep : public ::google::protobuf::Message {
 public:
  GuideStep();
  virtual ~GuideStep();

  GuideStep(const GuideStep& from);

  inline GuideStep& operator=(const GuideStep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideStep& default_instance();

  void Swap(GuideStep* other);

  // implements Message ----------------------------------------------

  GuideStep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideStep& from);
  void MergeFrom(const GuideStep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EGuideStepType StepType = 1;
  inline bool has_steptype() const;
  inline void clear_steptype();
  static const int kStepTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>steptype</name>
  		<replaceName>StepType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_steptype</name>
  		<replaceName>StepType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_steptype</name>
  		<replaceName>StepType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EGuideStepType steptype() const;
  inline void set_steptype(::pb::EGuideStepType value);

  // optional string GuideResPath = 2;
  inline bool has_guiderespath() const;
  inline void clear_guiderespath();
  static const int kGuideResPathFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>guiderespath</name>
  		<replaceName>GuideResPath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_guiderespath</name>
  		<replaceName>GuideResPath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_guiderespath</name>
  		<replaceName>GuideResPath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& guiderespath() const;
  inline void set_guiderespath(const ::std::string& value);
  inline void set_guiderespath(const char* value);
  inline void set_guiderespath(const char* value, size_t size);
  inline ::std::string* mutable_guiderespath();
  inline ::std::string* release_guiderespath();
  inline void set_allocated_guiderespath(::std::string* guiderespath);

  // optional string GuideWidget = 3;
  inline bool has_guidewidget() const;
  inline void clear_guidewidget();
  static const int kGuideWidgetFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>guidewidget</name>
  		<replaceName>GuideWidget</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_guidewidget</name>
  		<replaceName>GuideWidget</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_guidewidget</name>
  		<replaceName>GuideWidget</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& guidewidget() const;
  inline void set_guidewidget(const ::std::string& value);
  inline void set_guidewidget(const char* value);
  inline void set_guidewidget(const char* value, size_t size);
  inline ::std::string* mutable_guidewidget();
  inline ::std::string* release_guidewidget();
  inline void set_allocated_guidewidget(::std::string* guidewidget);

  // optional float DelayTime = 4;
  inline bool has_delaytime() const;
  inline void clear_delaytime();
  static const int kDelayTimeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_delaytime</name>
  		<replaceName>DelayTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float delaytime() const;
  inline void set_delaytime(float value);

  // optional .pb.GuideStepRes StepRes = 5;
  inline bool has_stepres() const;
  inline void clear_stepres();
  static const int kStepResFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>stepres</name>
  		<replaceName>StepRes</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_stepres</name>
  		<replaceName>StepRes</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_stepres</name>
  		<replaceName>StepRes</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_stepres</name>
  		<replaceName>StepRes</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::GuideStepRes& stepres() const;
  inline ::pb::GuideStepRes* mutable_stepres();
  inline ::pb::GuideStepRes* release_stepres();
  inline void set_allocated_stepres(::pb::GuideStepRes* stepres);

  // optional int32 ParamInt = 6;
  inline bool has_paramint() const;
  inline void clear_paramint();
  static const int kParamIntFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>paramint</name>
  		<replaceName>ParamInt</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_paramint</name>
  		<replaceName>ParamInt</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_paramint</name>
  		<replaceName>ParamInt</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 paramint() const;
  inline void set_paramint(::google::protobuf::int32 value);

  // optional .pb.ExtraInfo ExtraInfo = 7;
  inline bool has_extrainfo() const;
  inline void clear_extrainfo();
  static const int kExtraInfoFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::ExtraInfo& extrainfo() const;
  inline ::pb::ExtraInfo* mutable_extrainfo();
  inline ::pb::ExtraInfo* release_extrainfo();
  inline void set_allocated_extrainfo(::pb::ExtraInfo* extrainfo);

  // optional string Desc = 8;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string SceneConfName = 9;
  inline bool has_sceneconfname() const;
  inline void clear_sceneconfname();
  static const int kSceneConfNameFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>sceneconfname</name>
  		<replaceName>SceneConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sceneconfname</name>
  		<replaceName>SceneConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sceneconfname</name>
  		<replaceName>SceneConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& sceneconfname() const;
  inline void set_sceneconfname(const ::std::string& value);
  inline void set_sceneconfname(const char* value);
  inline void set_sceneconfname(const char* value, size_t size);
  inline ::std::string* mutable_sceneconfname();
  inline ::std::string* release_sceneconfname();
  inline void set_allocated_sceneconfname(::std::string* sceneconfname);

  // optional .pb.ScrollInfo ScrollInfo = 10;
  inline bool has_scrollinfo() const;
  inline void clear_scrollinfo();
  static const int kScrollInfoFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>GuideStep</name>
  	<Function>
  		<name>scrollinfo</name>
  		<replaceName>ScrollInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scrollinfo</name>
  		<replaceName>ScrollInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scrollinfo</name>
  		<replaceName>ScrollInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scrollinfo</name>
  		<replaceName>ScrollInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::ScrollInfo& scrollinfo() const;
  inline ::pb::ScrollInfo* mutable_scrollinfo();
  inline ::pb::ScrollInfo* release_scrollinfo();
  inline void set_allocated_scrollinfo(::pb::ScrollInfo* scrollinfo);

  // @@protoc_insertion_point(class_scope:pb.GuideStep)
 private:
  inline void set_has_steptype();
  inline void clear_has_steptype();
  inline void set_has_guiderespath();
  inline void clear_has_guiderespath();
  inline void set_has_guidewidget();
  inline void clear_has_guidewidget();
  inline void set_has_delaytime();
  inline void clear_has_delaytime();
  inline void set_has_stepres();
  inline void clear_has_stepres();
  inline void set_has_paramint();
  inline void clear_has_paramint();
  inline void set_has_extrainfo();
  inline void clear_has_extrainfo();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_sceneconfname();
  inline void clear_has_sceneconfname();
  inline void set_has_scrollinfo();
  inline void clear_has_scrollinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* guiderespath_;
  int steptype_;
  float delaytime_;
  ::std::string* guidewidget_;
  ::pb::GuideStepRes* stepres_;
  ::pb::ExtraInfo* extrainfo_;
  ::std::string* desc_;
  ::std::string* sceneconfname_;
  ::pb::ScrollInfo* scrollinfo_;
  ::google::protobuf::int32 paramint_;
  friend void  protobuf_AddDesc_module_2fGuideData_2eproto();
  friend void protobuf_AssignDesc_module_2fGuideData_2eproto();
  friend void protobuf_ShutdownFile_module_2fGuideData_2eproto();

  void InitAsDefaultInstance();
  static GuideStep* default_instance_;
};
// ===================================================================


// ===================================================================

// RewardInfo

// optional int32 RewardType = 1;
inline bool RewardInfo::has_rewardtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardInfo::set_has_rewardtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardInfo::clear_has_rewardtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardInfo::clear_rewardtype() {
  rewardtype_ = 0;
  clear_has_rewardtype();
}
inline ::google::protobuf::int32 RewardInfo::rewardtype() const {
  // @@protoc_insertion_point(field_get:pb.RewardInfo.RewardType)
  return rewardtype_;
}
inline void RewardInfo::set_rewardtype(::google::protobuf::int32 value) {
  set_has_rewardtype();
  rewardtype_ = value;
  // @@protoc_insertion_point(field_set:pb.RewardInfo.RewardType)
}

// optional int32 RewardNum = 2;
inline bool RewardInfo::has_rewardnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardInfo::set_has_rewardnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardInfo::clear_has_rewardnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardInfo::clear_rewardnum() {
  rewardnum_ = 0;
  clear_has_rewardnum();
}
inline ::google::protobuf::int32 RewardInfo::rewardnum() const {
  // @@protoc_insertion_point(field_get:pb.RewardInfo.RewardNum)
  return rewardnum_;
}
inline void RewardInfo::set_rewardnum(::google::protobuf::int32 value) {
  set_has_rewardnum();
  rewardnum_ = value;
  // @@protoc_insertion_point(field_set:pb.RewardInfo.RewardNum)
}

// -------------------------------------------------------------------

// GuideData

// optional int32 id = 1;
inline bool GuideData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GuideData::id() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.id)
  return id_;
}
inline void GuideData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.id)
}

// optional string LayerPath = 2;
inline bool GuideData::has_layerpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideData::set_has_layerpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideData::clear_has_layerpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideData::clear_layerpath() {
  if (layerpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    layerpath_->clear();
  }
  clear_has_layerpath();
}
inline const ::std::string& GuideData::layerpath() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.LayerPath)
  return *layerpath_;
}
inline void GuideData::set_layerpath(const ::std::string& value) {
  set_has_layerpath();
  if (layerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    layerpath_ = new ::std::string;
  }
  layerpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideData.LayerPath)
}
inline void GuideData::set_layerpath(const char* value) {
  set_has_layerpath();
  if (layerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    layerpath_ = new ::std::string;
  }
  layerpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideData.LayerPath)
}
inline void GuideData::set_layerpath(const char* value, size_t size) {
  set_has_layerpath();
  if (layerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    layerpath_ = new ::std::string;
  }
  layerpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideData.LayerPath)
}
inline ::std::string* GuideData::mutable_layerpath() {
  set_has_layerpath();
  if (layerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    layerpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideData.LayerPath)
  return layerpath_;
}
inline ::std::string* GuideData::release_layerpath() {
  clear_has_layerpath();
  if (layerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = layerpath_;
    layerpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideData::set_allocated_layerpath(::std::string* layerpath) {
  if (layerpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete layerpath_;
  }
  if (layerpath) {
    set_has_layerpath();
    layerpath_ = layerpath;
  } else {
    clear_has_layerpath();
    layerpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideData.LayerPath)
}

// optional string SceneName = 3;
inline bool GuideData::has_scenename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideData::set_has_scenename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideData::clear_has_scenename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideData::clear_scenename() {
  if (scenename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scenename_->clear();
  }
  clear_has_scenename();
}
inline const ::std::string& GuideData::scenename() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.SceneName)
  return *scenename_;
}
inline void GuideData::set_scenename(const ::std::string& value) {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scenename_ = new ::std::string;
  }
  scenename_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideData.SceneName)
}
inline void GuideData::set_scenename(const char* value) {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scenename_ = new ::std::string;
  }
  scenename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideData.SceneName)
}
inline void GuideData::set_scenename(const char* value, size_t size) {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scenename_ = new ::std::string;
  }
  scenename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideData.SceneName)
}
inline ::std::string* GuideData::mutable_scenename() {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scenename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideData.SceneName)
  return scenename_;
}
inline ::std::string* GuideData::release_scenename() {
  clear_has_scenename();
  if (scenename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = scenename_;
    scenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideData::set_allocated_scenename(::std::string* scenename) {
  if (scenename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scenename_;
  }
  if (scenename) {
    set_has_scenename();
    scenename_ = scenename;
  } else {
    clear_has_scenename();
    scenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideData.SceneName)
}

// optional int32 UserLevel = 4;
inline bool GuideData::has_userlevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideData::set_has_userlevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideData::clear_has_userlevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideData::clear_userlevel() {
  userlevel_ = 0;
  clear_has_userlevel();
}
inline ::google::protobuf::int32 GuideData::userlevel() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.UserLevel)
  return userlevel_;
}
inline void GuideData::set_userlevel(::google::protobuf::int32 value) {
  set_has_userlevel();
  userlevel_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.UserLevel)
}

// optional int32 PreId = 5;
inline bool GuideData::has_preid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideData::set_has_preid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideData::clear_has_preid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideData::clear_preid() {
  preid_ = 0;
  clear_has_preid();
}
inline ::google::protobuf::int32 GuideData::preid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.PreId)
  return preid_;
}
inline void GuideData::set_preid(::google::protobuf::int32 value) {
  set_has_preid();
  preid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.PreId)
}

// optional int32 EquipType = 6;
inline bool GuideData::has_equiptype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuideData::set_has_equiptype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuideData::clear_has_equiptype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuideData::clear_equiptype() {
  equiptype_ = 0;
  clear_has_equiptype();
}
inline ::google::protobuf::int32 GuideData::equiptype() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.EquipType)
  return equiptype_;
}
inline void GuideData::set_equiptype(::google::protobuf::int32 value) {
  set_has_equiptype();
  equiptype_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.EquipType)
}

// optional .pb.RewardInfo RewardInfo = 7;
inline bool GuideData::has_rewardinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuideData::set_has_rewardinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuideData::clear_has_rewardinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuideData::clear_rewardinfo() {
  if (rewardinfo_ != NULL) rewardinfo_->::pb::RewardInfo::Clear();
  clear_has_rewardinfo();
}
inline const ::pb::RewardInfo& GuideData::rewardinfo() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.RewardInfo)
  return rewardinfo_ != NULL ? *rewardinfo_ : *default_instance_->rewardinfo_;
}
inline ::pb::RewardInfo* GuideData::mutable_rewardinfo() {
  set_has_rewardinfo();
  if (rewardinfo_ == NULL) rewardinfo_ = new ::pb::RewardInfo;
  // @@protoc_insertion_point(field_mutable:pb.GuideData.RewardInfo)
  return rewardinfo_;
}
inline ::pb::RewardInfo* GuideData::release_rewardinfo() {
  clear_has_rewardinfo();
  ::pb::RewardInfo* temp = rewardinfo_;
  rewardinfo_ = NULL;
  return temp;
}
inline void GuideData::set_allocated_rewardinfo(::pb::RewardInfo* rewardinfo) {
  delete rewardinfo_;
  rewardinfo_ = rewardinfo;
  if (rewardinfo) {
    set_has_rewardinfo();
  } else {
    clear_has_rewardinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideData.RewardInfo)
}

// optional int32 StrongholdId = 8;
inline bool GuideData::has_strongholdid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuideData::set_has_strongholdid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuideData::clear_has_strongholdid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuideData::clear_strongholdid() {
  strongholdid_ = 0;
  clear_has_strongholdid();
}
inline ::google::protobuf::int32 GuideData::strongholdid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.StrongholdId)
  return strongholdid_;
}
inline void GuideData::set_strongholdid(::google::protobuf::int32 value) {
  set_has_strongholdid();
  strongholdid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.StrongholdId)
}

// optional bool Skip = 9;
inline bool GuideData::has_skip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuideData::set_has_skip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuideData::clear_has_skip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuideData::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool GuideData::skip() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.Skip)
  return skip_;
}
inline void GuideData::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.Skip)
}

// repeated .pb.GuideParagraph ParagraphArr = 10;
inline int GuideData::paragrapharr_size() const {
  return paragrapharr_.size();
}
inline void GuideData::clear_paragrapharr() {
  paragrapharr_.Clear();
}
inline const ::pb::GuideParagraph& GuideData::paragrapharr(int index) const {
  // @@protoc_insertion_point(field_get:pb.GuideData.ParagraphArr)
  return paragrapharr_.Get(index);
}
inline ::pb::GuideParagraph* GuideData::mutable_paragrapharr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GuideData.ParagraphArr)
  return paragrapharr_.Mutable(index);
}
inline ::pb::GuideParagraph* GuideData::add_paragrapharr() {
  // @@protoc_insertion_point(field_add:pb.GuideData.ParagraphArr)
  return paragrapharr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GuideParagraph >&
GuideData::paragrapharr() const {
  // @@protoc_insertion_point(field_list:pb.GuideData.ParagraphArr)
  return paragrapharr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GuideParagraph >*
GuideData::mutable_paragrapharr() {
  // @@protoc_insertion_point(field_mutable_list:pb.GuideData.ParagraphArr)
  return &paragrapharr_;
}

// optional string Desc = 11;
inline bool GuideData::has_desc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuideData::set_has_desc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuideData::clear_has_desc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuideData::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& GuideData::desc() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.Desc)
  return *desc_;
}
inline void GuideData::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideData.Desc)
}
inline void GuideData::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideData.Desc)
}
inline void GuideData::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideData.Desc)
}
inline ::std::string* GuideData::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideData.Desc)
  return desc_;
}
inline ::std::string* GuideData::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideData::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideData.Desc)
}

// optional string SceneConfName = 12;
inline bool GuideData::has_sceneconfname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GuideData::set_has_sceneconfname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GuideData::clear_has_sceneconfname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GuideData::clear_sceneconfname() {
  if (sceneconfname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_->clear();
  }
  clear_has_sceneconfname();
}
inline const ::std::string& GuideData::sceneconfname() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.SceneConfName)
  return *sceneconfname_;
}
inline void GuideData::set_sceneconfname(const ::std::string& value) {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  sceneconfname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideData.SceneConfName)
}
inline void GuideData::set_sceneconfname(const char* value) {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  sceneconfname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideData.SceneConfName)
}
inline void GuideData::set_sceneconfname(const char* value, size_t size) {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  sceneconfname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideData.SceneConfName)
}
inline ::std::string* GuideData::mutable_sceneconfname() {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideData.SceneConfName)
  return sceneconfname_;
}
inline ::std::string* GuideData::release_sceneconfname() {
  clear_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sceneconfname_;
    sceneconfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideData::set_allocated_sceneconfname(::std::string* sceneconfname) {
  if (sceneconfname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sceneconfname_;
  }
  if (sceneconfname) {
    set_has_sceneconfname();
    sceneconfname_ = sceneconfname;
  } else {
    clear_has_sceneconfname();
    sceneconfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideData.SceneConfName)
}

// repeated int32 ItemInfo = 13;
inline int GuideData::iteminfo_size() const {
  return iteminfo_.size();
}
inline void GuideData::clear_iteminfo() {
  iteminfo_.Clear();
}
inline ::google::protobuf::int32 GuideData::iteminfo(int index) const {
  // @@protoc_insertion_point(field_get:pb.GuideData.ItemInfo)
  return iteminfo_.Get(index);
}
inline void GuideData::set_iteminfo(int index, ::google::protobuf::int32 value) {
  iteminfo_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.GuideData.ItemInfo)
}
inline void GuideData::add_iteminfo(::google::protobuf::int32 value) {
  iteminfo_.Add(value);
  // @@protoc_insertion_point(field_add:pb.GuideData.ItemInfo)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GuideData::iteminfo() const {
  // @@protoc_insertion_point(field_list:pb.GuideData.ItemInfo)
  return iteminfo_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GuideData::mutable_iteminfo() {
  // @@protoc_insertion_point(field_mutable_list:pb.GuideData.ItemInfo)
  return &iteminfo_;
}

// optional int32 MutexId = 14;
inline bool GuideData::has_mutexid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GuideData::set_has_mutexid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GuideData::clear_has_mutexid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GuideData::clear_mutexid() {
  mutexid_ = 0;
  clear_has_mutexid();
}
inline ::google::protobuf::int32 GuideData::mutexid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.MutexId)
  return mutexid_;
}
inline void GuideData::set_mutexid(::google::protobuf::int32 value) {
  set_has_mutexid();
  mutexid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.MutexId)
}

// optional int32 UserLevelLimit = 15;
inline bool GuideData::has_userlevellimit() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GuideData::set_has_userlevellimit() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GuideData::clear_has_userlevellimit() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GuideData::clear_userlevellimit() {
  userlevellimit_ = 0;
  clear_has_userlevellimit();
}
inline ::google::protobuf::int32 GuideData::userlevellimit() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.UserLevelLimit)
  return userlevellimit_;
}
inline void GuideData::set_userlevellimit(::google::protobuf::int32 value) {
  set_has_userlevellimit();
  userlevellimit_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.UserLevelLimit)
}

// optional int32 DialogId = 16;
inline bool GuideData::has_dialogid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GuideData::set_has_dialogid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GuideData::clear_has_dialogid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GuideData::clear_dialogid() {
  dialogid_ = 0;
  clear_has_dialogid();
}
inline ::google::protobuf::int32 GuideData::dialogid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.DialogId)
  return dialogid_;
}
inline void GuideData::set_dialogid(::google::protobuf::int32 value) {
  set_has_dialogid();
  dialogid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.DialogId)
}

// optional int32 RelationId = 17;
inline bool GuideData::has_relationid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GuideData::set_has_relationid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GuideData::clear_has_relationid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GuideData::clear_relationid() {
  relationid_ = 0;
  clear_has_relationid();
}
inline ::google::protobuf::int32 GuideData::relationid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.RelationId)
  return relationid_;
}
inline void GuideData::set_relationid(::google::protobuf::int32 value) {
  set_has_relationid();
  relationid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.RelationId)
}

// optional int32 TriggerStronghold = 18;
inline bool GuideData::has_triggerstronghold() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GuideData::set_has_triggerstronghold() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GuideData::clear_has_triggerstronghold() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GuideData::clear_triggerstronghold() {
  triggerstronghold_ = 0;
  clear_has_triggerstronghold();
}
inline ::google::protobuf::int32 GuideData::triggerstronghold() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.TriggerStronghold)
  return triggerstronghold_;
}
inline void GuideData::set_triggerstronghold(::google::protobuf::int32 value) {
  set_has_triggerstronghold();
  triggerstronghold_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.TriggerStronghold)
}

// optional int32 TriggerSkillId = 19;
inline bool GuideData::has_triggerskillid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GuideData::set_has_triggerskillid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GuideData::clear_has_triggerskillid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GuideData::clear_triggerskillid() {
  triggerskillid_ = 0;
  clear_has_triggerskillid();
}
inline ::google::protobuf::int32 GuideData::triggerskillid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.TriggerSkillId)
  return triggerskillid_;
}
inline void GuideData::set_triggerskillid(::google::protobuf::int32 value) {
  set_has_triggerskillid();
  triggerskillid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.TriggerSkillId)
}

// optional bool NoForce = 20;
inline bool GuideData::has_noforce() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GuideData::set_has_noforce() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GuideData::clear_has_noforce() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GuideData::clear_noforce() {
  noforce_ = false;
  clear_has_noforce();
}
inline bool GuideData::noforce() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.NoForce)
  return noforce_;
}
inline void GuideData::set_noforce(bool value) {
  set_has_noforce();
  noforce_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.NoForce)
}

// optional int32 BeastStrongholdId = 21;
inline bool GuideData::has_beaststrongholdid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GuideData::set_has_beaststrongholdid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GuideData::clear_has_beaststrongholdid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GuideData::clear_beaststrongholdid() {
  beaststrongholdid_ = 0;
  clear_has_beaststrongholdid();
}
inline ::google::protobuf::int32 GuideData::beaststrongholdid() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.BeastStrongholdId)
  return beaststrongholdid_;
}
inline void GuideData::set_beaststrongholdid(::google::protobuf::int32 value) {
  set_has_beaststrongholdid();
  beaststrongholdid_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.BeastStrongholdId)
}

// optional bool TDPlotEnd = 22;
inline bool GuideData::has_tdplotend() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GuideData::set_has_tdplotend() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GuideData::clear_has_tdplotend() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GuideData::clear_tdplotend() {
  tdplotend_ = false;
  clear_has_tdplotend();
}
inline bool GuideData::tdplotend() const {
  // @@protoc_insertion_point(field_get:pb.GuideData.TDPlotEnd)
  return tdplotend_;
}
inline void GuideData::set_tdplotend(bool value) {
  set_has_tdplotend();
  tdplotend_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideData.TDPlotEnd)
}

// -------------------------------------------------------------------

// GuideParagraph

// optional int32 id = 1;
inline bool GuideParagraph::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideParagraph::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideParagraph::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideParagraph::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GuideParagraph::id() const {
  // @@protoc_insertion_point(field_get:pb.GuideParagraph.id)
  return id_;
}
inline void GuideParagraph::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideParagraph.id)
}

// repeated .pb.GuideStep StepArr = 2;
inline int GuideParagraph::steparr_size() const {
  return steparr_.size();
}
inline void GuideParagraph::clear_steparr() {
  steparr_.Clear();
}
inline const ::pb::GuideStep& GuideParagraph::steparr(int index) const {
  // @@protoc_insertion_point(field_get:pb.GuideParagraph.StepArr)
  return steparr_.Get(index);
}
inline ::pb::GuideStep* GuideParagraph::mutable_steparr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GuideParagraph.StepArr)
  return steparr_.Mutable(index);
}
inline ::pb::GuideStep* GuideParagraph::add_steparr() {
  // @@protoc_insertion_point(field_add:pb.GuideParagraph.StepArr)
  return steparr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GuideStep >&
GuideParagraph::steparr() const {
  // @@protoc_insertion_point(field_list:pb.GuideParagraph.StepArr)
  return steparr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GuideStep >*
GuideParagraph::mutable_steparr() {
  // @@protoc_insertion_point(field_mutable_list:pb.GuideParagraph.StepArr)
  return &steparr_;
}

// optional bool FinishOnce = 3;
inline bool GuideParagraph::has_finishonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideParagraph::set_has_finishonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideParagraph::clear_has_finishonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideParagraph::clear_finishonce() {
  finishonce_ = false;
  clear_has_finishonce();
}
inline bool GuideParagraph::finishonce() const {
  // @@protoc_insertion_point(field_get:pb.GuideParagraph.FinishOnce)
  return finishonce_;
}
inline void GuideParagraph::set_finishonce(bool value) {
  set_has_finishonce();
  finishonce_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideParagraph.FinishOnce)
}

// optional bool RunOnce = 4;
inline bool GuideParagraph::has_runonce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideParagraph::set_has_runonce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideParagraph::clear_has_runonce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideParagraph::clear_runonce() {
  runonce_ = false;
  clear_has_runonce();
}
inline bool GuideParagraph::runonce() const {
  // @@protoc_insertion_point(field_get:pb.GuideParagraph.RunOnce)
  return runonce_;
}
inline void GuideParagraph::set_runonce(bool value) {
  set_has_runonce();
  runonce_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideParagraph.RunOnce)
}

// optional string Desc = 5;
inline bool GuideParagraph::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideParagraph::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideParagraph::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideParagraph::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& GuideParagraph::desc() const {
  // @@protoc_insertion_point(field_get:pb.GuideParagraph.Desc)
  return *desc_;
}
inline void GuideParagraph::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideParagraph.Desc)
}
inline void GuideParagraph::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideParagraph.Desc)
}
inline void GuideParagraph::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideParagraph.Desc)
}
inline ::std::string* GuideParagraph::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideParagraph.Desc)
  return desc_;
}
inline ::std::string* GuideParagraph::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideParagraph::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideParagraph.Desc)
}

// -------------------------------------------------------------------

// GuideStepRes

// optional bool Insert = 1;
inline bool GuideStepRes::has_insert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideStepRes::set_has_insert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideStepRes::clear_has_insert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideStepRes::clear_insert() {
  insert_ = false;
  clear_has_insert();
}
inline bool GuideStepRes::insert() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.Insert)
  return insert_;
}
inline void GuideStepRes::set_insert(bool value) {
  set_has_insert();
  insert_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStepRes.Insert)
}

// optional .pb.PbVector2 GirlPos = 2;
inline bool GuideStepRes::has_girlpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideStepRes::set_has_girlpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideStepRes::clear_has_girlpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideStepRes::clear_girlpos() {
  if (girlpos_ != NULL) girlpos_->::pb::PbVector2::Clear();
  clear_has_girlpos();
}
inline const ::pb::PbVector2& GuideStepRes::girlpos() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.GirlPos)
  return girlpos_ != NULL ? *girlpos_ : *default_instance_->girlpos_;
}
inline ::pb::PbVector2* GuideStepRes::mutable_girlpos() {
  set_has_girlpos();
  if (girlpos_ == NULL) girlpos_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.GuideStepRes.GirlPos)
  return girlpos_;
}
inline ::pb::PbVector2* GuideStepRes::release_girlpos() {
  clear_has_girlpos();
  ::pb::PbVector2* temp = girlpos_;
  girlpos_ = NULL;
  return temp;
}
inline void GuideStepRes::set_allocated_girlpos(::pb::PbVector2* girlpos) {
  delete girlpos_;
  girlpos_ = girlpos;
  if (girlpos) {
    set_has_girlpos();
  } else {
    clear_has_girlpos();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStepRes.GirlPos)
}

// optional .pb.PbVector2 BoxPos = 3;
inline bool GuideStepRes::has_boxpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideStepRes::set_has_boxpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideStepRes::clear_has_boxpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideStepRes::clear_boxpos() {
  if (boxpos_ != NULL) boxpos_->::pb::PbVector2::Clear();
  clear_has_boxpos();
}
inline const ::pb::PbVector2& GuideStepRes::boxpos() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.BoxPos)
  return boxpos_ != NULL ? *boxpos_ : *default_instance_->boxpos_;
}
inline ::pb::PbVector2* GuideStepRes::mutable_boxpos() {
  set_has_boxpos();
  if (boxpos_ == NULL) boxpos_ = new ::pb::PbVector2;
  // @@protoc_insertion_point(field_mutable:pb.GuideStepRes.BoxPos)
  return boxpos_;
}
inline ::pb::PbVector2* GuideStepRes::release_boxpos() {
  clear_has_boxpos();
  ::pb::PbVector2* temp = boxpos_;
  boxpos_ = NULL;
  return temp;
}
inline void GuideStepRes::set_allocated_boxpos(::pb::PbVector2* boxpos) {
  delete boxpos_;
  boxpos_ = boxpos;
  if (boxpos) {
    set_has_boxpos();
  } else {
    clear_has_boxpos();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStepRes.BoxPos)
}

// optional bool GirlFlip = 4;
inline bool GuideStepRes::has_girlflip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideStepRes::set_has_girlflip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideStepRes::clear_has_girlflip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideStepRes::clear_girlflip() {
  girlflip_ = false;
  clear_has_girlflip();
}
inline bool GuideStepRes::girlflip() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.GirlFlip)
  return girlflip_;
}
inline void GuideStepRes::set_girlflip(bool value) {
  set_has_girlflip();
  girlflip_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStepRes.GirlFlip)
}

// optional bool BoxFlip = 5;
inline bool GuideStepRes::has_boxflip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideStepRes::set_has_boxflip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideStepRes::clear_has_boxflip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideStepRes::clear_boxflip() {
  boxflip_ = false;
  clear_has_boxflip();
}
inline bool GuideStepRes::boxflip() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.BoxFlip)
  return boxflip_;
}
inline void GuideStepRes::set_boxflip(bool value) {
  set_has_boxflip();
  boxflip_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStepRes.BoxFlip)
}

// optional int32 BoxLocalized = 6;
inline bool GuideStepRes::has_boxlocalized() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuideStepRes::set_has_boxlocalized() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuideStepRes::clear_has_boxlocalized() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuideStepRes::clear_boxlocalized() {
  boxlocalized_ = 0;
  clear_has_boxlocalized();
}
inline ::google::protobuf::int32 GuideStepRes::boxlocalized() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.BoxLocalized)
  return boxlocalized_;
}
inline void GuideStepRes::set_boxlocalized(::google::protobuf::int32 value) {
  set_has_boxlocalized();
  boxlocalized_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStepRes.BoxLocalized)
}

// optional .pb.EGuideGirlType GirlType = 7;
inline bool GuideStepRes::has_girltype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuideStepRes::set_has_girltype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuideStepRes::clear_has_girltype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuideStepRes::clear_girltype() {
  girltype_ = 0;
  clear_has_girltype();
}
inline ::pb::EGuideGirlType GuideStepRes::girltype() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.GirlType)
  return static_cast< ::pb::EGuideGirlType >(girltype_);
}
inline void GuideStepRes::set_girltype(::pb::EGuideGirlType value) {
  assert(::pb::EGuideGirlType_IsValid(value));
  set_has_girltype();
  girltype_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStepRes.GirlType)
}

// optional .pb.EEffectType EffectType = 8;
inline bool GuideStepRes::has_effecttype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuideStepRes::set_has_effecttype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuideStepRes::clear_has_effecttype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuideStepRes::clear_effecttype() {
  effecttype_ = 0;
  clear_has_effecttype();
}
inline ::pb::EEffectType GuideStepRes::effecttype() const {
  // @@protoc_insertion_point(field_get:pb.GuideStepRes.EffectType)
  return static_cast< ::pb::EEffectType >(effecttype_);
}
inline void GuideStepRes::set_effecttype(::pb::EEffectType value) {
  assert(::pb::EEffectType_IsValid(value));
  set_has_effecttype();
  effecttype_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStepRes.EffectType)
}

// -------------------------------------------------------------------

// ScrollInfo

// optional string ScrollPath = 1;
inline bool ScrollInfo::has_scrollpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollInfo::set_has_scrollpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScrollInfo::clear_has_scrollpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScrollInfo::clear_scrollpath() {
  if (scrollpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scrollpath_->clear();
  }
  clear_has_scrollpath();
}
inline const ::std::string& ScrollInfo::scrollpath() const {
  // @@protoc_insertion_point(field_get:pb.ScrollInfo.ScrollPath)
  return *scrollpath_;
}
inline void ScrollInfo::set_scrollpath(const ::std::string& value) {
  set_has_scrollpath();
  if (scrollpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scrollpath_ = new ::std::string;
  }
  scrollpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ScrollInfo.ScrollPath)
}
inline void ScrollInfo::set_scrollpath(const char* value) {
  set_has_scrollpath();
  if (scrollpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scrollpath_ = new ::std::string;
  }
  scrollpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ScrollInfo.ScrollPath)
}
inline void ScrollInfo::set_scrollpath(const char* value, size_t size) {
  set_has_scrollpath();
  if (scrollpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scrollpath_ = new ::std::string;
  }
  scrollpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ScrollInfo.ScrollPath)
}
inline ::std::string* ScrollInfo::mutable_scrollpath() {
  set_has_scrollpath();
  if (scrollpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scrollpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ScrollInfo.ScrollPath)
  return scrollpath_;
}
inline ::std::string* ScrollInfo::release_scrollpath() {
  clear_has_scrollpath();
  if (scrollpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = scrollpath_;
    scrollpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScrollInfo::set_allocated_scrollpath(::std::string* scrollpath) {
  if (scrollpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scrollpath_;
  }
  if (scrollpath) {
    set_has_scrollpath();
    scrollpath_ = scrollpath;
  } else {
    clear_has_scrollpath();
    scrollpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ScrollInfo.ScrollPath)
}

// optional int32 GroupIndex = 2;
inline bool ScrollInfo::has_groupindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollInfo::set_has_groupindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScrollInfo::clear_has_groupindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScrollInfo::clear_groupindex() {
  groupindex_ = 0;
  clear_has_groupindex();
}
inline ::google::protobuf::int32 ScrollInfo::groupindex() const {
  // @@protoc_insertion_point(field_get:pb.ScrollInfo.GroupIndex)
  return groupindex_;
}
inline void ScrollInfo::set_groupindex(::google::protobuf::int32 value) {
  set_has_groupindex();
  groupindex_ = value;
  // @@protoc_insertion_point(field_set:pb.ScrollInfo.GroupIndex)
}

// optional int32 ItemIndex = 3;
inline bool ScrollInfo::has_itemindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScrollInfo::set_has_itemindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScrollInfo::clear_has_itemindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScrollInfo::clear_itemindex() {
  itemindex_ = 0;
  clear_has_itemindex();
}
inline ::google::protobuf::int32 ScrollInfo::itemindex() const {
  // @@protoc_insertion_point(field_get:pb.ScrollInfo.ItemIndex)
  return itemindex_;
}
inline void ScrollInfo::set_itemindex(::google::protobuf::int32 value) {
  set_has_itemindex();
  itemindex_ = value;
  // @@protoc_insertion_point(field_set:pb.ScrollInfo.ItemIndex)
}

// optional int32 ScrollType = 4;
inline bool ScrollInfo::has_scrolltype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScrollInfo::set_has_scrolltype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScrollInfo::clear_has_scrolltype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScrollInfo::clear_scrolltype() {
  scrolltype_ = 0;
  clear_has_scrolltype();
}
inline ::google::protobuf::int32 ScrollInfo::scrolltype() const {
  // @@protoc_insertion_point(field_get:pb.ScrollInfo.ScrollType)
  return scrolltype_;
}
inline void ScrollInfo::set_scrolltype(::google::protobuf::int32 value) {
  set_has_scrolltype();
  scrolltype_ = value;
  // @@protoc_insertion_point(field_set:pb.ScrollInfo.ScrollType)
}

// optional int32 NeedScroll = 5;
inline bool ScrollInfo::has_needscroll() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScrollInfo::set_has_needscroll() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScrollInfo::clear_has_needscroll() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScrollInfo::clear_needscroll() {
  needscroll_ = 0;
  clear_has_needscroll();
}
inline ::google::protobuf::int32 ScrollInfo::needscroll() const {
  // @@protoc_insertion_point(field_get:pb.ScrollInfo.NeedScroll)
  return needscroll_;
}
inline void ScrollInfo::set_needscroll(::google::protobuf::int32 value) {
  set_has_needscroll();
  needscroll_ = value;
  // @@protoc_insertion_point(field_set:pb.ScrollInfo.NeedScroll)
}

// -------------------------------------------------------------------

// ExtraInfo

// optional bool LockUITouchMove = 1;
inline bool ExtraInfo::has_lockuitouchmove() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraInfo::set_has_lockuitouchmove() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraInfo::clear_has_lockuitouchmove() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraInfo::clear_lockuitouchmove() {
  lockuitouchmove_ = false;
  clear_has_lockuitouchmove();
}
inline bool ExtraInfo::lockuitouchmove() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.LockUITouchMove)
  return lockuitouchmove_;
}
inline void ExtraInfo::set_lockuitouchmove(bool value) {
  set_has_lockuitouchmove();
  lockuitouchmove_ = value;
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.LockUITouchMove)
}

// optional bool UseLayerModal = 2;
inline bool ExtraInfo::has_uselayermodal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtraInfo::set_has_uselayermodal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtraInfo::clear_has_uselayermodal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtraInfo::clear_uselayermodal() {
  uselayermodal_ = false;
  clear_has_uselayermodal();
}
inline bool ExtraInfo::uselayermodal() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.UseLayerModal)
  return uselayermodal_;
}
inline void ExtraInfo::set_uselayermodal(bool value) {
  set_has_uselayermodal();
  uselayermodal_ = value;
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.UseLayerModal)
}

// optional bool OnlyMark = 3;
inline bool ExtraInfo::has_onlymark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtraInfo::set_has_onlymark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtraInfo::clear_has_onlymark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtraInfo::clear_onlymark() {
  onlymark_ = false;
  clear_has_onlymark();
}
inline bool ExtraInfo::onlymark() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.OnlyMark)
  return onlymark_;
}
inline void ExtraInfo::set_onlymark(bool value) {
  set_has_onlymark();
  onlymark_ = value;
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.OnlyMark)
}

// optional bool LookAtBuilding = 4;
inline bool ExtraInfo::has_lookatbuilding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtraInfo::set_has_lookatbuilding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtraInfo::clear_has_lookatbuilding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtraInfo::clear_lookatbuilding() {
  lookatbuilding_ = false;
  clear_has_lookatbuilding();
}
inline bool ExtraInfo::lookatbuilding() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.LookAtBuilding)
  return lookatbuilding_;
}
inline void ExtraInfo::set_lookatbuilding(bool value) {
  set_has_lookatbuilding();
  lookatbuilding_ = value;
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.LookAtBuilding)
}

// optional int32 MoveSpeed = 6;
inline bool ExtraInfo::has_movespeed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtraInfo::set_has_movespeed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtraInfo::clear_has_movespeed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtraInfo::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline ::google::protobuf::int32 ExtraInfo::movespeed() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.MoveSpeed)
  return movespeed_;
}
inline void ExtraInfo::set_movespeed(::google::protobuf::int32 value) {
  set_has_movespeed();
  movespeed_ = value;
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.MoveSpeed)
}

// optional string ReqFuncName = 7;
inline bool ExtraInfo::has_reqfuncname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtraInfo::set_has_reqfuncname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExtraInfo::clear_has_reqfuncname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExtraInfo::clear_reqfuncname() {
  if (reqfuncname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reqfuncname_->clear();
  }
  clear_has_reqfuncname();
}
inline const ::std::string& ExtraInfo::reqfuncname() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.ReqFuncName)
  return *reqfuncname_;
}
inline void ExtraInfo::set_reqfuncname(const ::std::string& value) {
  set_has_reqfuncname();
  if (reqfuncname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reqfuncname_ = new ::std::string;
  }
  reqfuncname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.ReqFuncName)
}
inline void ExtraInfo::set_reqfuncname(const char* value) {
  set_has_reqfuncname();
  if (reqfuncname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reqfuncname_ = new ::std::string;
  }
  reqfuncname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ExtraInfo.ReqFuncName)
}
inline void ExtraInfo::set_reqfuncname(const char* value, size_t size) {
  set_has_reqfuncname();
  if (reqfuncname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reqfuncname_ = new ::std::string;
  }
  reqfuncname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ExtraInfo.ReqFuncName)
}
inline ::std::string* ExtraInfo::mutable_reqfuncname() {
  set_has_reqfuncname();
  if (reqfuncname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reqfuncname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ExtraInfo.ReqFuncName)
  return reqfuncname_;
}
inline ::std::string* ExtraInfo::release_reqfuncname() {
  clear_has_reqfuncname();
  if (reqfuncname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reqfuncname_;
    reqfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtraInfo::set_allocated_reqfuncname(::std::string* reqfuncname) {
  if (reqfuncname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reqfuncname_;
  }
  if (reqfuncname) {
    set_has_reqfuncname();
    reqfuncname_ = reqfuncname;
  } else {
    clear_has_reqfuncname();
    reqfuncname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ExtraInfo.ReqFuncName)
}

// optional float LimitTime = 8;
inline bool ExtraInfo::has_limittime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtraInfo::set_has_limittime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtraInfo::clear_has_limittime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtraInfo::clear_limittime() {
  limittime_ = 0;
  clear_has_limittime();
}
inline float ExtraInfo::limittime() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.LimitTime)
  return limittime_;
}
inline void ExtraInfo::set_limittime(float value) {
  set_has_limittime();
  limittime_ = value;
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.LimitTime)
}

// optional string FuncOpenAnim = 9;
inline bool ExtraInfo::has_funcopenanim() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExtraInfo::set_has_funcopenanim() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExtraInfo::clear_has_funcopenanim() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExtraInfo::clear_funcopenanim() {
  if (funcopenanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    funcopenanim_->clear();
  }
  clear_has_funcopenanim();
}
inline const ::std::string& ExtraInfo::funcopenanim() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.FuncOpenAnim)
  return *funcopenanim_;
}
inline void ExtraInfo::set_funcopenanim(const ::std::string& value) {
  set_has_funcopenanim();
  if (funcopenanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    funcopenanim_ = new ::std::string;
  }
  funcopenanim_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.FuncOpenAnim)
}
inline void ExtraInfo::set_funcopenanim(const char* value) {
  set_has_funcopenanim();
  if (funcopenanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    funcopenanim_ = new ::std::string;
  }
  funcopenanim_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ExtraInfo.FuncOpenAnim)
}
inline void ExtraInfo::set_funcopenanim(const char* value, size_t size) {
  set_has_funcopenanim();
  if (funcopenanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    funcopenanim_ = new ::std::string;
  }
  funcopenanim_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ExtraInfo.FuncOpenAnim)
}
inline ::std::string* ExtraInfo::mutable_funcopenanim() {
  set_has_funcopenanim();
  if (funcopenanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    funcopenanim_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ExtraInfo.FuncOpenAnim)
  return funcopenanim_;
}
inline ::std::string* ExtraInfo::release_funcopenanim() {
  clear_has_funcopenanim();
  if (funcopenanim_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = funcopenanim_;
    funcopenanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtraInfo::set_allocated_funcopenanim(::std::string* funcopenanim) {
  if (funcopenanim_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete funcopenanim_;
  }
  if (funcopenanim) {
    set_has_funcopenanim();
    funcopenanim_ = funcopenanim;
  } else {
    clear_has_funcopenanim();
    funcopenanim_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ExtraInfo.FuncOpenAnim)
}

// optional string DragEndWidget = 10;
inline bool ExtraInfo::has_dragendwidget() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExtraInfo::set_has_dragendwidget() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExtraInfo::clear_has_dragendwidget() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExtraInfo::clear_dragendwidget() {
  if (dragendwidget_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dragendwidget_->clear();
  }
  clear_has_dragendwidget();
}
inline const ::std::string& ExtraInfo::dragendwidget() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.DragEndWidget)
  return *dragendwidget_;
}
inline void ExtraInfo::set_dragendwidget(const ::std::string& value) {
  set_has_dragendwidget();
  if (dragendwidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dragendwidget_ = new ::std::string;
  }
  dragendwidget_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.DragEndWidget)
}
inline void ExtraInfo::set_dragendwidget(const char* value) {
  set_has_dragendwidget();
  if (dragendwidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dragendwidget_ = new ::std::string;
  }
  dragendwidget_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ExtraInfo.DragEndWidget)
}
inline void ExtraInfo::set_dragendwidget(const char* value, size_t size) {
  set_has_dragendwidget();
  if (dragendwidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dragendwidget_ = new ::std::string;
  }
  dragendwidget_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ExtraInfo.DragEndWidget)
}
inline ::std::string* ExtraInfo::mutable_dragendwidget() {
  set_has_dragendwidget();
  if (dragendwidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dragendwidget_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ExtraInfo.DragEndWidget)
  return dragendwidget_;
}
inline ::std::string* ExtraInfo::release_dragendwidget() {
  clear_has_dragendwidget();
  if (dragendwidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dragendwidget_;
    dragendwidget_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtraInfo::set_allocated_dragendwidget(::std::string* dragendwidget) {
  if (dragendwidget_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dragendwidget_;
  }
  if (dragendwidget) {
    set_has_dragendwidget();
    dragendwidget_ = dragendwidget;
  } else {
    clear_has_dragendwidget();
    dragendwidget_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ExtraInfo.DragEndWidget)
}

// optional string MainLayerPath = 11;
inline bool ExtraInfo::has_mainlayerpath() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExtraInfo::set_has_mainlayerpath() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExtraInfo::clear_has_mainlayerpath() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExtraInfo::clear_mainlayerpath() {
  if (mainlayerpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mainlayerpath_->clear();
  }
  clear_has_mainlayerpath();
}
inline const ::std::string& ExtraInfo::mainlayerpath() const {
  // @@protoc_insertion_point(field_get:pb.ExtraInfo.MainLayerPath)
  return *mainlayerpath_;
}
inline void ExtraInfo::set_mainlayerpath(const ::std::string& value) {
  set_has_mainlayerpath();
  if (mainlayerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mainlayerpath_ = new ::std::string;
  }
  mainlayerpath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ExtraInfo.MainLayerPath)
}
inline void ExtraInfo::set_mainlayerpath(const char* value) {
  set_has_mainlayerpath();
  if (mainlayerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mainlayerpath_ = new ::std::string;
  }
  mainlayerpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ExtraInfo.MainLayerPath)
}
inline void ExtraInfo::set_mainlayerpath(const char* value, size_t size) {
  set_has_mainlayerpath();
  if (mainlayerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mainlayerpath_ = new ::std::string;
  }
  mainlayerpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ExtraInfo.MainLayerPath)
}
inline ::std::string* ExtraInfo::mutable_mainlayerpath() {
  set_has_mainlayerpath();
  if (mainlayerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mainlayerpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ExtraInfo.MainLayerPath)
  return mainlayerpath_;
}
inline ::std::string* ExtraInfo::release_mainlayerpath() {
  clear_has_mainlayerpath();
  if (mainlayerpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mainlayerpath_;
    mainlayerpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtraInfo::set_allocated_mainlayerpath(::std::string* mainlayerpath) {
  if (mainlayerpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mainlayerpath_;
  }
  if (mainlayerpath) {
    set_has_mainlayerpath();
    mainlayerpath_ = mainlayerpath;
  } else {
    clear_has_mainlayerpath();
    mainlayerpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ExtraInfo.MainLayerPath)
}

// -------------------------------------------------------------------

// GuideStep

// optional .pb.EGuideStepType StepType = 1;
inline bool GuideStep::has_steptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideStep::set_has_steptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideStep::clear_has_steptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideStep::clear_steptype() {
  steptype_ = 0;
  clear_has_steptype();
}
inline ::pb::EGuideStepType GuideStep::steptype() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.StepType)
  return static_cast< ::pb::EGuideStepType >(steptype_);
}
inline void GuideStep::set_steptype(::pb::EGuideStepType value) {
  assert(::pb::EGuideStepType_IsValid(value));
  set_has_steptype();
  steptype_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStep.StepType)
}

// optional string GuideResPath = 2;
inline bool GuideStep::has_guiderespath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideStep::set_has_guiderespath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideStep::clear_has_guiderespath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideStep::clear_guiderespath() {
  if (guiderespath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guiderespath_->clear();
  }
  clear_has_guiderespath();
}
inline const ::std::string& GuideStep::guiderespath() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.GuideResPath)
  return *guiderespath_;
}
inline void GuideStep::set_guiderespath(const ::std::string& value) {
  set_has_guiderespath();
  if (guiderespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guiderespath_ = new ::std::string;
  }
  guiderespath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideStep.GuideResPath)
}
inline void GuideStep::set_guiderespath(const char* value) {
  set_has_guiderespath();
  if (guiderespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guiderespath_ = new ::std::string;
  }
  guiderespath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideStep.GuideResPath)
}
inline void GuideStep::set_guiderespath(const char* value, size_t size) {
  set_has_guiderespath();
  if (guiderespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guiderespath_ = new ::std::string;
  }
  guiderespath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideStep.GuideResPath)
}
inline ::std::string* GuideStep::mutable_guiderespath() {
  set_has_guiderespath();
  if (guiderespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guiderespath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.GuideResPath)
  return guiderespath_;
}
inline ::std::string* GuideStep::release_guiderespath() {
  clear_has_guiderespath();
  if (guiderespath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guiderespath_;
    guiderespath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideStep::set_allocated_guiderespath(::std::string* guiderespath) {
  if (guiderespath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guiderespath_;
  }
  if (guiderespath) {
    set_has_guiderespath();
    guiderespath_ = guiderespath;
  } else {
    clear_has_guiderespath();
    guiderespath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.GuideResPath)
}

// optional string GuideWidget = 3;
inline bool GuideStep::has_guidewidget() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideStep::set_has_guidewidget() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideStep::clear_has_guidewidget() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideStep::clear_guidewidget() {
  if (guidewidget_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guidewidget_->clear();
  }
  clear_has_guidewidget();
}
inline const ::std::string& GuideStep::guidewidget() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.GuideWidget)
  return *guidewidget_;
}
inline void GuideStep::set_guidewidget(const ::std::string& value) {
  set_has_guidewidget();
  if (guidewidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guidewidget_ = new ::std::string;
  }
  guidewidget_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideStep.GuideWidget)
}
inline void GuideStep::set_guidewidget(const char* value) {
  set_has_guidewidget();
  if (guidewidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guidewidget_ = new ::std::string;
  }
  guidewidget_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideStep.GuideWidget)
}
inline void GuideStep::set_guidewidget(const char* value, size_t size) {
  set_has_guidewidget();
  if (guidewidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guidewidget_ = new ::std::string;
  }
  guidewidget_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideStep.GuideWidget)
}
inline ::std::string* GuideStep::mutable_guidewidget() {
  set_has_guidewidget();
  if (guidewidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guidewidget_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.GuideWidget)
  return guidewidget_;
}
inline ::std::string* GuideStep::release_guidewidget() {
  clear_has_guidewidget();
  if (guidewidget_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guidewidget_;
    guidewidget_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideStep::set_allocated_guidewidget(::std::string* guidewidget) {
  if (guidewidget_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guidewidget_;
  }
  if (guidewidget) {
    set_has_guidewidget();
    guidewidget_ = guidewidget;
  } else {
    clear_has_guidewidget();
    guidewidget_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.GuideWidget)
}

// optional float DelayTime = 4;
inline bool GuideStep::has_delaytime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideStep::set_has_delaytime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideStep::clear_has_delaytime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideStep::clear_delaytime() {
  delaytime_ = 0;
  clear_has_delaytime();
}
inline float GuideStep::delaytime() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.DelayTime)
  return delaytime_;
}
inline void GuideStep::set_delaytime(float value) {
  set_has_delaytime();
  delaytime_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStep.DelayTime)
}

// optional .pb.GuideStepRes StepRes = 5;
inline bool GuideStep::has_stepres() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideStep::set_has_stepres() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideStep::clear_has_stepres() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideStep::clear_stepres() {
  if (stepres_ != NULL) stepres_->::pb::GuideStepRes::Clear();
  clear_has_stepres();
}
inline const ::pb::GuideStepRes& GuideStep::stepres() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.StepRes)
  return stepres_ != NULL ? *stepres_ : *default_instance_->stepres_;
}
inline ::pb::GuideStepRes* GuideStep::mutable_stepres() {
  set_has_stepres();
  if (stepres_ == NULL) stepres_ = new ::pb::GuideStepRes;
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.StepRes)
  return stepres_;
}
inline ::pb::GuideStepRes* GuideStep::release_stepres() {
  clear_has_stepres();
  ::pb::GuideStepRes* temp = stepres_;
  stepres_ = NULL;
  return temp;
}
inline void GuideStep::set_allocated_stepres(::pb::GuideStepRes* stepres) {
  delete stepres_;
  stepres_ = stepres;
  if (stepres) {
    set_has_stepres();
  } else {
    clear_has_stepres();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.StepRes)
}

// optional int32 ParamInt = 6;
inline bool GuideStep::has_paramint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuideStep::set_has_paramint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuideStep::clear_has_paramint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuideStep::clear_paramint() {
  paramint_ = 0;
  clear_has_paramint();
}
inline ::google::protobuf::int32 GuideStep::paramint() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.ParamInt)
  return paramint_;
}
inline void GuideStep::set_paramint(::google::protobuf::int32 value) {
  set_has_paramint();
  paramint_ = value;
  // @@protoc_insertion_point(field_set:pb.GuideStep.ParamInt)
}

// optional .pb.ExtraInfo ExtraInfo = 7;
inline bool GuideStep::has_extrainfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuideStep::set_has_extrainfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuideStep::clear_has_extrainfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuideStep::clear_extrainfo() {
  if (extrainfo_ != NULL) extrainfo_->::pb::ExtraInfo::Clear();
  clear_has_extrainfo();
}
inline const ::pb::ExtraInfo& GuideStep::extrainfo() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.ExtraInfo)
  return extrainfo_ != NULL ? *extrainfo_ : *default_instance_->extrainfo_;
}
inline ::pb::ExtraInfo* GuideStep::mutable_extrainfo() {
  set_has_extrainfo();
  if (extrainfo_ == NULL) extrainfo_ = new ::pb::ExtraInfo;
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.ExtraInfo)
  return extrainfo_;
}
inline ::pb::ExtraInfo* GuideStep::release_extrainfo() {
  clear_has_extrainfo();
  ::pb::ExtraInfo* temp = extrainfo_;
  extrainfo_ = NULL;
  return temp;
}
inline void GuideStep::set_allocated_extrainfo(::pb::ExtraInfo* extrainfo) {
  delete extrainfo_;
  extrainfo_ = extrainfo;
  if (extrainfo) {
    set_has_extrainfo();
  } else {
    clear_has_extrainfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.ExtraInfo)
}

// optional string Desc = 8;
inline bool GuideStep::has_desc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuideStep::set_has_desc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuideStep::clear_has_desc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuideStep::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& GuideStep::desc() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.Desc)
  return *desc_;
}
inline void GuideStep::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideStep.Desc)
}
inline void GuideStep::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideStep.Desc)
}
inline void GuideStep::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideStep.Desc)
}
inline ::std::string* GuideStep::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.Desc)
  return desc_;
}
inline ::std::string* GuideStep::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideStep::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.Desc)
}

// optional string SceneConfName = 9;
inline bool GuideStep::has_sceneconfname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuideStep::set_has_sceneconfname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuideStep::clear_has_sceneconfname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuideStep::clear_sceneconfname() {
  if (sceneconfname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_->clear();
  }
  clear_has_sceneconfname();
}
inline const ::std::string& GuideStep::sceneconfname() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.SceneConfName)
  return *sceneconfname_;
}
inline void GuideStep::set_sceneconfname(const ::std::string& value) {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  sceneconfname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.GuideStep.SceneConfName)
}
inline void GuideStep::set_sceneconfname(const char* value) {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  sceneconfname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GuideStep.SceneConfName)
}
inline void GuideStep::set_sceneconfname(const char* value, size_t size) {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  sceneconfname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GuideStep.SceneConfName)
}
inline ::std::string* GuideStep::mutable_sceneconfname() {
  set_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sceneconfname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.SceneConfName)
  return sceneconfname_;
}
inline ::std::string* GuideStep::release_sceneconfname() {
  clear_has_sceneconfname();
  if (sceneconfname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sceneconfname_;
    sceneconfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GuideStep::set_allocated_sceneconfname(::std::string* sceneconfname) {
  if (sceneconfname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sceneconfname_;
  }
  if (sceneconfname) {
    set_has_sceneconfname();
    sceneconfname_ = sceneconfname;
  } else {
    clear_has_sceneconfname();
    sceneconfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.SceneConfName)
}

// optional .pb.ScrollInfo ScrollInfo = 10;
inline bool GuideStep::has_scrollinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuideStep::set_has_scrollinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuideStep::clear_has_scrollinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuideStep::clear_scrollinfo() {
  if (scrollinfo_ != NULL) scrollinfo_->::pb::ScrollInfo::Clear();
  clear_has_scrollinfo();
}
inline const ::pb::ScrollInfo& GuideStep::scrollinfo() const {
  // @@protoc_insertion_point(field_get:pb.GuideStep.ScrollInfo)
  return scrollinfo_ != NULL ? *scrollinfo_ : *default_instance_->scrollinfo_;
}
inline ::pb::ScrollInfo* GuideStep::mutable_scrollinfo() {
  set_has_scrollinfo();
  if (scrollinfo_ == NULL) scrollinfo_ = new ::pb::ScrollInfo;
  // @@protoc_insertion_point(field_mutable:pb.GuideStep.ScrollInfo)
  return scrollinfo_;
}
inline ::pb::ScrollInfo* GuideStep::release_scrollinfo() {
  clear_has_scrollinfo();
  ::pb::ScrollInfo* temp = scrollinfo_;
  scrollinfo_ = NULL;
  return temp;
}
inline void GuideStep::set_allocated_scrollinfo(::pb::ScrollInfo* scrollinfo) {
  delete scrollinfo_;
  scrollinfo_ = scrollinfo;
  if (scrollinfo) {
    set_has_scrollinfo();
  } else {
    clear_has_scrollinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GuideStep.ScrollInfo)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::EGuideStepType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EGuideStepType>() {
  return ::pb::EGuideStepType_descriptor();
}
template <> struct is_proto_enum< ::pb::EGuideGirlType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EGuideGirlType>() {
  return ::pb::EGuideGirlType_descriptor();
}
template <> struct is_proto_enum< ::pb::EEffectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EEffectType>() {
  return ::pb::EEffectType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fGuideData_2eproto__INCLUDED
