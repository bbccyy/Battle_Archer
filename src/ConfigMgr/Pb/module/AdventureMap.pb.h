// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/AdventureMap.proto

#ifndef PROTOBUF_module_2fAdventureMap_2eproto__INCLUDED
#define PROTOBUF_module_2fAdventureMap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

class AdventureBlock;
class AdventureBehaviorKeyValue;
class AdventureBehaviorNode;
class AdventureBehavior;
class UserEventInfo;
class AdventureEvent;
class AdventureObject;
class AdventureBridge;
class AdventureGimmickDoor;
class AdventureTaskNpc;
class AdventureMystery;
class TransferObject;
class TrapResetPoint;
class AdventureLayer;
class AdventureMap;

enum EEventStatus {
  EVENT_UNDONE = 0,
  EVENT_INPROGRESS = 1,
  EVENT_DONE = 2
};
bool EEventStatus_IsValid(int value);
const EEventStatus EEventStatus_MIN = EVENT_UNDONE;
const EEventStatus EEventStatus_MAX = EVENT_DONE;
const int EEventStatus_ARRAYSIZE = EEventStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEventStatus_descriptor();
inline const ::std::string& EEventStatus_Name(EEventStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEventStatus_descriptor(), value);
}
inline bool EEventStatus_Parse(
    const ::std::string& name, EEventStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEventStatus>(
    EEventStatus_descriptor(), name, value);
}
// ===================================================================

/*FOR2LUA
<Record>
	<name>AdventureBlock</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureBlock : public ::google::protobuf::Message {
 public:
  AdventureBlock();
  virtual ~AdventureBlock();

  AdventureBlock(const AdventureBlock& from);

  inline AdventureBlock& operator=(const AdventureBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureBlock& default_instance();

  void Swap(AdventureBlock* other);

  // implements Message ----------------------------------------------

  AdventureBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureBlock& from);
  void MergeFrom(const AdventureBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureBlock</name>
  	<Function>
  		<name>x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 Y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureBlock</name>
  	<Function>
  		<name>y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional bool IsPass = 3;
  inline bool has_ispass() const;
  inline void clear_ispass();
  static const int kIsPassFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureBlock</name>
  	<Function>
  		<name>ispass</name>
  		<replaceName>IsPass</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_ispass</name>
  		<replaceName>IsPass</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_ispass</name>
  		<replaceName>IsPass</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool ispass() const;
  inline void set_ispass(bool value);

  // optional uint32 ResId = 4;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIdFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureBlock</name>
  	<Function>
  		<name>resid</name>
  		<replaceName>ResId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_resid</name>
  		<replaceName>ResId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_resid</name>
  		<replaceName>ResId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 resid() const;
  inline void set_resid(::google::protobuf::uint32 value);

  // optional bool CanPlace = 5;
  inline bool has_canplace() const;
  inline void clear_canplace();
  static const int kCanPlaceFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AdventureBlock</name>
  	<Function>
  		<name>canplace</name>
  		<replaceName>CanPlace</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_canplace</name>
  		<replaceName>CanPlace</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_canplace</name>
  		<replaceName>CanPlace</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool canplace() const;
  inline void set_canplace(bool value);

  // optional uint32 RegionId = 6;
  inline bool has_regionid() const;
  inline void clear_regionid();
  static const int kRegionIdFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AdventureBlock</name>
  	<Function>
  		<name>regionid</name>
  		<replaceName>RegionId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_regionid</name>
  		<replaceName>RegionId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_regionid</name>
  		<replaceName>RegionId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 regionid() const;
  inline void set_regionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureBlock)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_ispass();
  inline void clear_has_ispass();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_canplace();
  inline void clear_has_canplace();
  inline void set_has_regionid();
  inline void clear_has_regionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::uint32 resid_;
  bool ispass_;
  bool canplace_;
  ::google::protobuf::uint32 regionid_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureBlock* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureBehaviorKeyValue</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureBehaviorKeyValue : public ::google::protobuf::Message {
 public:
  AdventureBehaviorKeyValue();
  virtual ~AdventureBehaviorKeyValue();

  AdventureBehaviorKeyValue(const AdventureBehaviorKeyValue& from);

  inline AdventureBehaviorKeyValue& operator=(const AdventureBehaviorKeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureBehaviorKeyValue& default_instance();

  void Swap(AdventureBehaviorKeyValue* other);

  // implements Message ----------------------------------------------

  AdventureBehaviorKeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureBehaviorKeyValue& from);
  void MergeFrom(const AdventureBehaviorKeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehaviorKeyValue</name>
  	<Function>
  		<name>key</name>
  		<replaceName>Key</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_key</name>
  		<replaceName>Key</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_key</name>
  		<replaceName>Key</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehaviorKeyValue</name>
  	<Function>
  		<name>value</name>
  		<replaceName>Value</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_value</name>
  		<replaceName>Value</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_value</name>
  		<replaceName>Value</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional int32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehaviorKeyValue</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureBehaviorKeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureBehaviorKeyValue* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureBehaviorNode</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureBehaviorNode : public ::google::protobuf::Message {
 public:
  AdventureBehaviorNode();
  virtual ~AdventureBehaviorNode();

  AdventureBehaviorNode(const AdventureBehaviorNode& from);

  inline AdventureBehaviorNode& operator=(const AdventureBehaviorNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureBehaviorNode& default_instance();

  void Swap(AdventureBehaviorNode* other);

  // implements Message ----------------------------------------------

  AdventureBehaviorNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureBehaviorNode& from);
  void MergeFrom(const AdventureBehaviorNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 NodeId = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehaviorNode</name>
  	<Function>
  		<name>nodeid</name>
  		<replaceName>NodeId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_nodeid</name>
  		<replaceName>NodeId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_nodeid</name>
  		<replaceName>NodeId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 nodeid() const;
  inline void set_nodeid(::google::protobuf::uint32 value);

  // repeated .pb.AdventureBehaviorKeyValue Values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehaviorNode</name>
  	<Function>
  		<name>values</name>
  		<replaceName>Values</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_values</name>
  		<replaceName>Values</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_values</name>
  		<replaceName>Values</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_values</name>
  		<replaceName>Values</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>values_size</name>
  		<replaceName>Values</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureBehaviorKeyValue& values(int index) const;
  inline ::pb::AdventureBehaviorKeyValue* mutable_values(int index);
  inline ::pb::AdventureBehaviorKeyValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorKeyValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorKeyValue >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:pb.AdventureBehaviorNode)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorKeyValue > values_;
  ::google::protobuf::uint32 nodeid_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureBehaviorNode* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureBehavior</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureBehavior : public ::google::protobuf::Message {
 public:
  AdventureBehavior();
  virtual ~AdventureBehavior();

  AdventureBehavior(const AdventureBehavior& from);

  inline AdventureBehavior& operator=(const AdventureBehavior& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureBehavior& default_instance();

  void Swap(AdventureBehavior* other);

  // implements Message ----------------------------------------------

  AdventureBehavior* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureBehavior& from);
  void MergeFrom(const AdventureBehavior& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 BehaviorId = 1;
  inline bool has_behaviorid() const;
  inline void clear_behaviorid();
  static const int kBehaviorIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehavior</name>
  	<Function>
  		<name>behaviorid</name>
  		<replaceName>BehaviorId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_behaviorid</name>
  		<replaceName>BehaviorId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_behaviorid</name>
  		<replaceName>BehaviorId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 behaviorid() const;
  inline void set_behaviorid(::google::protobuf::uint32 value);

  // repeated .pb.AdventureBehaviorNode NodeArr = 2;
  inline int nodearr_size() const;
  inline void clear_nodearr();
  static const int kNodeArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureBehavior</name>
  	<Function>
  		<name>nodearr</name>
  		<replaceName>NodeArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_nodearr</name>
  		<replaceName>NodeArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_nodearr</name>
  		<replaceName>NodeArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_nodearr</name>
  		<replaceName>NodeArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>nodearr_size</name>
  		<replaceName>NodeArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureBehaviorNode& nodearr(int index) const;
  inline ::pb::AdventureBehaviorNode* mutable_nodearr(int index);
  inline ::pb::AdventureBehaviorNode* add_nodearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorNode >&
      nodearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorNode >*
      mutable_nodearr();

  // @@protoc_insertion_point(class_scope:pb.AdventureBehavior)
 private:
  inline void set_has_behaviorid();
  inline void clear_has_behaviorid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorNode > nodearr_;
  ::google::protobuf::uint32 behaviorid_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureBehavior* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>UserEventInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class UserEventInfo : public ::google::protobuf::Message {
 public:
  UserEventInfo();
  virtual ~UserEventInfo();

  UserEventInfo(const UserEventInfo& from);

  inline UserEventInfo& operator=(const UserEventInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserEventInfo& default_instance();

  void Swap(UserEventInfo* other);

  // implements Message ----------------------------------------------

  UserEventInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserEventInfo& from);
  void MergeFrom(const UserEventInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>UserEventInfo</name>
  	<Function>
  		<name>uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_uid</name>
  		<replaceName>Uid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 ChoseIndex = 2;
  inline bool has_choseindex() const;
  inline void clear_choseindex();
  static const int kChoseIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>UserEventInfo</name>
  	<Function>
  		<name>choseindex</name>
  		<replaceName>ChoseIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_choseindex</name>
  		<replaceName>ChoseIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_choseindex</name>
  		<replaceName>ChoseIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 choseindex() const;
  inline void set_choseindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.UserEventInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_choseindex();
  inline void clear_has_choseindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 choseindex_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static UserEventInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureEvent</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureEvent : public ::google::protobuf::Message {
 public:
  AdventureEvent();
  virtual ~AdventureEvent();

  AdventureEvent(const AdventureEvent& from);

  inline AdventureEvent& operator=(const AdventureEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureEvent& default_instance();

  void Swap(AdventureEvent* other);

  // implements Message ----------------------------------------------

  AdventureEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureEvent& from);
  void MergeFrom(const AdventureEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 EventId = 1;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>eventid</name>
  		<replaceName>EventId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_eventid</name>
  		<replaceName>EventId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventid</name>
  		<replaceName>EventId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 eventid() const;
  inline void set_eventid(::google::protobuf::uint32 value);

  // optional .pb.EEventStatus EventStatus = 2;
  inline bool has_eventstatus() const;
  inline void clear_eventstatus();
  static const int kEventStatusFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>eventstatus</name>
  		<replaceName>EventStatus</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_eventstatus</name>
  		<replaceName>EventStatus</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventstatus</name>
  		<replaceName>EventStatus</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EEventStatus eventstatus() const;
  inline void set_eventstatus(::pb::EEventStatus value);

  // optional .pb.AdventureBehavior Behavior = 3;
  inline bool has_behavior() const;
  inline void clear_behavior();
  static const int kBehaviorFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>behavior</name>
  		<replaceName>Behavior</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_behavior</name>
  		<replaceName>Behavior</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_behavior</name>
  		<replaceName>Behavior</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_behavior</name>
  		<replaceName>Behavior</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureBehavior& behavior() const;
  inline ::pb::AdventureBehavior* mutable_behavior();
  inline ::pb::AdventureBehavior* release_behavior();
  inline void set_allocated_behavior(::pb::AdventureBehavior* behavior);

  // repeated .pb.UserEventInfo UserEventInfoArr = 4;
  inline int usereventinfoarr_size() const;
  inline void clear_usereventinfoarr();
  static const int kUserEventInfoArrFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>usereventinfoarr</name>
  		<replaceName>UserEventInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_usereventinfoarr</name>
  		<replaceName>UserEventInfoArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_usereventinfoarr</name>
  		<replaceName>UserEventInfoArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_usereventinfoarr</name>
  		<replaceName>UserEventInfoArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>usereventinfoarr_size</name>
  		<replaceName>UserEventInfoArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::UserEventInfo& usereventinfoarr(int index) const;
  inline ::pb::UserEventInfo* mutable_usereventinfoarr(int index);
  inline ::pb::UserEventInfo* add_usereventinfoarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::UserEventInfo >&
      usereventinfoarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::UserEventInfo >*
      mutable_usereventinfoarr();

  // repeated uint32 BattleinfoIdArr = 5;
  inline int battleinfoidarr_size() const;
  inline void clear_battleinfoidarr();
  static const int kBattleinfoIdArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>battleinfoidarr</name>
  		<replaceName>BattleinfoIdArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_battleinfoidarr</name>
  		<replaceName>BattleinfoIdArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_battleinfoidarr</name>
  		<replaceName>BattleinfoIdArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_battleinfoidarr</name>
  		<replaceName>BattleinfoIdArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>battleinfoidarr_size</name>
  		<replaceName>BattleinfoIdArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 battleinfoidarr(int index) const;
  inline void set_battleinfoidarr(int index, ::google::protobuf::uint32 value);
  inline void add_battleinfoidarr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      battleinfoidarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_battleinfoidarr();

  // optional uint32 AnswerId = 6;
  inline bool has_answerid() const;
  inline void clear_answerid();
  static const int kAnswerIdFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>answerid</name>
  		<replaceName>AnswerId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_answerid</name>
  		<replaceName>AnswerId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_answerid</name>
  		<replaceName>AnswerId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 answerid() const;
  inline void set_answerid(::google::protobuf::uint32 value);

  // optional uint32 StateValue = 7;
  inline bool has_statevalue() const;
  inline void clear_statevalue();
  static const int kStateValueFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>statevalue</name>
  		<replaceName>StateValue</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_statevalue</name>
  		<replaceName>StateValue</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_statevalue</name>
  		<replaceName>StateValue</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 statevalue() const;
  inline void set_statevalue(::google::protobuf::uint32 value);

  // optional uint32 DoneValue = 8;
  inline bool has_donevalue() const;
  inline void clear_donevalue();
  static const int kDoneValueFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>donevalue</name>
  		<replaceName>DoneValue</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_donevalue</name>
  		<replaceName>DoneValue</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_donevalue</name>
  		<replaceName>DoneValue</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 donevalue() const;
  inline void set_donevalue(::google::protobuf::uint32 value);

  // repeated int32 RewardInfo = 9;
  inline int rewardinfo_size() const;
  inline void clear_rewardinfo();
  static const int kRewardInfoFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rewardinfo</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rewardinfo_size</name>
  		<replaceName>RewardInfo</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 rewardinfo(int index) const;
  inline void set_rewardinfo(int index, ::google::protobuf::int32 value);
  inline void add_rewardinfo(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rewardinfo() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rewardinfo();

  // optional uint64 AnswerStartTime = 10;
  inline bool has_answerstarttime() const;
  inline void clear_answerstarttime();
  static const int kAnswerStartTimeFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>AdventureEvent</name>
  	<Function>
  		<name>answerstarttime</name>
  		<replaceName>AnswerStartTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_answerstarttime</name>
  		<replaceName>AnswerStartTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_answerstarttime</name>
  		<replaceName>AnswerStartTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 answerstarttime() const;
  inline void set_answerstarttime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureEvent)
 private:
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_eventstatus();
  inline void clear_has_eventstatus();
  inline void set_has_behavior();
  inline void clear_has_behavior();
  inline void set_has_answerid();
  inline void clear_has_answerid();
  inline void set_has_statevalue();
  inline void clear_has_statevalue();
  inline void set_has_donevalue();
  inline void clear_has_donevalue();
  inline void set_has_answerstarttime();
  inline void clear_has_answerstarttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 eventid_;
  int eventstatus_;
  ::pb::AdventureBehavior* behavior_;
  ::google::protobuf::RepeatedPtrField< ::pb::UserEventInfo > usereventinfoarr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > battleinfoidarr_;
  ::google::protobuf::uint32 answerid_;
  ::google::protobuf::uint32 statevalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rewardinfo_;
  ::google::protobuf::uint64 answerstarttime_;
  ::google::protobuf::uint32 donevalue_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureEvent* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureObject</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureObject : public ::google::protobuf::Message {
 public:
  AdventureObject();
  virtual ~AdventureObject();

  AdventureObject(const AdventureObject& from);

  inline AdventureObject& operator=(const AdventureObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureObject& default_instance();

  void Swap(AdventureObject* other);

  // implements Message ----------------------------------------------

  AdventureObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureObject& from);
  void MergeFrom(const AdventureObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_x</name>
  		<replaceName>X</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 Y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_y</name>
  		<replaceName>Y</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional uint32 ObjectTid = 3;
  inline bool has_objecttid() const;
  inline void clear_objecttid();
  static const int kObjectTidFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>objecttid</name>
  		<replaceName>ObjectTid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_objecttid</name>
  		<replaceName>ObjectTid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_objecttid</name>
  		<replaceName>ObjectTid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 objecttid() const;
  inline void set_objecttid(::google::protobuf::uint32 value);

  // optional string ModelName = 4;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>modelname</name>
  		<replaceName>ModelName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_modelname</name>
  		<replaceName>ModelName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_modelname</name>
  		<replaceName>ModelName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // optional .pb.PbVector3 Scale = 5;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scale</name>
  		<replaceName>Scale</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3& scale() const;
  inline ::pb::PbVector3* mutable_scale();
  inline ::pb::PbVector3* release_scale();
  inline void set_allocated_scale(::pb::PbVector3* scale);

  // optional .pb.AdventureEvent Event = 6;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>event</name>
  		<replaceName>Event</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_event</name>
  		<replaceName>Event</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_event</name>
  		<replaceName>Event</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_event</name>
  		<replaceName>Event</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureEvent& event() const;
  inline ::pb::AdventureEvent* mutable_event();
  inline ::pb::AdventureEvent* release_event();
  inline void set_allocated_event(::pb::AdventureEvent* event);

  // optional uint32 SortingOrder = 7;
  inline bool has_sortingorder() const;
  inline void clear_sortingorder();
  static const int kSortingOrderFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AdventureObject</name>
  	<Function>
  		<name>sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sortingorder</name>
  		<replaceName>SortingOrder</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 sortingorder() const;
  inline void set_sortingorder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureObject)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_objecttid();
  inline void clear_has_objecttid();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_sortingorder();
  inline void clear_has_sortingorder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::std::string* modelname_;
  ::pb::PbVector3* scale_;
  ::google::protobuf::uint32 objecttid_;
  ::google::protobuf::uint32 sortingorder_;
  ::pb::AdventureEvent* event_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureObject* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureBridge</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureBridge : public ::google::protobuf::Message {
 public:
  AdventureBridge();
  virtual ~AdventureBridge();

  AdventureBridge(const AdventureBridge& from);

  inline AdventureBridge& operator=(const AdventureBridge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureBridge& default_instance();

  void Swap(AdventureBridge* other);

  // implements Message ----------------------------------------------

  AdventureBridge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureBridge& from);
  void MergeFrom(const AdventureBridge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureBridge</name>
  	<Function>
  		<name>x1</name>
  		<replaceName>X1</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_x1</name>
  		<replaceName>X1</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_x1</name>
  		<replaceName>X1</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 x1() const;
  inline void set_x1(::google::protobuf::int32 value);

  // optional int32 Y1 = 2;
  inline bool has_y1() const;
  inline void clear_y1();
  static const int kY1FieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureBridge</name>
  	<Function>
  		<name>y1</name>
  		<replaceName>Y1</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_y1</name>
  		<replaceName>Y1</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_y1</name>
  		<replaceName>Y1</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 y1() const;
  inline void set_y1(::google::protobuf::int32 value);

  // optional int32 X2 = 3;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureBridge</name>
  	<Function>
  		<name>x2</name>
  		<replaceName>X2</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_x2</name>
  		<replaceName>X2</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_x2</name>
  		<replaceName>X2</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 x2() const;
  inline void set_x2(::google::protobuf::int32 value);

  // optional int32 Y2 = 4;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureBridge</name>
  	<Function>
  		<name>y2</name>
  		<replaceName>Y2</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_y2</name>
  		<replaceName>Y2</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_y2</name>
  		<replaceName>Y2</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 y2() const;
  inline void set_y2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureBridge)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_y1();
  inline void clear_has_y1();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_y2();
  inline void clear_has_y2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x1_;
  ::google::protobuf::int32 y1_;
  ::google::protobuf::int32 x2_;
  ::google::protobuf::int32 y2_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureBridge* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureGimmickDoor</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureGimmickDoor : public ::google::protobuf::Message {
 public:
  AdventureGimmickDoor();
  virtual ~AdventureGimmickDoor();

  AdventureGimmickDoor(const AdventureGimmickDoor& from);

  inline AdventureGimmickDoor& operator=(const AdventureGimmickDoor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureGimmickDoor& default_instance();

  void Swap(AdventureGimmickDoor* other);

  // implements Message ----------------------------------------------

  AdventureGimmickDoor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureGimmickDoor& from);
  void MergeFrom(const AdventureGimmickDoor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 KeyIndex = 1;
  inline bool has_keyindex() const;
  inline void clear_keyindex();
  static const int kKeyIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureGimmickDoor</name>
  	<Function>
  		<name>keyindex</name>
  		<replaceName>KeyIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_keyindex</name>
  		<replaceName>KeyIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_keyindex</name>
  		<replaceName>KeyIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 keyindex() const;
  inline void set_keyindex(::google::protobuf::int32 value);

  // optional int32 DoorIndex = 2;
  inline bool has_doorindex() const;
  inline void clear_doorindex();
  static const int kDoorIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureGimmickDoor</name>
  	<Function>
  		<name>doorindex</name>
  		<replaceName>DoorIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_doorindex</name>
  		<replaceName>DoorIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_doorindex</name>
  		<replaceName>DoorIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 doorindex() const;
  inline void set_doorindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureGimmickDoor)
 private:
  inline void set_has_keyindex();
  inline void clear_has_keyindex();
  inline void set_has_doorindex();
  inline void clear_has_doorindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 keyindex_;
  ::google::protobuf::int32 doorindex_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureGimmickDoor* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureTaskNpc</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureTaskNpc : public ::google::protobuf::Message {
 public:
  AdventureTaskNpc();
  virtual ~AdventureTaskNpc();

  AdventureTaskNpc(const AdventureTaskNpc& from);

  inline AdventureTaskNpc& operator=(const AdventureTaskNpc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureTaskNpc& default_instance();

  void Swap(AdventureTaskNpc* other);

  // implements Message ----------------------------------------------

  AdventureTaskNpc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureTaskNpc& from);
  void MergeFrom(const AdventureTaskNpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 NpcIndex = 1;
  inline bool has_npcindex() const;
  inline void clear_npcindex();
  static const int kNpcIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureTaskNpc</name>
  	<Function>
  		<name>npcindex</name>
  		<replaceName>NpcIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_npcindex</name>
  		<replaceName>NpcIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_npcindex</name>
  		<replaceName>NpcIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 npcindex() const;
  inline void set_npcindex(::google::protobuf::int32 value);

  // repeated int32 ObjIndexArr = 2;
  inline int objindexarr_size() const;
  inline void clear_objindexarr();
  static const int kObjIndexArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureTaskNpc</name>
  	<Function>
  		<name>objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>objindexarr_size</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 objindexarr(int index) const;
  inline void set_objindexarr(int index, ::google::protobuf::int32 value);
  inline void add_objindexarr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      objindexarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_objindexarr();

  // @@protoc_insertion_point(class_scope:pb.AdventureTaskNpc)
 private:
  inline void set_has_npcindex();
  inline void clear_has_npcindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > objindexarr_;
  ::google::protobuf::int32 npcindex_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureTaskNpc* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureMystery</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureMystery : public ::google::protobuf::Message {
 public:
  AdventureMystery();
  virtual ~AdventureMystery();

  AdventureMystery(const AdventureMystery& from);

  inline AdventureMystery& operator=(const AdventureMystery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureMystery& default_instance();

  void Swap(AdventureMystery* other);

  // implements Message ----------------------------------------------

  AdventureMystery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureMystery& from);
  void MergeFrom(const AdventureMystery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 MysteryDoorIndex = 1;
  inline bool has_mysterydoorindex() const;
  inline void clear_mysterydoorindex();
  static const int kMysteryDoorIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>mysterydoorindex</name>
  		<replaceName>MysteryDoorIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mysterydoorindex</name>
  		<replaceName>MysteryDoorIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mysterydoorindex</name>
  		<replaceName>MysteryDoorIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 mysterydoorindex() const;
  inline void set_mysterydoorindex(::google::protobuf::int32 value);

  // repeated int32 ObjIndexArr = 2;
  inline int objindexarr_size() const;
  inline void clear_objindexarr();
  static const int kObjIndexArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_objindexarr</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>objindexarr_size</name>
  		<replaceName>ObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 objindexarr(int index) const;
  inline void set_objindexarr(int index, ::google::protobuf::int32 value);
  inline void add_objindexarr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      objindexarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_objindexarr();

  // repeated int32 TargetObjIndexArr = 3;
  inline int targetobjindexarr_size() const;
  inline void clear_targetobjindexarr();
  static const int kTargetObjIndexArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>targetobjindexarr</name>
  		<replaceName>TargetObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_targetobjindexarr</name>
  		<replaceName>TargetObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_targetobjindexarr</name>
  		<replaceName>TargetObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_targetobjindexarr</name>
  		<replaceName>TargetObjIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>targetobjindexarr_size</name>
  		<replaceName>TargetObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 targetobjindexarr(int index) const;
  inline void set_targetobjindexarr(int index, ::google::protobuf::int32 value);
  inline void add_targetobjindexarr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      targetobjindexarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_targetobjindexarr();

  // repeated int32 NonTargetObjIndexArr = 4;
  inline int nontargetobjindexarr_size() const;
  inline void clear_nontargetobjindexarr();
  static const int kNonTargetObjIndexArrFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>nontargetobjindexarr</name>
  		<replaceName>NonTargetObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_nontargetobjindexarr</name>
  		<replaceName>NonTargetObjIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_nontargetobjindexarr</name>
  		<replaceName>NonTargetObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_nontargetobjindexarr</name>
  		<replaceName>NonTargetObjIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>nontargetobjindexarr_size</name>
  		<replaceName>NonTargetObjIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 nontargetobjindexarr(int index) const;
  inline void set_nontargetobjindexarr(int index, ::google::protobuf::int32 value);
  inline void add_nontargetobjindexarr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      nontargetobjindexarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_nontargetobjindexarr();

  // optional uint32 MysteryLayerIndex = 5;
  inline bool has_mysterylayerindex() const;
  inline void clear_mysterylayerindex();
  static const int kMysteryLayerIndexFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>mysterylayerindex</name>
  		<replaceName>MysteryLayerIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mysterylayerindex</name>
  		<replaceName>MysteryLayerIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mysterylayerindex</name>
  		<replaceName>MysteryLayerIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 mysterylayerindex() const;
  inline void set_mysterylayerindex(::google::protobuf::uint32 value);

  // optional uint32 IsOpen = 6;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>isopen</name>
  		<replaceName>IsOpen</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_isopen</name>
  		<replaceName>IsOpen</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_isopen</name>
  		<replaceName>IsOpen</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 isopen() const;
  inline void set_isopen(::google::protobuf::uint32 value);

  // optional int32 CipherMonsterIndex = 7;
  inline bool has_ciphermonsterindex() const;
  inline void clear_ciphermonsterindex();
  static const int kCipherMonsterIndexFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AdventureMystery</name>
  	<Function>
  		<name>ciphermonsterindex</name>
  		<replaceName>CipherMonsterIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_ciphermonsterindex</name>
  		<replaceName>CipherMonsterIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_ciphermonsterindex</name>
  		<replaceName>CipherMonsterIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 ciphermonsterindex() const;
  inline void set_ciphermonsterindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureMystery)
 private:
  inline void set_has_mysterydoorindex();
  inline void clear_has_mysterydoorindex();
  inline void set_has_mysterylayerindex();
  inline void clear_has_mysterylayerindex();
  inline void set_has_isopen();
  inline void clear_has_isopen();
  inline void set_has_ciphermonsterindex();
  inline void clear_has_ciphermonsterindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > objindexarr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > targetobjindexarr_;
  ::google::protobuf::int32 mysterydoorindex_;
  ::google::protobuf::uint32 mysterylayerindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > nontargetobjindexarr_;
  ::google::protobuf::uint32 isopen_;
  ::google::protobuf::int32 ciphermonsterindex_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureMystery* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TransferObject</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TransferObject : public ::google::protobuf::Message {
 public:
  TransferObject();
  virtual ~TransferObject();

  TransferObject(const TransferObject& from);

  inline TransferObject& operator=(const TransferObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferObject& default_instance();

  void Swap(TransferObject* other);

  // implements Message ----------------------------------------------

  TransferObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferObject& from);
  void MergeFrom(const TransferObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ObjectLayerIndex = 1;
  inline bool has_objectlayerindex() const;
  inline void clear_objectlayerindex();
  static const int kObjectLayerIndexFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TransferObject</name>
  	<Function>
  		<name>objectlayerindex</name>
  		<replaceName>ObjectLayerIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_objectlayerindex</name>
  		<replaceName>ObjectLayerIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_objectlayerindex</name>
  		<replaceName>ObjectLayerIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 objectlayerindex() const;
  inline void set_objectlayerindex(::google::protobuf::uint32 value);

  // optional int32 ObjectIndex = 2;
  inline bool has_objectindex() const;
  inline void clear_objectindex();
  static const int kObjectIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TransferObject</name>
  	<Function>
  		<name>objectindex</name>
  		<replaceName>ObjectIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_objectindex</name>
  		<replaceName>ObjectIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_objectindex</name>
  		<replaceName>ObjectIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 objectindex() const;
  inline void set_objectindex(::google::protobuf::int32 value);

  // optional uint32 TransferLayerIndex = 3;
  inline bool has_transferlayerindex() const;
  inline void clear_transferlayerindex();
  static const int kTransferLayerIndexFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TransferObject</name>
  	<Function>
  		<name>transferlayerindex</name>
  		<replaceName>TransferLayerIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_transferlayerindex</name>
  		<replaceName>TransferLayerIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_transferlayerindex</name>
  		<replaceName>TransferLayerIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 transferlayerindex() const;
  inline void set_transferlayerindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.TransferObject)
 private:
  inline void set_has_objectlayerindex();
  inline void clear_has_objectlayerindex();
  inline void set_has_objectindex();
  inline void clear_has_objectindex();
  inline void set_has_transferlayerindex();
  inline void clear_has_transferlayerindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 objectlayerindex_;
  ::google::protobuf::int32 objectindex_;
  ::google::protobuf::uint32 transferlayerindex_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static TransferObject* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TrapResetPoint</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TrapResetPoint : public ::google::protobuf::Message {
 public:
  TrapResetPoint();
  virtual ~TrapResetPoint();

  TrapResetPoint(const TrapResetPoint& from);

  inline TrapResetPoint& operator=(const TrapResetPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrapResetPoint& default_instance();

  void Swap(TrapResetPoint* other);

  // implements Message ----------------------------------------------

  TrapResetPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrapResetPoint& from);
  void MergeFrom(const TrapResetPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 TrapId = 1;
  inline bool has_trapid() const;
  inline void clear_trapid();
  static const int kTrapIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TrapResetPoint</name>
  	<Function>
  		<name>trapid</name>
  		<replaceName>TrapId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_trapid</name>
  		<replaceName>TrapId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_trapid</name>
  		<replaceName>TrapId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 trapid() const;
  inline void set_trapid(::google::protobuf::uint32 value);

  // optional .pb.PbVector2_Int Pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TrapResetPoint</name>
  	<Function>
  		<name>pos</name>
  		<replaceName>Pos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_pos</name>
  		<replaceName>Pos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_pos</name>
  		<replaceName>Pos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pos</name>
  		<replaceName>Pos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2_Int& pos() const;
  inline ::pb::PbVector2_Int* mutable_pos();
  inline ::pb::PbVector2_Int* release_pos();
  inline void set_allocated_pos(::pb::PbVector2_Int* pos);

  // @@protoc_insertion_point(class_scope:pb.TrapResetPoint)
 private:
  inline void set_has_trapid();
  inline void clear_has_trapid();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::PbVector2_Int* pos_;
  ::google::protobuf::uint32 trapid_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static TrapResetPoint* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureLayer</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureLayer : public ::google::protobuf::Message {
 public:
  AdventureLayer();
  virtual ~AdventureLayer();

  AdventureLayer(const AdventureLayer& from);

  inline AdventureLayer& operator=(const AdventureLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureLayer& default_instance();

  void Swap(AdventureLayer* other);

  // implements Message ----------------------------------------------

  AdventureLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureLayer& from);
  void MergeFrom(const AdventureLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.AdventureBlock BlockArr = 1;
  inline int blockarr_size() const;
  inline void clear_blockarr();
  static const int kBlockArrFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>blockarr</name>
  		<replaceName>BlockArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_blockarr</name>
  		<replaceName>BlockArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_blockarr</name>
  		<replaceName>BlockArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_blockarr</name>
  		<replaceName>BlockArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>blockarr_size</name>
  		<replaceName>BlockArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureBlock& blockarr(int index) const;
  inline ::pb::AdventureBlock* mutable_blockarr(int index);
  inline ::pb::AdventureBlock* add_blockarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBlock >&
      blockarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBlock >*
      mutable_blockarr();

  // repeated .pb.AdventureObject ObjectArr = 2;
  inline int objectarr_size() const;
  inline void clear_objectarr();
  static const int kObjectArrFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>objectarr</name>
  		<replaceName>ObjectArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_objectarr</name>
  		<replaceName>ObjectArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_objectarr</name>
  		<replaceName>ObjectArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_objectarr</name>
  		<replaceName>ObjectArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>objectarr_size</name>
  		<replaceName>ObjectArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureObject& objectarr(int index) const;
  inline ::pb::AdventureObject* mutable_objectarr(int index);
  inline ::pb::AdventureObject* add_objectarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureObject >&
      objectarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureObject >*
      mutable_objectarr();

  // repeated .pb.AdventureBridge BridgeArr = 3;
  inline int bridgearr_size() const;
  inline void clear_bridgearr();
  static const int kBridgeArrFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>bridgearr</name>
  		<replaceName>BridgeArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_bridgearr</name>
  		<replaceName>BridgeArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_bridgearr</name>
  		<replaceName>BridgeArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_bridgearr</name>
  		<replaceName>BridgeArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>bridgearr_size</name>
  		<replaceName>BridgeArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureBridge& bridgearr(int index) const;
  inline ::pb::AdventureBridge* mutable_bridgearr(int index);
  inline ::pb::AdventureBridge* add_bridgearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBridge >&
      bridgearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBridge >*
      mutable_bridgearr();

  // optional .pb.PbVector2_Int LayerSize = 4;
  inline bool has_layersize() const;
  inline void clear_layersize();
  static const int kLayerSizeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>layersize</name>
  		<replaceName>LayerSize</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_layersize</name>
  		<replaceName>LayerSize</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_layersize</name>
  		<replaceName>LayerSize</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_layersize</name>
  		<replaceName>LayerSize</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2_Int& layersize() const;
  inline ::pb::PbVector2_Int* mutable_layersize();
  inline ::pb::PbVector2_Int* release_layersize();
  inline void set_allocated_layersize(::pb::PbVector2_Int* layersize);

  // repeated .pb.AdventureGimmickDoor DoorArr = 5;
  inline int doorarr_size() const;
  inline void clear_doorarr();
  static const int kDoorArrFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>doorarr</name>
  		<replaceName>DoorArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_doorarr</name>
  		<replaceName>DoorArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_doorarr</name>
  		<replaceName>DoorArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_doorarr</name>
  		<replaceName>DoorArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>doorarr_size</name>
  		<replaceName>DoorArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureGimmickDoor& doorarr(int index) const;
  inline ::pb::AdventureGimmickDoor* mutable_doorarr(int index);
  inline ::pb::AdventureGimmickDoor* add_doorarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureGimmickDoor >&
      doorarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureGimmickDoor >*
      mutable_doorarr();

  // optional .pb.AdventureTaskNpc TaskNpc = 6;
  inline bool has_tasknpc() const;
  inline void clear_tasknpc();
  static const int kTaskNpcFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>tasknpc</name>
  		<replaceName>TaskNpc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_tasknpc</name>
  		<replaceName>TaskNpc</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_tasknpc</name>
  		<replaceName>TaskNpc</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_tasknpc</name>
  		<replaceName>TaskNpc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureTaskNpc& tasknpc() const;
  inline ::pb::AdventureTaskNpc* mutable_tasknpc();
  inline ::pb::AdventureTaskNpc* release_tasknpc();
  inline void set_allocated_tasknpc(::pb::AdventureTaskNpc* tasknpc);

  // optional .pb.AdventureMystery MysteryEntry = 7;
  inline bool has_mysteryentry() const;
  inline void clear_mysteryentry();
  static const int kMysteryEntryFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>mysteryentry</name>
  		<replaceName>MysteryEntry</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mysteryentry</name>
  		<replaceName>MysteryEntry</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_mysteryentry</name>
  		<replaceName>MysteryEntry</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mysteryentry</name>
  		<replaceName>MysteryEntry</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureMystery& mysteryentry() const;
  inline ::pb::AdventureMystery* mutable_mysteryentry();
  inline ::pb::AdventureMystery* release_mysteryentry();
  inline void set_allocated_mysteryentry(::pb::AdventureMystery* mysteryentry);

  // repeated .pb.PbVector2_Int RoomPosArr = 8;
  inline int roomposarr_size() const;
  inline void clear_roomposarr();
  static const int kRoomPosArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>roomposarr</name>
  		<replaceName>RoomPosArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_roomposarr</name>
  		<replaceName>RoomPosArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_roomposarr</name>
  		<replaceName>RoomPosArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_roomposarr</name>
  		<replaceName>RoomPosArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>roomposarr_size</name>
  		<replaceName>RoomPosArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector2_Int& roomposarr(int index) const;
  inline ::pb::PbVector2_Int* mutable_roomposarr(int index);
  inline ::pb::PbVector2_Int* add_roomposarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >&
      roomposarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >*
      mutable_roomposarr();

  // repeated .pb.TrapResetPoint TrapPosArr = 9;
  inline int trapposarr_size() const;
  inline void clear_trapposarr();
  static const int kTrapPosArrFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>AdventureLayer</name>
  	<Function>
  		<name>trapposarr</name>
  		<replaceName>TrapPosArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_trapposarr</name>
  		<replaceName>TrapPosArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_trapposarr</name>
  		<replaceName>TrapPosArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_trapposarr</name>
  		<replaceName>TrapPosArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>trapposarr_size</name>
  		<replaceName>TrapPosArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TrapResetPoint& trapposarr(int index) const;
  inline ::pb::TrapResetPoint* mutable_trapposarr(int index);
  inline ::pb::TrapResetPoint* add_trapposarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TrapResetPoint >&
      trapposarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TrapResetPoint >*
      mutable_trapposarr();

  // @@protoc_insertion_point(class_scope:pb.AdventureLayer)
 private:
  inline void set_has_layersize();
  inline void clear_has_layersize();
  inline void set_has_tasknpc();
  inline void clear_has_tasknpc();
  inline void set_has_mysteryentry();
  inline void clear_has_mysteryentry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureBlock > blockarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureObject > objectarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureBridge > bridgearr_;
  ::pb::PbVector2_Int* layersize_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureGimmickDoor > doorarr_;
  ::pb::AdventureTaskNpc* tasknpc_;
  ::pb::AdventureMystery* mysteryentry_;
  ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int > roomposarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::TrapResetPoint > trapposarr_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureLayer* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>AdventureMap</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/AdventureMap.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class AdventureMap : public ::google::protobuf::Message {
 public:
  AdventureMap();
  virtual ~AdventureMap();

  AdventureMap(const AdventureMap& from);

  inline AdventureMap& operator=(const AdventureMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdventureMap& default_instance();

  void Swap(AdventureMap* other);

  // implements Message ----------------------------------------------

  AdventureMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdventureMap& from);
  void MergeFrom(const AdventureMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 MapTid = 2;
  inline bool has_maptid() const;
  inline void clear_maptid();
  static const int kMapTidFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>maptid</name>
  		<replaceName>MapTid</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_maptid</name>
  		<replaceName>MapTid</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_maptid</name>
  		<replaceName>MapTid</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 maptid() const;
  inline void set_maptid(::google::protobuf::uint32 value);

  // optional string MapName = 3;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>mapname</name>
  		<replaceName>MapName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mapname</name>
  		<replaceName>MapName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mapname</name>
  		<replaceName>MapName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // optional int32 StartX = 4;
  inline bool has_startx() const;
  inline void clear_startx();
  static const int kStartXFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>startx</name>
  		<replaceName>StartX</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_startx</name>
  		<replaceName>StartX</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_startx</name>
  		<replaceName>StartX</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 startx() const;
  inline void set_startx(::google::protobuf::int32 value);

  // optional int32 StartY = 5;
  inline bool has_starty() const;
  inline void clear_starty();
  static const int kStartYFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>starty</name>
  		<replaceName>StartY</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_starty</name>
  		<replaceName>StartY</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_starty</name>
  		<replaceName>StartY</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 starty() const;
  inline void set_starty(::google::protobuf::int32 value);

  // optional int32 DirectX = 6;
  inline bool has_directx() const;
  inline void clear_directx();
  static const int kDirectXFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>directx</name>
  		<replaceName>DirectX</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_directx</name>
  		<replaceName>DirectX</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_directx</name>
  		<replaceName>DirectX</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 directx() const;
  inline void set_directx(::google::protobuf::int32 value);

  // optional int32 DirectY = 7;
  inline bool has_directy() const;
  inline void clear_directy();
  static const int kDirectYFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>directy</name>
  		<replaceName>DirectY</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_directy</name>
  		<replaceName>DirectY</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_directy</name>
  		<replaceName>DirectY</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 directy() const;
  inline void set_directy(::google::protobuf::int32 value);

  // repeated .pb.AdventureLayer LayerArr = 8;
  inline int layerarr_size() const;
  inline void clear_layerarr();
  static const int kLayerArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>layerarr</name>
  		<replaceName>LayerArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_layerarr</name>
  		<replaceName>LayerArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_layerarr</name>
  		<replaceName>LayerArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_layerarr</name>
  		<replaceName>LayerArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>layerarr_size</name>
  		<replaceName>LayerArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AdventureLayer& layerarr(int index) const;
  inline ::pb::AdventureLayer* mutable_layerarr(int index);
  inline ::pb::AdventureLayer* add_layerarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureLayer >&
      layerarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureLayer >*
      mutable_layerarr();

  // optional uint32 TerrainMapId = 9;
  inline bool has_terrainmapid() const;
  inline void clear_terrainmapid();
  static const int kTerrainMapIdFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>terrainmapid</name>
  		<replaceName>TerrainMapId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_terrainmapid</name>
  		<replaceName>TerrainMapId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_terrainmapid</name>
  		<replaceName>TerrainMapId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 terrainmapid() const;
  inline void set_terrainmapid(::google::protobuf::uint32 value);

  // optional uint32 EventNum = 10;
  inline bool has_eventnum() const;
  inline void clear_eventnum();
  static const int kEventNumFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>eventnum</name>
  		<replaceName>EventNum</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_eventnum</name>
  		<replaceName>EventNum</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_eventnum</name>
  		<replaceName>EventNum</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 eventnum() const;
  inline void set_eventnum(::google::protobuf::uint32 value);

  // optional uint64 MonsterHp = 11;
  inline bool has_monsterhp() const;
  inline void clear_monsterhp();
  static const int kMonsterHpFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>monsterhp</name>
  		<replaceName>MonsterHp</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_monsterhp</name>
  		<replaceName>MonsterHp</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_monsterhp</name>
  		<replaceName>MonsterHp</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 monsterhp() const;
  inline void set_monsterhp(::google::protobuf::uint64 value);

  // repeated .pb.TransferObject TransferObjArr = 12;
  inline int transferobjarr_size() const;
  inline void clear_transferobjarr();
  static const int kTransferObjArrFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>transferobjarr</name>
  		<replaceName>TransferObjArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_transferobjarr</name>
  		<replaceName>TransferObjArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_transferobjarr</name>
  		<replaceName>TransferObjArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_transferobjarr</name>
  		<replaceName>TransferObjArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>transferobjarr_size</name>
  		<replaceName>TransferObjArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TransferObject& transferobjarr(int index) const;
  inline ::pb::TransferObject* mutable_transferobjarr(int index);
  inline ::pb::TransferObject* add_transferobjarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TransferObject >&
      transferobjarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TransferObject >*
      mutable_transferobjarr();

  // optional uint32 DoneEventNum = 13;
  inline bool has_doneeventnum() const;
  inline void clear_doneeventnum();
  static const int kDoneEventNumFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>doneeventnum</name>
  		<replaceName>DoneEventNum</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_doneeventnum</name>
  		<replaceName>DoneEventNum</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_doneeventnum</name>
  		<replaceName>DoneEventNum</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 doneeventnum() const;
  inline void set_doneeventnum(::google::protobuf::uint32 value);

  // optional uint64 MapExpireTime = 14;
  inline bool has_mapexpiretime() const;
  inline void clear_mapexpiretime();
  static const int kMapExpireTimeFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>AdventureMap</name>
  	<Function>
  		<name>mapexpiretime</name>
  		<replaceName>MapExpireTime</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_mapexpiretime</name>
  		<replaceName>MapExpireTime</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_mapexpiretime</name>
  		<replaceName>MapExpireTime</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint64 mapexpiretime() const;
  inline void set_mapexpiretime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.AdventureMap)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_maptid();
  inline void clear_has_maptid();
  inline void set_has_mapname();
  inline void clear_has_mapname();
  inline void set_has_startx();
  inline void clear_has_startx();
  inline void set_has_starty();
  inline void clear_has_starty();
  inline void set_has_directx();
  inline void clear_has_directx();
  inline void set_has_directy();
  inline void clear_has_directy();
  inline void set_has_terrainmapid();
  inline void clear_has_terrainmapid();
  inline void set_has_eventnum();
  inline void clear_has_eventnum();
  inline void set_has_monsterhp();
  inline void clear_has_monsterhp();
  inline void set_has_doneeventnum();
  inline void clear_has_doneeventnum();
  inline void set_has_mapexpiretime();
  inline void clear_has_mapexpiretime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::std::string* mapname_;
  ::google::protobuf::uint32 maptid_;
  ::google::protobuf::int32 startx_;
  ::google::protobuf::int32 starty_;
  ::google::protobuf::int32 directx_;
  ::google::protobuf::RepeatedPtrField< ::pb::AdventureLayer > layerarr_;
  ::google::protobuf::int32 directy_;
  ::google::protobuf::uint32 terrainmapid_;
  ::google::protobuf::uint64 monsterhp_;
  ::google::protobuf::uint32 eventnum_;
  ::google::protobuf::uint32 doneeventnum_;
  ::google::protobuf::RepeatedPtrField< ::pb::TransferObject > transferobjarr_;
  ::google::protobuf::uint64 mapexpiretime_;
  friend void  protobuf_AddDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_AssignDesc_module_2fAdventureMap_2eproto();
  friend void protobuf_ShutdownFile_module_2fAdventureMap_2eproto();

  void InitAsDefaultInstance();
  static AdventureMap* default_instance_;
};
// ===================================================================


// ===================================================================

// AdventureBlock

// optional int32 X = 1;
inline bool AdventureBlock::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureBlock::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureBlock::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureBlock::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 AdventureBlock::x() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBlock.X)
  return x_;
}
inline void AdventureBlock::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBlock.X)
}

// optional int32 Y = 2;
inline bool AdventureBlock::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureBlock::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureBlock::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureBlock::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 AdventureBlock::y() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBlock.Y)
  return y_;
}
inline void AdventureBlock::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBlock.Y)
}

// optional bool IsPass = 3;
inline bool AdventureBlock::has_ispass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdventureBlock::set_has_ispass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdventureBlock::clear_has_ispass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdventureBlock::clear_ispass() {
  ispass_ = false;
  clear_has_ispass();
}
inline bool AdventureBlock::ispass() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBlock.IsPass)
  return ispass_;
}
inline void AdventureBlock::set_ispass(bool value) {
  set_has_ispass();
  ispass_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBlock.IsPass)
}

// optional uint32 ResId = 4;
inline bool AdventureBlock::has_resid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdventureBlock::set_has_resid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdventureBlock::clear_has_resid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdventureBlock::clear_resid() {
  resid_ = 0u;
  clear_has_resid();
}
inline ::google::protobuf::uint32 AdventureBlock::resid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBlock.ResId)
  return resid_;
}
inline void AdventureBlock::set_resid(::google::protobuf::uint32 value) {
  set_has_resid();
  resid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBlock.ResId)
}

// optional bool CanPlace = 5;
inline bool AdventureBlock::has_canplace() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdventureBlock::set_has_canplace() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdventureBlock::clear_has_canplace() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdventureBlock::clear_canplace() {
  canplace_ = false;
  clear_has_canplace();
}
inline bool AdventureBlock::canplace() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBlock.CanPlace)
  return canplace_;
}
inline void AdventureBlock::set_canplace(bool value) {
  set_has_canplace();
  canplace_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBlock.CanPlace)
}

// optional uint32 RegionId = 6;
inline bool AdventureBlock::has_regionid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdventureBlock::set_has_regionid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdventureBlock::clear_has_regionid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdventureBlock::clear_regionid() {
  regionid_ = 0u;
  clear_has_regionid();
}
inline ::google::protobuf::uint32 AdventureBlock::regionid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBlock.RegionId)
  return regionid_;
}
inline void AdventureBlock::set_regionid(::google::protobuf::uint32 value) {
  set_has_regionid();
  regionid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBlock.RegionId)
}

// -------------------------------------------------------------------

// AdventureBehaviorKeyValue

// optional string Key = 1;
inline bool AdventureBehaviorKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureBehaviorKeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureBehaviorKeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureBehaviorKeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AdventureBehaviorKeyValue::key() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehaviorKeyValue.Key)
  return *key_;
}
inline void AdventureBehaviorKeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AdventureBehaviorKeyValue.Key)
}
inline void AdventureBehaviorKeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AdventureBehaviorKeyValue.Key)
}
inline void AdventureBehaviorKeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AdventureBehaviorKeyValue.Key)
}
inline ::std::string* AdventureBehaviorKeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AdventureBehaviorKeyValue.Key)
  return key_;
}
inline ::std::string* AdventureBehaviorKeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdventureBehaviorKeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureBehaviorKeyValue.Key)
}

// optional string Value = 2;
inline bool AdventureBehaviorKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureBehaviorKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureBehaviorKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureBehaviorKeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AdventureBehaviorKeyValue::value() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehaviorKeyValue.Value)
  return *value_;
}
inline void AdventureBehaviorKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AdventureBehaviorKeyValue.Value)
}
inline void AdventureBehaviorKeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AdventureBehaviorKeyValue.Value)
}
inline void AdventureBehaviorKeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AdventureBehaviorKeyValue.Value)
}
inline ::std::string* AdventureBehaviorKeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AdventureBehaviorKeyValue.Value)
  return value_;
}
inline ::std::string* AdventureBehaviorKeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdventureBehaviorKeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureBehaviorKeyValue.Value)
}

// optional int32 Type = 3;
inline bool AdventureBehaviorKeyValue::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdventureBehaviorKeyValue::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdventureBehaviorKeyValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdventureBehaviorKeyValue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AdventureBehaviorKeyValue::type() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehaviorKeyValue.Type)
  return type_;
}
inline void AdventureBehaviorKeyValue::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBehaviorKeyValue.Type)
}

// -------------------------------------------------------------------

// AdventureBehaviorNode

// optional uint32 NodeId = 1;
inline bool AdventureBehaviorNode::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureBehaviorNode::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureBehaviorNode::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureBehaviorNode::clear_nodeid() {
  nodeid_ = 0u;
  clear_has_nodeid();
}
inline ::google::protobuf::uint32 AdventureBehaviorNode::nodeid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehaviorNode.NodeId)
  return nodeid_;
}
inline void AdventureBehaviorNode::set_nodeid(::google::protobuf::uint32 value) {
  set_has_nodeid();
  nodeid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBehaviorNode.NodeId)
}

// repeated .pb.AdventureBehaviorKeyValue Values = 2;
inline int AdventureBehaviorNode::values_size() const {
  return values_.size();
}
inline void AdventureBehaviorNode::clear_values() {
  values_.Clear();
}
inline const ::pb::AdventureBehaviorKeyValue& AdventureBehaviorNode::values(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehaviorNode.Values)
  return values_.Get(index);
}
inline ::pb::AdventureBehaviorKeyValue* AdventureBehaviorNode::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureBehaviorNode.Values)
  return values_.Mutable(index);
}
inline ::pb::AdventureBehaviorKeyValue* AdventureBehaviorNode::add_values() {
  // @@protoc_insertion_point(field_add:pb.AdventureBehaviorNode.Values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorKeyValue >&
AdventureBehaviorNode::values() const {
  // @@protoc_insertion_point(field_list:pb.AdventureBehaviorNode.Values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorKeyValue >*
AdventureBehaviorNode::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureBehaviorNode.Values)
  return &values_;
}

// -------------------------------------------------------------------

// AdventureBehavior

// optional uint32 BehaviorId = 1;
inline bool AdventureBehavior::has_behaviorid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureBehavior::set_has_behaviorid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureBehavior::clear_has_behaviorid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureBehavior::clear_behaviorid() {
  behaviorid_ = 0u;
  clear_has_behaviorid();
}
inline ::google::protobuf::uint32 AdventureBehavior::behaviorid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehavior.BehaviorId)
  return behaviorid_;
}
inline void AdventureBehavior::set_behaviorid(::google::protobuf::uint32 value) {
  set_has_behaviorid();
  behaviorid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBehavior.BehaviorId)
}

// repeated .pb.AdventureBehaviorNode NodeArr = 2;
inline int AdventureBehavior::nodearr_size() const {
  return nodearr_.size();
}
inline void AdventureBehavior::clear_nodearr() {
  nodearr_.Clear();
}
inline const ::pb::AdventureBehaviorNode& AdventureBehavior::nodearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureBehavior.NodeArr)
  return nodearr_.Get(index);
}
inline ::pb::AdventureBehaviorNode* AdventureBehavior::mutable_nodearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureBehavior.NodeArr)
  return nodearr_.Mutable(index);
}
inline ::pb::AdventureBehaviorNode* AdventureBehavior::add_nodearr() {
  // @@protoc_insertion_point(field_add:pb.AdventureBehavior.NodeArr)
  return nodearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorNode >&
AdventureBehavior::nodearr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureBehavior.NodeArr)
  return nodearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBehaviorNode >*
AdventureBehavior::mutable_nodearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureBehavior.NodeArr)
  return &nodearr_;
}

// -------------------------------------------------------------------

// UserEventInfo

// optional uint64 Uid = 1;
inline bool UserEventInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserEventInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserEventInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserEventInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserEventInfo::uid() const {
  // @@protoc_insertion_point(field_get:pb.UserEventInfo.Uid)
  return uid_;
}
inline void UserEventInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:pb.UserEventInfo.Uid)
}

// optional uint32 ChoseIndex = 2;
inline bool UserEventInfo::has_choseindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserEventInfo::set_has_choseindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserEventInfo::clear_has_choseindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserEventInfo::clear_choseindex() {
  choseindex_ = 0u;
  clear_has_choseindex();
}
inline ::google::protobuf::uint32 UserEventInfo::choseindex() const {
  // @@protoc_insertion_point(field_get:pb.UserEventInfo.ChoseIndex)
  return choseindex_;
}
inline void UserEventInfo::set_choseindex(::google::protobuf::uint32 value) {
  set_has_choseindex();
  choseindex_ = value;
  // @@protoc_insertion_point(field_set:pb.UserEventInfo.ChoseIndex)
}

// -------------------------------------------------------------------

// AdventureEvent

// optional uint32 EventId = 1;
inline bool AdventureEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureEvent::clear_eventid() {
  eventid_ = 0u;
  clear_has_eventid();
}
inline ::google::protobuf::uint32 AdventureEvent::eventid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.EventId)
  return eventid_;
}
inline void AdventureEvent::set_eventid(::google::protobuf::uint32 value) {
  set_has_eventid();
  eventid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.EventId)
}

// optional .pb.EEventStatus EventStatus = 2;
inline bool AdventureEvent::has_eventstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureEvent::set_has_eventstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureEvent::clear_has_eventstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureEvent::clear_eventstatus() {
  eventstatus_ = 0;
  clear_has_eventstatus();
}
inline ::pb::EEventStatus AdventureEvent::eventstatus() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.EventStatus)
  return static_cast< ::pb::EEventStatus >(eventstatus_);
}
inline void AdventureEvent::set_eventstatus(::pb::EEventStatus value) {
  assert(::pb::EEventStatus_IsValid(value));
  set_has_eventstatus();
  eventstatus_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.EventStatus)
}

// optional .pb.AdventureBehavior Behavior = 3;
inline bool AdventureEvent::has_behavior() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdventureEvent::set_has_behavior() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdventureEvent::clear_has_behavior() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdventureEvent::clear_behavior() {
  if (behavior_ != NULL) behavior_->::pb::AdventureBehavior::Clear();
  clear_has_behavior();
}
inline const ::pb::AdventureBehavior& AdventureEvent::behavior() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.Behavior)
  return behavior_ != NULL ? *behavior_ : *default_instance_->behavior_;
}
inline ::pb::AdventureBehavior* AdventureEvent::mutable_behavior() {
  set_has_behavior();
  if (behavior_ == NULL) behavior_ = new ::pb::AdventureBehavior;
  // @@protoc_insertion_point(field_mutable:pb.AdventureEvent.Behavior)
  return behavior_;
}
inline ::pb::AdventureBehavior* AdventureEvent::release_behavior() {
  clear_has_behavior();
  ::pb::AdventureBehavior* temp = behavior_;
  behavior_ = NULL;
  return temp;
}
inline void AdventureEvent::set_allocated_behavior(::pb::AdventureBehavior* behavior) {
  delete behavior_;
  behavior_ = behavior;
  if (behavior) {
    set_has_behavior();
  } else {
    clear_has_behavior();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureEvent.Behavior)
}

// repeated .pb.UserEventInfo UserEventInfoArr = 4;
inline int AdventureEvent::usereventinfoarr_size() const {
  return usereventinfoarr_.size();
}
inline void AdventureEvent::clear_usereventinfoarr() {
  usereventinfoarr_.Clear();
}
inline const ::pb::UserEventInfo& AdventureEvent::usereventinfoarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.UserEventInfoArr)
  return usereventinfoarr_.Get(index);
}
inline ::pb::UserEventInfo* AdventureEvent::mutable_usereventinfoarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureEvent.UserEventInfoArr)
  return usereventinfoarr_.Mutable(index);
}
inline ::pb::UserEventInfo* AdventureEvent::add_usereventinfoarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureEvent.UserEventInfoArr)
  return usereventinfoarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::UserEventInfo >&
AdventureEvent::usereventinfoarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureEvent.UserEventInfoArr)
  return usereventinfoarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::UserEventInfo >*
AdventureEvent::mutable_usereventinfoarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureEvent.UserEventInfoArr)
  return &usereventinfoarr_;
}

// repeated uint32 BattleinfoIdArr = 5;
inline int AdventureEvent::battleinfoidarr_size() const {
  return battleinfoidarr_.size();
}
inline void AdventureEvent::clear_battleinfoidarr() {
  battleinfoidarr_.Clear();
}
inline ::google::protobuf::uint32 AdventureEvent::battleinfoidarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.BattleinfoIdArr)
  return battleinfoidarr_.Get(index);
}
inline void AdventureEvent::set_battleinfoidarr(int index, ::google::protobuf::uint32 value) {
  battleinfoidarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.BattleinfoIdArr)
}
inline void AdventureEvent::add_battleinfoidarr(::google::protobuf::uint32 value) {
  battleinfoidarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AdventureEvent.BattleinfoIdArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AdventureEvent::battleinfoidarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureEvent.BattleinfoIdArr)
  return battleinfoidarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AdventureEvent::mutable_battleinfoidarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureEvent.BattleinfoIdArr)
  return &battleinfoidarr_;
}

// optional uint32 AnswerId = 6;
inline bool AdventureEvent::has_answerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdventureEvent::set_has_answerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdventureEvent::clear_has_answerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdventureEvent::clear_answerid() {
  answerid_ = 0u;
  clear_has_answerid();
}
inline ::google::protobuf::uint32 AdventureEvent::answerid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.AnswerId)
  return answerid_;
}
inline void AdventureEvent::set_answerid(::google::protobuf::uint32 value) {
  set_has_answerid();
  answerid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.AnswerId)
}

// optional uint32 StateValue = 7;
inline bool AdventureEvent::has_statevalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdventureEvent::set_has_statevalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdventureEvent::clear_has_statevalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdventureEvent::clear_statevalue() {
  statevalue_ = 0u;
  clear_has_statevalue();
}
inline ::google::protobuf::uint32 AdventureEvent::statevalue() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.StateValue)
  return statevalue_;
}
inline void AdventureEvent::set_statevalue(::google::protobuf::uint32 value) {
  set_has_statevalue();
  statevalue_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.StateValue)
}

// optional uint32 DoneValue = 8;
inline bool AdventureEvent::has_donevalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AdventureEvent::set_has_donevalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AdventureEvent::clear_has_donevalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AdventureEvent::clear_donevalue() {
  donevalue_ = 0u;
  clear_has_donevalue();
}
inline ::google::protobuf::uint32 AdventureEvent::donevalue() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.DoneValue)
  return donevalue_;
}
inline void AdventureEvent::set_donevalue(::google::protobuf::uint32 value) {
  set_has_donevalue();
  donevalue_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.DoneValue)
}

// repeated int32 RewardInfo = 9;
inline int AdventureEvent::rewardinfo_size() const {
  return rewardinfo_.size();
}
inline void AdventureEvent::clear_rewardinfo() {
  rewardinfo_.Clear();
}
inline ::google::protobuf::int32 AdventureEvent::rewardinfo(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.RewardInfo)
  return rewardinfo_.Get(index);
}
inline void AdventureEvent::set_rewardinfo(int index, ::google::protobuf::int32 value) {
  rewardinfo_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.RewardInfo)
}
inline void AdventureEvent::add_rewardinfo(::google::protobuf::int32 value) {
  rewardinfo_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AdventureEvent.RewardInfo)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AdventureEvent::rewardinfo() const {
  // @@protoc_insertion_point(field_list:pb.AdventureEvent.RewardInfo)
  return rewardinfo_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AdventureEvent::mutable_rewardinfo() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureEvent.RewardInfo)
  return &rewardinfo_;
}

// optional uint64 AnswerStartTime = 10;
inline bool AdventureEvent::has_answerstarttime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AdventureEvent::set_has_answerstarttime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AdventureEvent::clear_has_answerstarttime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AdventureEvent::clear_answerstarttime() {
  answerstarttime_ = GOOGLE_ULONGLONG(0);
  clear_has_answerstarttime();
}
inline ::google::protobuf::uint64 AdventureEvent::answerstarttime() const {
  // @@protoc_insertion_point(field_get:pb.AdventureEvent.AnswerStartTime)
  return answerstarttime_;
}
inline void AdventureEvent::set_answerstarttime(::google::protobuf::uint64 value) {
  set_has_answerstarttime();
  answerstarttime_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureEvent.AnswerStartTime)
}

// -------------------------------------------------------------------

// AdventureObject

// optional int32 X = 1;
inline bool AdventureObject::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureObject::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureObject::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureObject::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 AdventureObject::x() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.X)
  return x_;
}
inline void AdventureObject::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureObject.X)
}

// optional int32 Y = 2;
inline bool AdventureObject::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureObject::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureObject::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureObject::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 AdventureObject::y() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.Y)
  return y_;
}
inline void AdventureObject::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureObject.Y)
}

// optional uint32 ObjectTid = 3;
inline bool AdventureObject::has_objecttid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdventureObject::set_has_objecttid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdventureObject::clear_has_objecttid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdventureObject::clear_objecttid() {
  objecttid_ = 0u;
  clear_has_objecttid();
}
inline ::google::protobuf::uint32 AdventureObject::objecttid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.ObjectTid)
  return objecttid_;
}
inline void AdventureObject::set_objecttid(::google::protobuf::uint32 value) {
  set_has_objecttid();
  objecttid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureObject.ObjectTid)
}

// optional string ModelName = 4;
inline bool AdventureObject::has_modelname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdventureObject::set_has_modelname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdventureObject::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdventureObject::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& AdventureObject::modelname() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.ModelName)
  return *modelname_;
}
inline void AdventureObject::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AdventureObject.ModelName)
}
inline void AdventureObject::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AdventureObject.ModelName)
}
inline void AdventureObject::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AdventureObject.ModelName)
}
inline ::std::string* AdventureObject::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AdventureObject.ModelName)
  return modelname_;
}
inline ::std::string* AdventureObject::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdventureObject::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureObject.ModelName)
}

// optional .pb.PbVector3 Scale = 5;
inline bool AdventureObject::has_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdventureObject::set_has_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdventureObject::clear_has_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdventureObject::clear_scale() {
  if (scale_ != NULL) scale_->::pb::PbVector3::Clear();
  clear_has_scale();
}
inline const ::pb::PbVector3& AdventureObject::scale() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.Scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::pb::PbVector3* AdventureObject::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::pb::PbVector3;
  // @@protoc_insertion_point(field_mutable:pb.AdventureObject.Scale)
  return scale_;
}
inline ::pb::PbVector3* AdventureObject::release_scale() {
  clear_has_scale();
  ::pb::PbVector3* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void AdventureObject::set_allocated_scale(::pb::PbVector3* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureObject.Scale)
}

// optional .pb.AdventureEvent Event = 6;
inline bool AdventureObject::has_event() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdventureObject::set_has_event() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdventureObject::clear_has_event() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdventureObject::clear_event() {
  if (event_ != NULL) event_->::pb::AdventureEvent::Clear();
  clear_has_event();
}
inline const ::pb::AdventureEvent& AdventureObject::event() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.Event)
  return event_ != NULL ? *event_ : *default_instance_->event_;
}
inline ::pb::AdventureEvent* AdventureObject::mutable_event() {
  set_has_event();
  if (event_ == NULL) event_ = new ::pb::AdventureEvent;
  // @@protoc_insertion_point(field_mutable:pb.AdventureObject.Event)
  return event_;
}
inline ::pb::AdventureEvent* AdventureObject::release_event() {
  clear_has_event();
  ::pb::AdventureEvent* temp = event_;
  event_ = NULL;
  return temp;
}
inline void AdventureObject::set_allocated_event(::pb::AdventureEvent* event) {
  delete event_;
  event_ = event;
  if (event) {
    set_has_event();
  } else {
    clear_has_event();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureObject.Event)
}

// optional uint32 SortingOrder = 7;
inline bool AdventureObject::has_sortingorder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdventureObject::set_has_sortingorder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdventureObject::clear_has_sortingorder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdventureObject::clear_sortingorder() {
  sortingorder_ = 0u;
  clear_has_sortingorder();
}
inline ::google::protobuf::uint32 AdventureObject::sortingorder() const {
  // @@protoc_insertion_point(field_get:pb.AdventureObject.SortingOrder)
  return sortingorder_;
}
inline void AdventureObject::set_sortingorder(::google::protobuf::uint32 value) {
  set_has_sortingorder();
  sortingorder_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureObject.SortingOrder)
}

// -------------------------------------------------------------------

// AdventureBridge

// optional int32 X1 = 1;
inline bool AdventureBridge::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureBridge::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureBridge::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureBridge::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline ::google::protobuf::int32 AdventureBridge::x1() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBridge.X1)
  return x1_;
}
inline void AdventureBridge::set_x1(::google::protobuf::int32 value) {
  set_has_x1();
  x1_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBridge.X1)
}

// optional int32 Y1 = 2;
inline bool AdventureBridge::has_y1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureBridge::set_has_y1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureBridge::clear_has_y1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureBridge::clear_y1() {
  y1_ = 0;
  clear_has_y1();
}
inline ::google::protobuf::int32 AdventureBridge::y1() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBridge.Y1)
  return y1_;
}
inline void AdventureBridge::set_y1(::google::protobuf::int32 value) {
  set_has_y1();
  y1_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBridge.Y1)
}

// optional int32 X2 = 3;
inline bool AdventureBridge::has_x2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdventureBridge::set_has_x2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdventureBridge::clear_has_x2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdventureBridge::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline ::google::protobuf::int32 AdventureBridge::x2() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBridge.X2)
  return x2_;
}
inline void AdventureBridge::set_x2(::google::protobuf::int32 value) {
  set_has_x2();
  x2_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBridge.X2)
}

// optional int32 Y2 = 4;
inline bool AdventureBridge::has_y2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdventureBridge::set_has_y2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdventureBridge::clear_has_y2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdventureBridge::clear_y2() {
  y2_ = 0;
  clear_has_y2();
}
inline ::google::protobuf::int32 AdventureBridge::y2() const {
  // @@protoc_insertion_point(field_get:pb.AdventureBridge.Y2)
  return y2_;
}
inline void AdventureBridge::set_y2(::google::protobuf::int32 value) {
  set_has_y2();
  y2_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureBridge.Y2)
}

// -------------------------------------------------------------------

// AdventureGimmickDoor

// optional int32 KeyIndex = 1;
inline bool AdventureGimmickDoor::has_keyindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureGimmickDoor::set_has_keyindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureGimmickDoor::clear_has_keyindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureGimmickDoor::clear_keyindex() {
  keyindex_ = 0;
  clear_has_keyindex();
}
inline ::google::protobuf::int32 AdventureGimmickDoor::keyindex() const {
  // @@protoc_insertion_point(field_get:pb.AdventureGimmickDoor.KeyIndex)
  return keyindex_;
}
inline void AdventureGimmickDoor::set_keyindex(::google::protobuf::int32 value) {
  set_has_keyindex();
  keyindex_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureGimmickDoor.KeyIndex)
}

// optional int32 DoorIndex = 2;
inline bool AdventureGimmickDoor::has_doorindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureGimmickDoor::set_has_doorindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureGimmickDoor::clear_has_doorindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureGimmickDoor::clear_doorindex() {
  doorindex_ = 0;
  clear_has_doorindex();
}
inline ::google::protobuf::int32 AdventureGimmickDoor::doorindex() const {
  // @@protoc_insertion_point(field_get:pb.AdventureGimmickDoor.DoorIndex)
  return doorindex_;
}
inline void AdventureGimmickDoor::set_doorindex(::google::protobuf::int32 value) {
  set_has_doorindex();
  doorindex_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureGimmickDoor.DoorIndex)
}

// -------------------------------------------------------------------

// AdventureTaskNpc

// optional int32 NpcIndex = 1;
inline bool AdventureTaskNpc::has_npcindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureTaskNpc::set_has_npcindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureTaskNpc::clear_has_npcindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureTaskNpc::clear_npcindex() {
  npcindex_ = 0;
  clear_has_npcindex();
}
inline ::google::protobuf::int32 AdventureTaskNpc::npcindex() const {
  // @@protoc_insertion_point(field_get:pb.AdventureTaskNpc.NpcIndex)
  return npcindex_;
}
inline void AdventureTaskNpc::set_npcindex(::google::protobuf::int32 value) {
  set_has_npcindex();
  npcindex_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureTaskNpc.NpcIndex)
}

// repeated int32 ObjIndexArr = 2;
inline int AdventureTaskNpc::objindexarr_size() const {
  return objindexarr_.size();
}
inline void AdventureTaskNpc::clear_objindexarr() {
  objindexarr_.Clear();
}
inline ::google::protobuf::int32 AdventureTaskNpc::objindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureTaskNpc.ObjIndexArr)
  return objindexarr_.Get(index);
}
inline void AdventureTaskNpc::set_objindexarr(int index, ::google::protobuf::int32 value) {
  objindexarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AdventureTaskNpc.ObjIndexArr)
}
inline void AdventureTaskNpc::add_objindexarr(::google::protobuf::int32 value) {
  objindexarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AdventureTaskNpc.ObjIndexArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AdventureTaskNpc::objindexarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureTaskNpc.ObjIndexArr)
  return objindexarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AdventureTaskNpc::mutable_objindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureTaskNpc.ObjIndexArr)
  return &objindexarr_;
}

// -------------------------------------------------------------------

// AdventureMystery

// optional int32 MysteryDoorIndex = 1;
inline bool AdventureMystery::has_mysterydoorindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureMystery::set_has_mysterydoorindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureMystery::clear_has_mysterydoorindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureMystery::clear_mysterydoorindex() {
  mysterydoorindex_ = 0;
  clear_has_mysterydoorindex();
}
inline ::google::protobuf::int32 AdventureMystery::mysterydoorindex() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.MysteryDoorIndex)
  return mysterydoorindex_;
}
inline void AdventureMystery::set_mysterydoorindex(::google::protobuf::int32 value) {
  set_has_mysterydoorindex();
  mysterydoorindex_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.MysteryDoorIndex)
}

// repeated int32 ObjIndexArr = 2;
inline int AdventureMystery::objindexarr_size() const {
  return objindexarr_.size();
}
inline void AdventureMystery::clear_objindexarr() {
  objindexarr_.Clear();
}
inline ::google::protobuf::int32 AdventureMystery::objindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.ObjIndexArr)
  return objindexarr_.Get(index);
}
inline void AdventureMystery::set_objindexarr(int index, ::google::protobuf::int32 value) {
  objindexarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.ObjIndexArr)
}
inline void AdventureMystery::add_objindexarr(::google::protobuf::int32 value) {
  objindexarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AdventureMystery.ObjIndexArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AdventureMystery::objindexarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureMystery.ObjIndexArr)
  return objindexarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AdventureMystery::mutable_objindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureMystery.ObjIndexArr)
  return &objindexarr_;
}

// repeated int32 TargetObjIndexArr = 3;
inline int AdventureMystery::targetobjindexarr_size() const {
  return targetobjindexarr_.size();
}
inline void AdventureMystery::clear_targetobjindexarr() {
  targetobjindexarr_.Clear();
}
inline ::google::protobuf::int32 AdventureMystery::targetobjindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.TargetObjIndexArr)
  return targetobjindexarr_.Get(index);
}
inline void AdventureMystery::set_targetobjindexarr(int index, ::google::protobuf::int32 value) {
  targetobjindexarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.TargetObjIndexArr)
}
inline void AdventureMystery::add_targetobjindexarr(::google::protobuf::int32 value) {
  targetobjindexarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AdventureMystery.TargetObjIndexArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AdventureMystery::targetobjindexarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureMystery.TargetObjIndexArr)
  return targetobjindexarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AdventureMystery::mutable_targetobjindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureMystery.TargetObjIndexArr)
  return &targetobjindexarr_;
}

// repeated int32 NonTargetObjIndexArr = 4;
inline int AdventureMystery::nontargetobjindexarr_size() const {
  return nontargetobjindexarr_.size();
}
inline void AdventureMystery::clear_nontargetobjindexarr() {
  nontargetobjindexarr_.Clear();
}
inline ::google::protobuf::int32 AdventureMystery::nontargetobjindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.NonTargetObjIndexArr)
  return nontargetobjindexarr_.Get(index);
}
inline void AdventureMystery::set_nontargetobjindexarr(int index, ::google::protobuf::int32 value) {
  nontargetobjindexarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.NonTargetObjIndexArr)
}
inline void AdventureMystery::add_nontargetobjindexarr(::google::protobuf::int32 value) {
  nontargetobjindexarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AdventureMystery.NonTargetObjIndexArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AdventureMystery::nontargetobjindexarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureMystery.NonTargetObjIndexArr)
  return nontargetobjindexarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AdventureMystery::mutable_nontargetobjindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureMystery.NonTargetObjIndexArr)
  return &nontargetobjindexarr_;
}

// optional uint32 MysteryLayerIndex = 5;
inline bool AdventureMystery::has_mysterylayerindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdventureMystery::set_has_mysterylayerindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdventureMystery::clear_has_mysterylayerindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdventureMystery::clear_mysterylayerindex() {
  mysterylayerindex_ = 0u;
  clear_has_mysterylayerindex();
}
inline ::google::protobuf::uint32 AdventureMystery::mysterylayerindex() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.MysteryLayerIndex)
  return mysterylayerindex_;
}
inline void AdventureMystery::set_mysterylayerindex(::google::protobuf::uint32 value) {
  set_has_mysterylayerindex();
  mysterylayerindex_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.MysteryLayerIndex)
}

// optional uint32 IsOpen = 6;
inline bool AdventureMystery::has_isopen() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdventureMystery::set_has_isopen() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdventureMystery::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdventureMystery::clear_isopen() {
  isopen_ = 0u;
  clear_has_isopen();
}
inline ::google::protobuf::uint32 AdventureMystery::isopen() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.IsOpen)
  return isopen_;
}
inline void AdventureMystery::set_isopen(::google::protobuf::uint32 value) {
  set_has_isopen();
  isopen_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.IsOpen)
}

// optional int32 CipherMonsterIndex = 7;
inline bool AdventureMystery::has_ciphermonsterindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdventureMystery::set_has_ciphermonsterindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdventureMystery::clear_has_ciphermonsterindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdventureMystery::clear_ciphermonsterindex() {
  ciphermonsterindex_ = 0;
  clear_has_ciphermonsterindex();
}
inline ::google::protobuf::int32 AdventureMystery::ciphermonsterindex() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMystery.CipherMonsterIndex)
  return ciphermonsterindex_;
}
inline void AdventureMystery::set_ciphermonsterindex(::google::protobuf::int32 value) {
  set_has_ciphermonsterindex();
  ciphermonsterindex_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMystery.CipherMonsterIndex)
}

// -------------------------------------------------------------------

// TransferObject

// optional uint32 ObjectLayerIndex = 1;
inline bool TransferObject::has_objectlayerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferObject::set_has_objectlayerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferObject::clear_has_objectlayerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferObject::clear_objectlayerindex() {
  objectlayerindex_ = 0u;
  clear_has_objectlayerindex();
}
inline ::google::protobuf::uint32 TransferObject::objectlayerindex() const {
  // @@protoc_insertion_point(field_get:pb.TransferObject.ObjectLayerIndex)
  return objectlayerindex_;
}
inline void TransferObject::set_objectlayerindex(::google::protobuf::uint32 value) {
  set_has_objectlayerindex();
  objectlayerindex_ = value;
  // @@protoc_insertion_point(field_set:pb.TransferObject.ObjectLayerIndex)
}

// optional int32 ObjectIndex = 2;
inline bool TransferObject::has_objectindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferObject::set_has_objectindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferObject::clear_has_objectindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferObject::clear_objectindex() {
  objectindex_ = 0;
  clear_has_objectindex();
}
inline ::google::protobuf::int32 TransferObject::objectindex() const {
  // @@protoc_insertion_point(field_get:pb.TransferObject.ObjectIndex)
  return objectindex_;
}
inline void TransferObject::set_objectindex(::google::protobuf::int32 value) {
  set_has_objectindex();
  objectindex_ = value;
  // @@protoc_insertion_point(field_set:pb.TransferObject.ObjectIndex)
}

// optional uint32 TransferLayerIndex = 3;
inline bool TransferObject::has_transferlayerindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferObject::set_has_transferlayerindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferObject::clear_has_transferlayerindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferObject::clear_transferlayerindex() {
  transferlayerindex_ = 0u;
  clear_has_transferlayerindex();
}
inline ::google::protobuf::uint32 TransferObject::transferlayerindex() const {
  // @@protoc_insertion_point(field_get:pb.TransferObject.TransferLayerIndex)
  return transferlayerindex_;
}
inline void TransferObject::set_transferlayerindex(::google::protobuf::uint32 value) {
  set_has_transferlayerindex();
  transferlayerindex_ = value;
  // @@protoc_insertion_point(field_set:pb.TransferObject.TransferLayerIndex)
}

// -------------------------------------------------------------------

// TrapResetPoint

// optional uint32 TrapId = 1;
inline bool TrapResetPoint::has_trapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrapResetPoint::set_has_trapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrapResetPoint::clear_has_trapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrapResetPoint::clear_trapid() {
  trapid_ = 0u;
  clear_has_trapid();
}
inline ::google::protobuf::uint32 TrapResetPoint::trapid() const {
  // @@protoc_insertion_point(field_get:pb.TrapResetPoint.TrapId)
  return trapid_;
}
inline void TrapResetPoint::set_trapid(::google::protobuf::uint32 value) {
  set_has_trapid();
  trapid_ = value;
  // @@protoc_insertion_point(field_set:pb.TrapResetPoint.TrapId)
}

// optional .pb.PbVector2_Int Pos = 2;
inline bool TrapResetPoint::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrapResetPoint::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrapResetPoint::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrapResetPoint::clear_pos() {
  if (pos_ != NULL) pos_->::pb::PbVector2_Int::Clear();
  clear_has_pos();
}
inline const ::pb::PbVector2_Int& TrapResetPoint::pos() const {
  // @@protoc_insertion_point(field_get:pb.TrapResetPoint.Pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::pb::PbVector2_Int* TrapResetPoint::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::pb::PbVector2_Int;
  // @@protoc_insertion_point(field_mutable:pb.TrapResetPoint.Pos)
  return pos_;
}
inline ::pb::PbVector2_Int* TrapResetPoint::release_pos() {
  clear_has_pos();
  ::pb::PbVector2_Int* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void TrapResetPoint::set_allocated_pos(::pb::PbVector2_Int* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TrapResetPoint.Pos)
}

// -------------------------------------------------------------------

// AdventureLayer

// repeated .pb.AdventureBlock BlockArr = 1;
inline int AdventureLayer::blockarr_size() const {
  return blockarr_.size();
}
inline void AdventureLayer::clear_blockarr() {
  blockarr_.Clear();
}
inline const ::pb::AdventureBlock& AdventureLayer::blockarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.BlockArr)
  return blockarr_.Get(index);
}
inline ::pb::AdventureBlock* AdventureLayer::mutable_blockarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.BlockArr)
  return blockarr_.Mutable(index);
}
inline ::pb::AdventureBlock* AdventureLayer::add_blockarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureLayer.BlockArr)
  return blockarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBlock >&
AdventureLayer::blockarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureLayer.BlockArr)
  return blockarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBlock >*
AdventureLayer::mutable_blockarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureLayer.BlockArr)
  return &blockarr_;
}

// repeated .pb.AdventureObject ObjectArr = 2;
inline int AdventureLayer::objectarr_size() const {
  return objectarr_.size();
}
inline void AdventureLayer::clear_objectarr() {
  objectarr_.Clear();
}
inline const ::pb::AdventureObject& AdventureLayer::objectarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.ObjectArr)
  return objectarr_.Get(index);
}
inline ::pb::AdventureObject* AdventureLayer::mutable_objectarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.ObjectArr)
  return objectarr_.Mutable(index);
}
inline ::pb::AdventureObject* AdventureLayer::add_objectarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureLayer.ObjectArr)
  return objectarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureObject >&
AdventureLayer::objectarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureLayer.ObjectArr)
  return objectarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureObject >*
AdventureLayer::mutable_objectarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureLayer.ObjectArr)
  return &objectarr_;
}

// repeated .pb.AdventureBridge BridgeArr = 3;
inline int AdventureLayer::bridgearr_size() const {
  return bridgearr_.size();
}
inline void AdventureLayer::clear_bridgearr() {
  bridgearr_.Clear();
}
inline const ::pb::AdventureBridge& AdventureLayer::bridgearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.BridgeArr)
  return bridgearr_.Get(index);
}
inline ::pb::AdventureBridge* AdventureLayer::mutable_bridgearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.BridgeArr)
  return bridgearr_.Mutable(index);
}
inline ::pb::AdventureBridge* AdventureLayer::add_bridgearr() {
  // @@protoc_insertion_point(field_add:pb.AdventureLayer.BridgeArr)
  return bridgearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureBridge >&
AdventureLayer::bridgearr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureLayer.BridgeArr)
  return bridgearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureBridge >*
AdventureLayer::mutable_bridgearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureLayer.BridgeArr)
  return &bridgearr_;
}

// optional .pb.PbVector2_Int LayerSize = 4;
inline bool AdventureLayer::has_layersize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdventureLayer::set_has_layersize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdventureLayer::clear_has_layersize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdventureLayer::clear_layersize() {
  if (layersize_ != NULL) layersize_->::pb::PbVector2_Int::Clear();
  clear_has_layersize();
}
inline const ::pb::PbVector2_Int& AdventureLayer::layersize() const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.LayerSize)
  return layersize_ != NULL ? *layersize_ : *default_instance_->layersize_;
}
inline ::pb::PbVector2_Int* AdventureLayer::mutable_layersize() {
  set_has_layersize();
  if (layersize_ == NULL) layersize_ = new ::pb::PbVector2_Int;
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.LayerSize)
  return layersize_;
}
inline ::pb::PbVector2_Int* AdventureLayer::release_layersize() {
  clear_has_layersize();
  ::pb::PbVector2_Int* temp = layersize_;
  layersize_ = NULL;
  return temp;
}
inline void AdventureLayer::set_allocated_layersize(::pb::PbVector2_Int* layersize) {
  delete layersize_;
  layersize_ = layersize;
  if (layersize) {
    set_has_layersize();
  } else {
    clear_has_layersize();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureLayer.LayerSize)
}

// repeated .pb.AdventureGimmickDoor DoorArr = 5;
inline int AdventureLayer::doorarr_size() const {
  return doorarr_.size();
}
inline void AdventureLayer::clear_doorarr() {
  doorarr_.Clear();
}
inline const ::pb::AdventureGimmickDoor& AdventureLayer::doorarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.DoorArr)
  return doorarr_.Get(index);
}
inline ::pb::AdventureGimmickDoor* AdventureLayer::mutable_doorarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.DoorArr)
  return doorarr_.Mutable(index);
}
inline ::pb::AdventureGimmickDoor* AdventureLayer::add_doorarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureLayer.DoorArr)
  return doorarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureGimmickDoor >&
AdventureLayer::doorarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureLayer.DoorArr)
  return doorarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureGimmickDoor >*
AdventureLayer::mutable_doorarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureLayer.DoorArr)
  return &doorarr_;
}

// optional .pb.AdventureTaskNpc TaskNpc = 6;
inline bool AdventureLayer::has_tasknpc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdventureLayer::set_has_tasknpc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdventureLayer::clear_has_tasknpc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdventureLayer::clear_tasknpc() {
  if (tasknpc_ != NULL) tasknpc_->::pb::AdventureTaskNpc::Clear();
  clear_has_tasknpc();
}
inline const ::pb::AdventureTaskNpc& AdventureLayer::tasknpc() const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.TaskNpc)
  return tasknpc_ != NULL ? *tasknpc_ : *default_instance_->tasknpc_;
}
inline ::pb::AdventureTaskNpc* AdventureLayer::mutable_tasknpc() {
  set_has_tasknpc();
  if (tasknpc_ == NULL) tasknpc_ = new ::pb::AdventureTaskNpc;
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.TaskNpc)
  return tasknpc_;
}
inline ::pb::AdventureTaskNpc* AdventureLayer::release_tasknpc() {
  clear_has_tasknpc();
  ::pb::AdventureTaskNpc* temp = tasknpc_;
  tasknpc_ = NULL;
  return temp;
}
inline void AdventureLayer::set_allocated_tasknpc(::pb::AdventureTaskNpc* tasknpc) {
  delete tasknpc_;
  tasknpc_ = tasknpc;
  if (tasknpc) {
    set_has_tasknpc();
  } else {
    clear_has_tasknpc();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureLayer.TaskNpc)
}

// optional .pb.AdventureMystery MysteryEntry = 7;
inline bool AdventureLayer::has_mysteryentry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdventureLayer::set_has_mysteryentry() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdventureLayer::clear_has_mysteryentry() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdventureLayer::clear_mysteryentry() {
  if (mysteryentry_ != NULL) mysteryentry_->::pb::AdventureMystery::Clear();
  clear_has_mysteryentry();
}
inline const ::pb::AdventureMystery& AdventureLayer::mysteryentry() const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.MysteryEntry)
  return mysteryentry_ != NULL ? *mysteryentry_ : *default_instance_->mysteryentry_;
}
inline ::pb::AdventureMystery* AdventureLayer::mutable_mysteryentry() {
  set_has_mysteryentry();
  if (mysteryentry_ == NULL) mysteryentry_ = new ::pb::AdventureMystery;
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.MysteryEntry)
  return mysteryentry_;
}
inline ::pb::AdventureMystery* AdventureLayer::release_mysteryentry() {
  clear_has_mysteryentry();
  ::pb::AdventureMystery* temp = mysteryentry_;
  mysteryentry_ = NULL;
  return temp;
}
inline void AdventureLayer::set_allocated_mysteryentry(::pb::AdventureMystery* mysteryentry) {
  delete mysteryentry_;
  mysteryentry_ = mysteryentry;
  if (mysteryentry) {
    set_has_mysteryentry();
  } else {
    clear_has_mysteryentry();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureLayer.MysteryEntry)
}

// repeated .pb.PbVector2_Int RoomPosArr = 8;
inline int AdventureLayer::roomposarr_size() const {
  return roomposarr_.size();
}
inline void AdventureLayer::clear_roomposarr() {
  roomposarr_.Clear();
}
inline const ::pb::PbVector2_Int& AdventureLayer::roomposarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.RoomPosArr)
  return roomposarr_.Get(index);
}
inline ::pb::PbVector2_Int* AdventureLayer::mutable_roomposarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.RoomPosArr)
  return roomposarr_.Mutable(index);
}
inline ::pb::PbVector2_Int* AdventureLayer::add_roomposarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureLayer.RoomPosArr)
  return roomposarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >&
AdventureLayer::roomposarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureLayer.RoomPosArr)
  return roomposarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PbVector2_Int >*
AdventureLayer::mutable_roomposarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureLayer.RoomPosArr)
  return &roomposarr_;
}

// repeated .pb.TrapResetPoint TrapPosArr = 9;
inline int AdventureLayer::trapposarr_size() const {
  return trapposarr_.size();
}
inline void AdventureLayer::clear_trapposarr() {
  trapposarr_.Clear();
}
inline const ::pb::TrapResetPoint& AdventureLayer::trapposarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureLayer.TrapPosArr)
  return trapposarr_.Get(index);
}
inline ::pb::TrapResetPoint* AdventureLayer::mutable_trapposarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureLayer.TrapPosArr)
  return trapposarr_.Mutable(index);
}
inline ::pb::TrapResetPoint* AdventureLayer::add_trapposarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureLayer.TrapPosArr)
  return trapposarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TrapResetPoint >&
AdventureLayer::trapposarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureLayer.TrapPosArr)
  return trapposarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TrapResetPoint >*
AdventureLayer::mutable_trapposarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureLayer.TrapPosArr)
  return &trapposarr_;
}

// -------------------------------------------------------------------

// AdventureMap

// optional uint64 Id = 1;
inline bool AdventureMap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdventureMap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdventureMap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdventureMap::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AdventureMap::id() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.Id)
  return id_;
}
inline void AdventureMap::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.Id)
}

// optional uint32 MapTid = 2;
inline bool AdventureMap::has_maptid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdventureMap::set_has_maptid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdventureMap::clear_has_maptid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdventureMap::clear_maptid() {
  maptid_ = 0u;
  clear_has_maptid();
}
inline ::google::protobuf::uint32 AdventureMap::maptid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.MapTid)
  return maptid_;
}
inline void AdventureMap::set_maptid(::google::protobuf::uint32 value) {
  set_has_maptid();
  maptid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.MapTid)
}

// optional string MapName = 3;
inline bool AdventureMap::has_mapname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdventureMap::set_has_mapname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdventureMap::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdventureMap::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& AdventureMap::mapname() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.MapName)
  return *mapname_;
}
inline void AdventureMap::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AdventureMap.MapName)
}
inline void AdventureMap::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AdventureMap.MapName)
}
inline void AdventureMap::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AdventureMap.MapName)
}
inline ::std::string* AdventureMap::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AdventureMap.MapName)
  return mapname_;
}
inline ::std::string* AdventureMap::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdventureMap::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AdventureMap.MapName)
}

// optional int32 StartX = 4;
inline bool AdventureMap::has_startx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdventureMap::set_has_startx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdventureMap::clear_has_startx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdventureMap::clear_startx() {
  startx_ = 0;
  clear_has_startx();
}
inline ::google::protobuf::int32 AdventureMap::startx() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.StartX)
  return startx_;
}
inline void AdventureMap::set_startx(::google::protobuf::int32 value) {
  set_has_startx();
  startx_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.StartX)
}

// optional int32 StartY = 5;
inline bool AdventureMap::has_starty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdventureMap::set_has_starty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdventureMap::clear_has_starty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdventureMap::clear_starty() {
  starty_ = 0;
  clear_has_starty();
}
inline ::google::protobuf::int32 AdventureMap::starty() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.StartY)
  return starty_;
}
inline void AdventureMap::set_starty(::google::protobuf::int32 value) {
  set_has_starty();
  starty_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.StartY)
}

// optional int32 DirectX = 6;
inline bool AdventureMap::has_directx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdventureMap::set_has_directx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdventureMap::clear_has_directx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdventureMap::clear_directx() {
  directx_ = 0;
  clear_has_directx();
}
inline ::google::protobuf::int32 AdventureMap::directx() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.DirectX)
  return directx_;
}
inline void AdventureMap::set_directx(::google::protobuf::int32 value) {
  set_has_directx();
  directx_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.DirectX)
}

// optional int32 DirectY = 7;
inline bool AdventureMap::has_directy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdventureMap::set_has_directy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdventureMap::clear_has_directy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdventureMap::clear_directy() {
  directy_ = 0;
  clear_has_directy();
}
inline ::google::protobuf::int32 AdventureMap::directy() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.DirectY)
  return directy_;
}
inline void AdventureMap::set_directy(::google::protobuf::int32 value) {
  set_has_directy();
  directy_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.DirectY)
}

// repeated .pb.AdventureLayer LayerArr = 8;
inline int AdventureMap::layerarr_size() const {
  return layerarr_.size();
}
inline void AdventureMap::clear_layerarr() {
  layerarr_.Clear();
}
inline const ::pb::AdventureLayer& AdventureMap::layerarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.LayerArr)
  return layerarr_.Get(index);
}
inline ::pb::AdventureLayer* AdventureMap::mutable_layerarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureMap.LayerArr)
  return layerarr_.Mutable(index);
}
inline ::pb::AdventureLayer* AdventureMap::add_layerarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureMap.LayerArr)
  return layerarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AdventureLayer >&
AdventureMap::layerarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureMap.LayerArr)
  return layerarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AdventureLayer >*
AdventureMap::mutable_layerarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureMap.LayerArr)
  return &layerarr_;
}

// optional uint32 TerrainMapId = 9;
inline bool AdventureMap::has_terrainmapid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AdventureMap::set_has_terrainmapid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AdventureMap::clear_has_terrainmapid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AdventureMap::clear_terrainmapid() {
  terrainmapid_ = 0u;
  clear_has_terrainmapid();
}
inline ::google::protobuf::uint32 AdventureMap::terrainmapid() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.TerrainMapId)
  return terrainmapid_;
}
inline void AdventureMap::set_terrainmapid(::google::protobuf::uint32 value) {
  set_has_terrainmapid();
  terrainmapid_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.TerrainMapId)
}

// optional uint32 EventNum = 10;
inline bool AdventureMap::has_eventnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AdventureMap::set_has_eventnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AdventureMap::clear_has_eventnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AdventureMap::clear_eventnum() {
  eventnum_ = 0u;
  clear_has_eventnum();
}
inline ::google::protobuf::uint32 AdventureMap::eventnum() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.EventNum)
  return eventnum_;
}
inline void AdventureMap::set_eventnum(::google::protobuf::uint32 value) {
  set_has_eventnum();
  eventnum_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.EventNum)
}

// optional uint64 MonsterHp = 11;
inline bool AdventureMap::has_monsterhp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AdventureMap::set_has_monsterhp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AdventureMap::clear_has_monsterhp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AdventureMap::clear_monsterhp() {
  monsterhp_ = GOOGLE_ULONGLONG(0);
  clear_has_monsterhp();
}
inline ::google::protobuf::uint64 AdventureMap::monsterhp() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.MonsterHp)
  return monsterhp_;
}
inline void AdventureMap::set_monsterhp(::google::protobuf::uint64 value) {
  set_has_monsterhp();
  monsterhp_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.MonsterHp)
}

// repeated .pb.TransferObject TransferObjArr = 12;
inline int AdventureMap::transferobjarr_size() const {
  return transferobjarr_.size();
}
inline void AdventureMap::clear_transferobjarr() {
  transferobjarr_.Clear();
}
inline const ::pb::TransferObject& AdventureMap::transferobjarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.TransferObjArr)
  return transferobjarr_.Get(index);
}
inline ::pb::TransferObject* AdventureMap::mutable_transferobjarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.AdventureMap.TransferObjArr)
  return transferobjarr_.Mutable(index);
}
inline ::pb::TransferObject* AdventureMap::add_transferobjarr() {
  // @@protoc_insertion_point(field_add:pb.AdventureMap.TransferObjArr)
  return transferobjarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TransferObject >&
AdventureMap::transferobjarr() const {
  // @@protoc_insertion_point(field_list:pb.AdventureMap.TransferObjArr)
  return transferobjarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TransferObject >*
AdventureMap::mutable_transferobjarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.AdventureMap.TransferObjArr)
  return &transferobjarr_;
}

// optional uint32 DoneEventNum = 13;
inline bool AdventureMap::has_doneeventnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AdventureMap::set_has_doneeventnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AdventureMap::clear_has_doneeventnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AdventureMap::clear_doneeventnum() {
  doneeventnum_ = 0u;
  clear_has_doneeventnum();
}
inline ::google::protobuf::uint32 AdventureMap::doneeventnum() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.DoneEventNum)
  return doneeventnum_;
}
inline void AdventureMap::set_doneeventnum(::google::protobuf::uint32 value) {
  set_has_doneeventnum();
  doneeventnum_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.DoneEventNum)
}

// optional uint64 MapExpireTime = 14;
inline bool AdventureMap::has_mapexpiretime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AdventureMap::set_has_mapexpiretime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AdventureMap::clear_has_mapexpiretime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AdventureMap::clear_mapexpiretime() {
  mapexpiretime_ = GOOGLE_ULONGLONG(0);
  clear_has_mapexpiretime();
}
inline ::google::protobuf::uint64 AdventureMap::mapexpiretime() const {
  // @@protoc_insertion_point(field_get:pb.AdventureMap.MapExpireTime)
  return mapexpiretime_;
}
inline void AdventureMap::set_mapexpiretime(::google::protobuf::uint64 value) {
  set_has_mapexpiretime();
  mapexpiretime_ = value;
  // @@protoc_insertion_point(field_set:pb.AdventureMap.MapExpireTime)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::EEventStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EEventStatus>() {
  return ::pb::EEventStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fAdventureMap_2eproto__INCLUDED
