// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/SceneConfGuildWar.proto

#ifndef PROTOBUF_module_2fSceneConfGuildWar_2eproto__INCLUDED
#define PROTOBUF_module_2fSceneConfGuildWar_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
#include "module/SceneConf2d.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fSceneConfGuildWar_2eproto();
void protobuf_AssignDesc_module_2fSceneConfGuildWar_2eproto();
void protobuf_ShutdownFile_module_2fSceneConfGuildWar_2eproto();

class SceneConfGuildWar;

// ===================================================================

/*FOR2LUA
<Record>
	<name>SceneConfGuildWar</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfGuildWar.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SceneConfGuildWar : public ::google::protobuf::Message {
 public:
  SceneConfGuildWar();
  virtual ~SceneConfGuildWar();

  SceneConfGuildWar(const SceneConfGuildWar& from);

  inline SceneConfGuildWar& operator=(const SceneConfGuildWar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneConfGuildWar& default_instance();

  void Swap(SceneConfGuildWar* other);

  // implements Message ----------------------------------------------

  SceneConfGuildWar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneConfGuildWar& from);
  void MergeFrom(const SceneConfGuildWar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string ConfName = 2;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // required string ArtScenePath = 3;
  inline bool has_artscenepath() const;
  inline void clear_artscenepath();
  static const int kArtScenePathFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& artscenepath() const;
  inline void set_artscenepath(const ::std::string& value);
  inline void set_artscenepath(const char* value);
  inline void set_artscenepath(const char* value, size_t size);
  inline ::std::string* mutable_artscenepath();
  inline ::std::string* release_artscenepath();
  inline void set_allocated_artscenepath(::std::string* artscenepath);

  // required .pb.SceneChunkInfo ChunkInfo = 4;
  inline bool has_chunkinfo() const;
  inline void clear_chunkinfo();
  static const int kChunkInfoFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_chunkinfo</name>
  		<replaceName>ChunkInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::SceneChunkInfo& chunkinfo() const;
  inline ::pb::SceneChunkInfo* mutable_chunkinfo();
  inline ::pb::SceneChunkInfo* release_chunkinfo();
  inline void set_allocated_chunkinfo(::pb::SceneChunkInfo* chunkinfo);

  // required .pb.PbRect CameraMoveArea = 5;
  inline bool has_cameramovearea() const;
  inline void clear_cameramovearea();
  static const int kCameraMoveAreaFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_cameramovearea</name>
  		<replaceName>CameraMoveArea</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbRect& cameramovearea() const;
  inline ::pb::PbRect* mutable_cameramovearea();
  inline ::pb::PbRect* release_cameramovearea();
  inline void set_allocated_cameramovearea(::pb::PbRect* cameramovearea);

  // repeated .pb.RectArea2 RectAreaArr = 6;
  inline int rectareaarr_size() const;
  inline void clear_rectareaarr();
  static const int kRectAreaArrFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_rectareaarr</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>rectareaarr_size</name>
  		<replaceName>RectAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::RectArea2& rectareaarr(int index) const;
  inline ::pb::RectArea2* mutable_rectareaarr(int index);
  inline ::pb::RectArea2* add_rectareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >&
      rectareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >*
      mutable_rectareaarr();

  // repeated .pb.CustomArea2 CustomAreaArr = 7;
  inline int customareaarr_size() const;
  inline void clear_customareaarr();
  static const int kCustomAreaArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_customareaarr</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>customareaarr_size</name>
  		<replaceName>CustomAreaArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CustomArea2& customareaarr(int index) const;
  inline ::pb::CustomArea2* mutable_customareaarr(int index);
  inline ::pb::CustomArea2* add_customareaarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >&
      customareaarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >*
      mutable_customareaarr();

  // repeated .pb.AnimAsset2 AnimAssetArr = 8;
  inline int animassetarr_size() const;
  inline void clear_animassetarr();
  static const int kAnimAssetArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_animassetarr</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>animassetarr_size</name>
  		<replaceName>AnimAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::AnimAsset2& animassetarr(int index) const;
  inline ::pb::AnimAsset2* mutable_animassetarr(int index);
  inline ::pb::AnimAsset2* add_animassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
      animassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
      mutable_animassetarr();

  // repeated .pb.StaticAsset2 StaticAssetArr = 9;
  inline int staticassetarr_size() const;
  inline void clear_staticassetarr();
  static const int kStaticAssetArrFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_staticassetarr</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>staticassetarr_size</name>
  		<replaceName>StaticAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::StaticAsset2& staticassetarr(int index) const;
  inline ::pb::StaticAsset2* mutable_staticassetarr(int index);
  inline ::pb::StaticAsset2* add_staticassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
      staticassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
      mutable_staticassetarr();

  // repeated .pb.EffectAsset2 EffectAssetArr = 10;
  inline int effectassetarr_size() const;
  inline void clear_effectassetarr();
  static const int kEffectAssetArrFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_effectassetarr</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>effectassetarr_size</name>
  		<replaceName>EffectAssetArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::EffectAsset2& effectassetarr(int index) const;
  inline ::pb::EffectAsset2* mutable_effectassetarr(int index);
  inline ::pb::EffectAsset2* add_effectassetarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
      effectassetarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
      mutable_effectassetarr();

  // repeated .pb.PointElement2 PointElementArr = 11;
  inline int pointelementarr_size() const;
  inline void clear_pointelementarr();
  static const int kPointElementArrFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_pointelementarr</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>pointelementarr_size</name>
  		<replaceName>PointElementArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PointElement2& pointelementarr(int index) const;
  inline ::pb::PointElement2* mutable_pointelementarr(int index);
  inline ::pb::PointElement2* add_pointelementarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >&
      pointelementarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >*
      mutable_pointelementarr();

  // repeated .pb.FeatureEntrance FeatureEntranceArr = 12;
  inline int featureentrancearr_size() const;
  inline void clear_featureentrancearr();
  static const int kFeatureEntranceArrFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_featureentrancearr</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>featureentrancearr_size</name>
  		<replaceName>FeatureEntranceArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::FeatureEntrance& featureentrancearr(int index) const;
  inline ::pb::FeatureEntrance* mutable_featureentrancearr(int index);
  inline ::pb::FeatureEntrance* add_featureentrancearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >&
      featureentrancearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >*
      mutable_featureentrancearr();

  // repeated .pb.Obstacle ObstacleArr = 13;
  inline int obstaclearr_size() const;
  inline void clear_obstaclearr();
  static const int kObstacleArrFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>SceneConfGuildWar</name>
  	<Function>
  		<name>obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_obstaclearr</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>obstaclearr_size</name>
  		<replaceName>ObstacleArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::Obstacle& obstaclearr(int index) const;
  inline ::pb::Obstacle* mutable_obstaclearr(int index);
  inline ::pb::Obstacle* add_obstaclearr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >&
      obstaclearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >*
      mutable_obstaclearr();

  // @@protoc_insertion_point(class_scope:pb.SceneConfGuildWar)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_artscenepath();
  inline void clear_has_artscenepath();
  inline void set_has_chunkinfo();
  inline void clear_has_chunkinfo();
  inline void set_has_cameramovearea();
  inline void clear_has_cameramovearea();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* confname_;
  ::std::string* artscenepath_;
  ::pb::SceneChunkInfo* chunkinfo_;
  ::pb::PbRect* cameramovearea_;
  ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 > rectareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 > customareaarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 > animassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 > staticassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 > effectassetarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 > pointelementarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance > featureentrancearr_;
  ::google::protobuf::RepeatedPtrField< ::pb::Obstacle > obstaclearr_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fSceneConfGuildWar_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfGuildWar_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfGuildWar_2eproto();

  void InitAsDefaultInstance();
  static SceneConfGuildWar* default_instance_;
};
// ===================================================================


// ===================================================================

// SceneConfGuildWar

// required int32 Id = 1;
inline bool SceneConfGuildWar::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneConfGuildWar::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneConfGuildWar::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneConfGuildWar::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SceneConfGuildWar::id() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.Id)
  return id_;
}
inline void SceneConfGuildWar::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.SceneConfGuildWar.Id)
}

// required string ConfName = 2;
inline bool SceneConfGuildWar::has_confname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneConfGuildWar::set_has_confname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneConfGuildWar::clear_has_confname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneConfGuildWar::clear_confname() {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& SceneConfGuildWar::confname() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.ConfName)
  return *confname_;
}
inline void SceneConfGuildWar::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConfGuildWar.ConfName)
}
inline void SceneConfGuildWar::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfGuildWar.ConfName)
}
inline void SceneConfGuildWar::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfGuildWar.ConfName)
}
inline ::std::string* SceneConfGuildWar::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.ConfName)
  return confname_;
}
inline ::std::string* SceneConfGuildWar::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConfGuildWar::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGuildWar.ConfName)
}

// required string ArtScenePath = 3;
inline bool SceneConfGuildWar::has_artscenepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneConfGuildWar::set_has_artscenepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneConfGuildWar::clear_has_artscenepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneConfGuildWar::clear_artscenepath() {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_->clear();
  }
  clear_has_artscenepath();
}
inline const ::std::string& SceneConfGuildWar::artscenepath() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.ArtScenePath)
  return *artscenepath_;
}
inline void SceneConfGuildWar::set_artscenepath(const ::std::string& value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConfGuildWar.ArtScenePath)
}
inline void SceneConfGuildWar::set_artscenepath(const char* value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfGuildWar.ArtScenePath)
}
inline void SceneConfGuildWar::set_artscenepath(const char* value, size_t size) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfGuildWar.ArtScenePath)
}
inline ::std::string* SceneConfGuildWar::mutable_artscenepath() {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.ArtScenePath)
  return artscenepath_;
}
inline ::std::string* SceneConfGuildWar::release_artscenepath() {
  clear_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = artscenepath_;
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConfGuildWar::set_allocated_artscenepath(::std::string* artscenepath) {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete artscenepath_;
  }
  if (artscenepath) {
    set_has_artscenepath();
    artscenepath_ = artscenepath;
  } else {
    clear_has_artscenepath();
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGuildWar.ArtScenePath)
}

// required .pb.SceneChunkInfo ChunkInfo = 4;
inline bool SceneConfGuildWar::has_chunkinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneConfGuildWar::set_has_chunkinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneConfGuildWar::clear_has_chunkinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneConfGuildWar::clear_chunkinfo() {
  if (chunkinfo_ != NULL) chunkinfo_->::pb::SceneChunkInfo::Clear();
  clear_has_chunkinfo();
}
inline const ::pb::SceneChunkInfo& SceneConfGuildWar::chunkinfo() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.ChunkInfo)
  return chunkinfo_ != NULL ? *chunkinfo_ : *default_instance_->chunkinfo_;
}
inline ::pb::SceneChunkInfo* SceneConfGuildWar::mutable_chunkinfo() {
  set_has_chunkinfo();
  if (chunkinfo_ == NULL) chunkinfo_ = new ::pb::SceneChunkInfo;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.ChunkInfo)
  return chunkinfo_;
}
inline ::pb::SceneChunkInfo* SceneConfGuildWar::release_chunkinfo() {
  clear_has_chunkinfo();
  ::pb::SceneChunkInfo* temp = chunkinfo_;
  chunkinfo_ = NULL;
  return temp;
}
inline void SceneConfGuildWar::set_allocated_chunkinfo(::pb::SceneChunkInfo* chunkinfo) {
  delete chunkinfo_;
  chunkinfo_ = chunkinfo;
  if (chunkinfo) {
    set_has_chunkinfo();
  } else {
    clear_has_chunkinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGuildWar.ChunkInfo)
}

// required .pb.PbRect CameraMoveArea = 5;
inline bool SceneConfGuildWar::has_cameramovearea() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SceneConfGuildWar::set_has_cameramovearea() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SceneConfGuildWar::clear_has_cameramovearea() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SceneConfGuildWar::clear_cameramovearea() {
  if (cameramovearea_ != NULL) cameramovearea_->::pb::PbRect::Clear();
  clear_has_cameramovearea();
}
inline const ::pb::PbRect& SceneConfGuildWar::cameramovearea() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.CameraMoveArea)
  return cameramovearea_ != NULL ? *cameramovearea_ : *default_instance_->cameramovearea_;
}
inline ::pb::PbRect* SceneConfGuildWar::mutable_cameramovearea() {
  set_has_cameramovearea();
  if (cameramovearea_ == NULL) cameramovearea_ = new ::pb::PbRect;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.CameraMoveArea)
  return cameramovearea_;
}
inline ::pb::PbRect* SceneConfGuildWar::release_cameramovearea() {
  clear_has_cameramovearea();
  ::pb::PbRect* temp = cameramovearea_;
  cameramovearea_ = NULL;
  return temp;
}
inline void SceneConfGuildWar::set_allocated_cameramovearea(::pb::PbRect* cameramovearea) {
  delete cameramovearea_;
  cameramovearea_ = cameramovearea;
  if (cameramovearea) {
    set_has_cameramovearea();
  } else {
    clear_has_cameramovearea();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfGuildWar.CameraMoveArea)
}

// repeated .pb.RectArea2 RectAreaArr = 6;
inline int SceneConfGuildWar::rectareaarr_size() const {
  return rectareaarr_.size();
}
inline void SceneConfGuildWar::clear_rectareaarr() {
  rectareaarr_.Clear();
}
inline const ::pb::RectArea2& SceneConfGuildWar::rectareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.RectAreaArr)
  return rectareaarr_.Get(index);
}
inline ::pb::RectArea2* SceneConfGuildWar::mutable_rectareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.RectAreaArr)
  return rectareaarr_.Mutable(index);
}
inline ::pb::RectArea2* SceneConfGuildWar::add_rectareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.RectAreaArr)
  return rectareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >&
SceneConfGuildWar::rectareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.RectAreaArr)
  return rectareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::RectArea2 >*
SceneConfGuildWar::mutable_rectareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.RectAreaArr)
  return &rectareaarr_;
}

// repeated .pb.CustomArea2 CustomAreaArr = 7;
inline int SceneConfGuildWar::customareaarr_size() const {
  return customareaarr_.size();
}
inline void SceneConfGuildWar::clear_customareaarr() {
  customareaarr_.Clear();
}
inline const ::pb::CustomArea2& SceneConfGuildWar::customareaarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.CustomAreaArr)
  return customareaarr_.Get(index);
}
inline ::pb::CustomArea2* SceneConfGuildWar::mutable_customareaarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.CustomAreaArr)
  return customareaarr_.Mutable(index);
}
inline ::pb::CustomArea2* SceneConfGuildWar::add_customareaarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.CustomAreaArr)
  return customareaarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >&
SceneConfGuildWar::customareaarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.CustomAreaArr)
  return customareaarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CustomArea2 >*
SceneConfGuildWar::mutable_customareaarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.CustomAreaArr)
  return &customareaarr_;
}

// repeated .pb.AnimAsset2 AnimAssetArr = 8;
inline int SceneConfGuildWar::animassetarr_size() const {
  return animassetarr_.size();
}
inline void SceneConfGuildWar::clear_animassetarr() {
  animassetarr_.Clear();
}
inline const ::pb::AnimAsset2& SceneConfGuildWar::animassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.AnimAssetArr)
  return animassetarr_.Get(index);
}
inline ::pb::AnimAsset2* SceneConfGuildWar::mutable_animassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.AnimAssetArr)
  return animassetarr_.Mutable(index);
}
inline ::pb::AnimAsset2* SceneConfGuildWar::add_animassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.AnimAssetArr)
  return animassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >&
SceneConfGuildWar::animassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.AnimAssetArr)
  return animassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AnimAsset2 >*
SceneConfGuildWar::mutable_animassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.AnimAssetArr)
  return &animassetarr_;
}

// repeated .pb.StaticAsset2 StaticAssetArr = 9;
inline int SceneConfGuildWar::staticassetarr_size() const {
  return staticassetarr_.size();
}
inline void SceneConfGuildWar::clear_staticassetarr() {
  staticassetarr_.Clear();
}
inline const ::pb::StaticAsset2& SceneConfGuildWar::staticassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.StaticAssetArr)
  return staticassetarr_.Get(index);
}
inline ::pb::StaticAsset2* SceneConfGuildWar::mutable_staticassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.StaticAssetArr)
  return staticassetarr_.Mutable(index);
}
inline ::pb::StaticAsset2* SceneConfGuildWar::add_staticassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.StaticAssetArr)
  return staticassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >&
SceneConfGuildWar::staticassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.StaticAssetArr)
  return staticassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::StaticAsset2 >*
SceneConfGuildWar::mutable_staticassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.StaticAssetArr)
  return &staticassetarr_;
}

// repeated .pb.EffectAsset2 EffectAssetArr = 10;
inline int SceneConfGuildWar::effectassetarr_size() const {
  return effectassetarr_.size();
}
inline void SceneConfGuildWar::clear_effectassetarr() {
  effectassetarr_.Clear();
}
inline const ::pb::EffectAsset2& SceneConfGuildWar::effectassetarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.EffectAssetArr)
  return effectassetarr_.Get(index);
}
inline ::pb::EffectAsset2* SceneConfGuildWar::mutable_effectassetarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.EffectAssetArr)
  return effectassetarr_.Mutable(index);
}
inline ::pb::EffectAsset2* SceneConfGuildWar::add_effectassetarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.EffectAssetArr)
  return effectassetarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >&
SceneConfGuildWar::effectassetarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.EffectAssetArr)
  return effectassetarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EffectAsset2 >*
SceneConfGuildWar::mutable_effectassetarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.EffectAssetArr)
  return &effectassetarr_;
}

// repeated .pb.PointElement2 PointElementArr = 11;
inline int SceneConfGuildWar::pointelementarr_size() const {
  return pointelementarr_.size();
}
inline void SceneConfGuildWar::clear_pointelementarr() {
  pointelementarr_.Clear();
}
inline const ::pb::PointElement2& SceneConfGuildWar::pointelementarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.PointElementArr)
  return pointelementarr_.Get(index);
}
inline ::pb::PointElement2* SceneConfGuildWar::mutable_pointelementarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.PointElementArr)
  return pointelementarr_.Mutable(index);
}
inline ::pb::PointElement2* SceneConfGuildWar::add_pointelementarr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.PointElementArr)
  return pointelementarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >&
SceneConfGuildWar::pointelementarr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.PointElementArr)
  return pointelementarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PointElement2 >*
SceneConfGuildWar::mutable_pointelementarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.PointElementArr)
  return &pointelementarr_;
}

// repeated .pb.FeatureEntrance FeatureEntranceArr = 12;
inline int SceneConfGuildWar::featureentrancearr_size() const {
  return featureentrancearr_.size();
}
inline void SceneConfGuildWar::clear_featureentrancearr() {
  featureentrancearr_.Clear();
}
inline const ::pb::FeatureEntrance& SceneConfGuildWar::featureentrancearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.FeatureEntranceArr)
  return featureentrancearr_.Get(index);
}
inline ::pb::FeatureEntrance* SceneConfGuildWar::mutable_featureentrancearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.FeatureEntranceArr)
  return featureentrancearr_.Mutable(index);
}
inline ::pb::FeatureEntrance* SceneConfGuildWar::add_featureentrancearr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.FeatureEntranceArr)
  return featureentrancearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >&
SceneConfGuildWar::featureentrancearr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.FeatureEntranceArr)
  return featureentrancearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::FeatureEntrance >*
SceneConfGuildWar::mutable_featureentrancearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.FeatureEntranceArr)
  return &featureentrancearr_;
}

// repeated .pb.Obstacle ObstacleArr = 13;
inline int SceneConfGuildWar::obstaclearr_size() const {
  return obstaclearr_.size();
}
inline void SceneConfGuildWar::clear_obstaclearr() {
  obstaclearr_.Clear();
}
inline const ::pb::Obstacle& SceneConfGuildWar::obstaclearr(int index) const {
  // @@protoc_insertion_point(field_get:pb.SceneConfGuildWar.ObstacleArr)
  return obstaclearr_.Get(index);
}
inline ::pb::Obstacle* SceneConfGuildWar::mutable_obstaclearr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SceneConfGuildWar.ObstacleArr)
  return obstaclearr_.Mutable(index);
}
inline ::pb::Obstacle* SceneConfGuildWar::add_obstaclearr() {
  // @@protoc_insertion_point(field_add:pb.SceneConfGuildWar.ObstacleArr)
  return obstaclearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >&
SceneConfGuildWar::obstaclearr() const {
  // @@protoc_insertion_point(field_list:pb.SceneConfGuildWar.ObstacleArr)
  return obstaclearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Obstacle >*
SceneConfGuildWar::mutable_obstaclearr() {
  // @@protoc_insertion_point(field_mutable_list:pb.SceneConfGuildWar.ObstacleArr)
  return &obstaclearr_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fSceneConfGuildWar_2eproto__INCLUDED
