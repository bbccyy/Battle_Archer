// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/SceneConfArcher.proto

#ifndef PROTOBUF_module_2fSceneConfArcher_2eproto__INCLUDED
#define PROTOBUF_module_2fSceneConfArcher_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/Util.pb.h"
#include "module/SceneElementDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fSceneConfArcher_2eproto();
void protobuf_AssignDesc_module_2fSceneConfArcher_2eproto();
void protobuf_ShutdownFile_module_2fSceneConfArcher_2eproto();

class ArcherScene;
class ArcherGridBlock;
class CameraArcher;
class SceneConfArcher;

enum EArcherGridType {
  Default = 1,
  Obstacle_All = 2,
  Obstacle_Ground_Only = 3,
  Trap = 4,
  Mission_Complete = 5
};
bool EArcherGridType_IsValid(int value);
const EArcherGridType EArcherGridType_MIN = Default;
const EArcherGridType EArcherGridType_MAX = Mission_Complete;
const int EArcherGridType_ARRAYSIZE = EArcherGridType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EArcherGridType_descriptor();
inline const ::std::string& EArcherGridType_Name(EArcherGridType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EArcherGridType_descriptor(), value);
}
inline bool EArcherGridType_Parse(
    const ::std::string& name, EArcherGridType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EArcherGridType>(
    EArcherGridType_descriptor(), name, value);
}
// ===================================================================

/*FOR2LUA
<Record>
	<name>ArcherScene</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfArcher.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class ArcherScene : public ::google::protobuf::Message {
 public:
  ArcherScene();
  virtual ~ArcherScene();

  ArcherScene(const ArcherScene& from);

  inline ArcherScene& operator=(const ArcherScene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArcherScene& default_instance();

  void Swap(ArcherScene* other);

  // implements Message ----------------------------------------------

  ArcherScene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArcherScene& from);
  void MergeFrom(const ArcherScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 SceneId = 1;
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>sceneid</name>
  		<replaceName>SceneId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sceneid</name>
  		<replaceName>SceneId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sceneid</name>
  		<replaceName>SceneId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 sceneid() const;
  inline void set_sceneid(::google::protobuf::uint32 value);

  // required uint32 SceneTileWidth = 2;
  inline bool has_scenetilewidth() const;
  inline void clear_scenetilewidth();
  static const int kSceneTileWidthFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>scenetilewidth</name>
  		<replaceName>SceneTileWidth</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scenetilewidth</name>
  		<replaceName>SceneTileWidth</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scenetilewidth</name>
  		<replaceName>SceneTileWidth</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 scenetilewidth() const;
  inline void set_scenetilewidth(::google::protobuf::uint32 value);

  // required uint32 SceneTileHeight = 3;
  inline bool has_scenetileheight() const;
  inline void clear_scenetileheight();
  static const int kSceneTileHeightFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>scenetileheight</name>
  		<replaceName>SceneTileHeight</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_scenetileheight</name>
  		<replaceName>SceneTileHeight</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_scenetileheight</name>
  		<replaceName>SceneTileHeight</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 scenetileheight() const;
  inline void set_scenetileheight(::google::protobuf::uint32 value);

  // required uint32 TileSize = 4;
  inline bool has_tilesize() const;
  inline void clear_tilesize();
  static const int kTileSizeFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>tilesize</name>
  		<replaceName>TileSize</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_tilesize</name>
  		<replaceName>TileSize</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_tilesize</name>
  		<replaceName>TileSize</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 tilesize() const;
  inline void set_tilesize(::google::protobuf::uint32 value);

  // required .pb.PbVector3 CenterWSPos = 5;
  inline bool has_centerwspos() const;
  inline void clear_centerwspos();
  static const int kCenterWSPosFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>centerwspos</name>
  		<replaceName>CenterWSPos</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_centerwspos</name>
  		<replaceName>CenterWSPos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_centerwspos</name>
  		<replaceName>CenterWSPos</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_centerwspos</name>
  		<replaceName>CenterWSPos</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3& centerwspos() const;
  inline ::pb::PbVector3* mutable_centerwspos();
  inline ::pb::PbVector3* release_centerwspos();
  inline void set_allocated_centerwspos(::pb::PbVector3* centerwspos);

  // required .pb.PbVector3 SceneForward = 6;
  inline bool has_sceneforward() const;
  inline void clear_sceneforward();
  static const int kSceneForwardFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>sceneforward</name>
  		<replaceName>SceneForward</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_sceneforward</name>
  		<replaceName>SceneForward</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_sceneforward</name>
  		<replaceName>SceneForward</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_sceneforward</name>
  		<replaceName>SceneForward</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3& sceneforward() const;
  inline ::pb::PbVector3* mutable_sceneforward();
  inline ::pb::PbVector3* release_sceneforward();
  inline void set_allocated_sceneforward(::pb::PbVector3* sceneforward);

  // repeated .pb.ArcherGridBlock GridBlockArr = 7;
  inline int gridblockarr_size() const;
  inline void clear_gridblockarr();
  static const int kGridBlockArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>gridblockarr</name>
  		<replaceName>GridBlockArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_gridblockarr</name>
  		<replaceName>GridBlockArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_gridblockarr</name>
  		<replaceName>GridBlockArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_gridblockarr</name>
  		<replaceName>GridBlockArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>gridblockarr_size</name>
  		<replaceName>GridBlockArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::ArcherGridBlock& gridblockarr(int index) const;
  inline ::pb::ArcherGridBlock* mutable_gridblockarr(int index);
  inline ::pb::ArcherGridBlock* add_gridblockarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ArcherGridBlock >&
      gridblockarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ArcherGridBlock >*
      mutable_gridblockarr();

  // repeated uint32 StandTileIndexArr = 8;
  inline int standtileindexarr_size() const;
  inline void clear_standtileindexarr();
  static const int kStandTileIndexArrFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>standtileindexarr</name>
  		<replaceName>StandTileIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_standtileindexarr</name>
  		<replaceName>StandTileIndexArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_standtileindexarr</name>
  		<replaceName>StandTileIndexArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_standtileindexarr</name>
  		<replaceName>StandTileIndexArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>standtileindexarr_size</name>
  		<replaceName>StandTileIndexArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 standtileindexarr(int index) const;
  inline void set_standtileindexarr(int index, ::google::protobuf::uint32 value);
  inline void add_standtileindexarr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      standtileindexarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_standtileindexarr();

  // required uint32 PlayerBronTileIndex = 9;
  inline bool has_playerbrontileindex() const;
  inline void clear_playerbrontileindex();
  static const int kPlayerBronTileIndexFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>playerbrontileindex</name>
  		<replaceName>PlayerBronTileIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_playerbrontileindex</name>
  		<replaceName>PlayerBronTileIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_playerbrontileindex</name>
  		<replaceName>PlayerBronTileIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 playerbrontileindex() const;
  inline void set_playerbrontileindex(::google::protobuf::uint32 value);

  // required string ArtScenePath = 10;
  inline bool has_artscenepath() const;
  inline void clear_artscenepath();
  static const int kArtScenePathFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>ArcherScene</name>
  	<Function>
  		<name>artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_artscenepath</name>
  		<replaceName>ArtScenePath</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& artscenepath() const;
  inline void set_artscenepath(const ::std::string& value);
  inline void set_artscenepath(const char* value);
  inline void set_artscenepath(const char* value, size_t size);
  inline ::std::string* mutable_artscenepath();
  inline ::std::string* release_artscenepath();
  inline void set_allocated_artscenepath(::std::string* artscenepath);

  // @@protoc_insertion_point(class_scope:pb.ArcherScene)
 private:
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_scenetilewidth();
  inline void clear_has_scenetilewidth();
  inline void set_has_scenetileheight();
  inline void clear_has_scenetileheight();
  inline void set_has_tilesize();
  inline void clear_has_tilesize();
  inline void set_has_centerwspos();
  inline void clear_has_centerwspos();
  inline void set_has_sceneforward();
  inline void clear_has_sceneforward();
  inline void set_has_playerbrontileindex();
  inline void clear_has_playerbrontileindex();
  inline void set_has_artscenepath();
  inline void clear_has_artscenepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sceneid_;
  ::google::protobuf::uint32 scenetilewidth_;
  ::google::protobuf::uint32 scenetileheight_;
  ::google::protobuf::uint32 tilesize_;
  ::pb::PbVector3* centerwspos_;
  ::pb::PbVector3* sceneforward_;
  ::google::protobuf::RepeatedPtrField< ::pb::ArcherGridBlock > gridblockarr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > standtileindexarr_;
  ::std::string* artscenepath_;
  ::google::protobuf::uint32 playerbrontileindex_;
  friend void  protobuf_AddDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfArcher_2eproto();

  void InitAsDefaultInstance();
  static ArcherScene* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>ArcherGridBlock</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfArcher.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class ArcherGridBlock : public ::google::protobuf::Message {
 public:
  ArcherGridBlock();
  virtual ~ArcherGridBlock();

  ArcherGridBlock(const ArcherGridBlock& from);

  inline ArcherGridBlock& operator=(const ArcherGridBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArcherGridBlock& default_instance();

  void Swap(ArcherGridBlock* other);

  // implements Message ----------------------------------------------

  ArcherGridBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArcherGridBlock& from);
  void MergeFrom(const ArcherGridBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EArcherGridType GridType = 1;
  inline bool has_gridtype() const;
  inline void clear_gridtype();
  static const int kGridTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>ArcherGridBlock</name>
  	<Function>
  		<name>gridtype</name>
  		<replaceName>GridType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_gridtype</name>
  		<replaceName>GridType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_gridtype</name>
  		<replaceName>GridType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::EArcherGridType gridtype() const;
  inline void set_gridtype(::pb::EArcherGridType value);

  // required uint32 GridIndex = 2;
  inline bool has_gridindex() const;
  inline void clear_gridindex();
  static const int kGridIndexFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>ArcherGridBlock</name>
  	<Function>
  		<name>gridindex</name>
  		<replaceName>GridIndex</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_gridindex</name>
  		<replaceName>GridIndex</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_gridindex</name>
  		<replaceName>GridIndex</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 gridindex() const;
  inline void set_gridindex(::google::protobuf::uint32 value);

  // required uint32 ConfigId = 3;
  inline bool has_configid() const;
  inline void clear_configid();
  static const int kConfigIdFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>ArcherGridBlock</name>
  	<Function>
  		<name>configid</name>
  		<replaceName>ConfigId</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_configid</name>
  		<replaceName>ConfigId</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_configid</name>
  		<replaceName>ConfigId</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::uint32 configid() const;
  inline void set_configid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ArcherGridBlock)
 private:
  inline void set_has_gridtype();
  inline void clear_has_gridtype();
  inline void set_has_gridindex();
  inline void clear_has_gridindex();
  inline void set_has_configid();
  inline void clear_has_configid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int gridtype_;
  ::google::protobuf::uint32 gridindex_;
  ::google::protobuf::uint32 configid_;
  friend void  protobuf_AddDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfArcher_2eproto();

  void InitAsDefaultInstance();
  static ArcherGridBlock* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>CameraArcher</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfArcher.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class CameraArcher : public ::google::protobuf::Message {
 public:
  CameraArcher();
  virtual ~CameraArcher();

  CameraArcher(const CameraArcher& from);

  inline CameraArcher& operator=(const CameraArcher& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraArcher& default_instance();

  void Swap(CameraArcher* other);

  // implements Message ----------------------------------------------

  CameraArcher* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraArcher& from);
  void MergeFrom(const CameraArcher& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>CameraArcher</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float Fov = 2;
  inline bool has_fov() const;
  inline void clear_fov();
  static const int kFovFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>CameraArcher</name>
  	<Function>
  		<name>fov</name>
  		<replaceName>Fov</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fov</name>
  		<replaceName>Fov</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fov</name>
  		<replaceName>Fov</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline float fov() const;
  inline void set_fov(float value);

  // required .pb.PbVector3_Int Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>CameraArcher</name>
  	<Function>
  		<name>position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_position</name>
  		<replaceName>Position</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& position() const;
  inline ::pb::PbVector3_Int* mutable_position();
  inline ::pb::PbVector3_Int* release_position();
  inline void set_allocated_position(::pb::PbVector3_Int* position);

  // required .pb.PbVector3_Int Direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>CameraArcher</name>
  	<Function>
  		<name>direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_direction</name>
  		<replaceName>Direction</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::PbVector3_Int& direction() const;
  inline ::pb::PbVector3_Int* mutable_direction();
  inline ::pb::PbVector3_Int* release_direction();
  inline void set_allocated_direction(::pb::PbVector3_Int* direction);

  // @@protoc_insertion_point(class_scope:pb.CameraArcher)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fov();
  inline void clear_has_fov();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pb::PbVector3_Int* position_;
  ::pb::PbVector3_Int* direction_;
  float fov_;
  friend void  protobuf_AddDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfArcher_2eproto();

  void InitAsDefaultInstance();
  static CameraArcher* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>SceneConfArcher</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/SceneConfArcher.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class SceneConfArcher : public ::google::protobuf::Message {
 public:
  SceneConfArcher();
  virtual ~SceneConfArcher();

  SceneConfArcher(const SceneConfArcher& from);

  inline SceneConfArcher& operator=(const SceneConfArcher& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneConfArcher& default_instance();

  void Swap(SceneConfArcher* other);

  // implements Message ----------------------------------------------

  SceneConfArcher* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneConfArcher& from);
  void MergeFrom(const SceneConfArcher& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>SceneConfArcher</name>
  	<Function>
  		<name>id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>Id</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string ConfName = 2;
  inline bool has_confname() const;
  inline void clear_confname();
  static const int kConfNameFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>SceneConfArcher</name>
  	<Function>
  		<name>confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_confname</name>
  		<replaceName>ConfName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& confname() const;
  inline void set_confname(const ::std::string& value);
  inline void set_confname(const char* value);
  inline void set_confname(const char* value, size_t size);
  inline ::std::string* mutable_confname();
  inline ::std::string* release_confname();
  inline void set_allocated_confname(::std::string* confname);

  // required .pb.ArcherScene FieldConf = 3;
  inline bool has_fieldconf() const;
  inline void clear_fieldconf();
  static const int kFieldConfFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>SceneConfArcher</name>
  	<Function>
  		<name>fieldconf</name>
  		<replaceName>FieldConf</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_fieldconf</name>
  		<replaceName>FieldConf</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_fieldconf</name>
  		<replaceName>FieldConf</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_fieldconf</name>
  		<replaceName>FieldConf</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::ArcherScene& fieldconf() const;
  inline ::pb::ArcherScene* mutable_fieldconf();
  inline ::pb::ArcherScene* release_fieldconf();
  inline void set_allocated_fieldconf(::pb::ArcherScene* fieldconf);

  // required .pb.CameraArcher Camera = 4;
  inline bool has_camera() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>SceneConfArcher</name>
  	<Function>
  		<name>camera</name>
  		<replaceName>Camera</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_camera</name>
  		<replaceName>Camera</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_camera</name>
  		<replaceName>Camera</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_camera</name>
  		<replaceName>Camera</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::CameraArcher& camera() const;
  inline ::pb::CameraArcher* mutable_camera();
  inline ::pb::CameraArcher* release_camera();
  inline void set_allocated_camera(::pb::CameraArcher* camera);

  // @@protoc_insertion_point(class_scope:pb.SceneConfArcher)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_confname();
  inline void clear_has_confname();
  inline void set_has_fieldconf();
  inline void clear_has_fieldconf();
  inline void set_has_camera();
  inline void clear_has_camera();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* confname_;
  ::pb::ArcherScene* fieldconf_;
  ::pb::CameraArcher* camera_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_AssignDesc_module_2fSceneConfArcher_2eproto();
  friend void protobuf_ShutdownFile_module_2fSceneConfArcher_2eproto();

  void InitAsDefaultInstance();
  static SceneConfArcher* default_instance_;
};
// ===================================================================


// ===================================================================

// ArcherScene

// required uint32 SceneId = 1;
inline bool ArcherScene::has_sceneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArcherScene::set_has_sceneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArcherScene::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArcherScene::clear_sceneid() {
  sceneid_ = 0u;
  clear_has_sceneid();
}
inline ::google::protobuf::uint32 ArcherScene::sceneid() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.SceneId)
  return sceneid_;
}
inline void ArcherScene::set_sceneid(::google::protobuf::uint32 value) {
  set_has_sceneid();
  sceneid_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherScene.SceneId)
}

// required uint32 SceneTileWidth = 2;
inline bool ArcherScene::has_scenetilewidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArcherScene::set_has_scenetilewidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArcherScene::clear_has_scenetilewidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArcherScene::clear_scenetilewidth() {
  scenetilewidth_ = 0u;
  clear_has_scenetilewidth();
}
inline ::google::protobuf::uint32 ArcherScene::scenetilewidth() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.SceneTileWidth)
  return scenetilewidth_;
}
inline void ArcherScene::set_scenetilewidth(::google::protobuf::uint32 value) {
  set_has_scenetilewidth();
  scenetilewidth_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherScene.SceneTileWidth)
}

// required uint32 SceneTileHeight = 3;
inline bool ArcherScene::has_scenetileheight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArcherScene::set_has_scenetileheight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArcherScene::clear_has_scenetileheight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArcherScene::clear_scenetileheight() {
  scenetileheight_ = 0u;
  clear_has_scenetileheight();
}
inline ::google::protobuf::uint32 ArcherScene::scenetileheight() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.SceneTileHeight)
  return scenetileheight_;
}
inline void ArcherScene::set_scenetileheight(::google::protobuf::uint32 value) {
  set_has_scenetileheight();
  scenetileheight_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherScene.SceneTileHeight)
}

// required uint32 TileSize = 4;
inline bool ArcherScene::has_tilesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArcherScene::set_has_tilesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArcherScene::clear_has_tilesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArcherScene::clear_tilesize() {
  tilesize_ = 0u;
  clear_has_tilesize();
}
inline ::google::protobuf::uint32 ArcherScene::tilesize() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.TileSize)
  return tilesize_;
}
inline void ArcherScene::set_tilesize(::google::protobuf::uint32 value) {
  set_has_tilesize();
  tilesize_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherScene.TileSize)
}

// required .pb.PbVector3 CenterWSPos = 5;
inline bool ArcherScene::has_centerwspos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArcherScene::set_has_centerwspos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArcherScene::clear_has_centerwspos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArcherScene::clear_centerwspos() {
  if (centerwspos_ != NULL) centerwspos_->::pb::PbVector3::Clear();
  clear_has_centerwspos();
}
inline const ::pb::PbVector3& ArcherScene::centerwspos() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.CenterWSPos)
  return centerwspos_ != NULL ? *centerwspos_ : *default_instance_->centerwspos_;
}
inline ::pb::PbVector3* ArcherScene::mutable_centerwspos() {
  set_has_centerwspos();
  if (centerwspos_ == NULL) centerwspos_ = new ::pb::PbVector3;
  // @@protoc_insertion_point(field_mutable:pb.ArcherScene.CenterWSPos)
  return centerwspos_;
}
inline ::pb::PbVector3* ArcherScene::release_centerwspos() {
  clear_has_centerwspos();
  ::pb::PbVector3* temp = centerwspos_;
  centerwspos_ = NULL;
  return temp;
}
inline void ArcherScene::set_allocated_centerwspos(::pb::PbVector3* centerwspos) {
  delete centerwspos_;
  centerwspos_ = centerwspos;
  if (centerwspos) {
    set_has_centerwspos();
  } else {
    clear_has_centerwspos();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ArcherScene.CenterWSPos)
}

// required .pb.PbVector3 SceneForward = 6;
inline bool ArcherScene::has_sceneforward() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArcherScene::set_has_sceneforward() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArcherScene::clear_has_sceneforward() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArcherScene::clear_sceneforward() {
  if (sceneforward_ != NULL) sceneforward_->::pb::PbVector3::Clear();
  clear_has_sceneforward();
}
inline const ::pb::PbVector3& ArcherScene::sceneforward() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.SceneForward)
  return sceneforward_ != NULL ? *sceneforward_ : *default_instance_->sceneforward_;
}
inline ::pb::PbVector3* ArcherScene::mutable_sceneforward() {
  set_has_sceneforward();
  if (sceneforward_ == NULL) sceneforward_ = new ::pb::PbVector3;
  // @@protoc_insertion_point(field_mutable:pb.ArcherScene.SceneForward)
  return sceneforward_;
}
inline ::pb::PbVector3* ArcherScene::release_sceneforward() {
  clear_has_sceneforward();
  ::pb::PbVector3* temp = sceneforward_;
  sceneforward_ = NULL;
  return temp;
}
inline void ArcherScene::set_allocated_sceneforward(::pb::PbVector3* sceneforward) {
  delete sceneforward_;
  sceneforward_ = sceneforward;
  if (sceneforward) {
    set_has_sceneforward();
  } else {
    clear_has_sceneforward();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ArcherScene.SceneForward)
}

// repeated .pb.ArcherGridBlock GridBlockArr = 7;
inline int ArcherScene::gridblockarr_size() const {
  return gridblockarr_.size();
}
inline void ArcherScene::clear_gridblockarr() {
  gridblockarr_.Clear();
}
inline const ::pb::ArcherGridBlock& ArcherScene::gridblockarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.GridBlockArr)
  return gridblockarr_.Get(index);
}
inline ::pb::ArcherGridBlock* ArcherScene::mutable_gridblockarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ArcherScene.GridBlockArr)
  return gridblockarr_.Mutable(index);
}
inline ::pb::ArcherGridBlock* ArcherScene::add_gridblockarr() {
  // @@protoc_insertion_point(field_add:pb.ArcherScene.GridBlockArr)
  return gridblockarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ArcherGridBlock >&
ArcherScene::gridblockarr() const {
  // @@protoc_insertion_point(field_list:pb.ArcherScene.GridBlockArr)
  return gridblockarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ArcherGridBlock >*
ArcherScene::mutable_gridblockarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.ArcherScene.GridBlockArr)
  return &gridblockarr_;
}

// repeated uint32 StandTileIndexArr = 8;
inline int ArcherScene::standtileindexarr_size() const {
  return standtileindexarr_.size();
}
inline void ArcherScene::clear_standtileindexarr() {
  standtileindexarr_.Clear();
}
inline ::google::protobuf::uint32 ArcherScene::standtileindexarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.StandTileIndexArr)
  return standtileindexarr_.Get(index);
}
inline void ArcherScene::set_standtileindexarr(int index, ::google::protobuf::uint32 value) {
  standtileindexarr_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.ArcherScene.StandTileIndexArr)
}
inline void ArcherScene::add_standtileindexarr(::google::protobuf::uint32 value) {
  standtileindexarr_.Add(value);
  // @@protoc_insertion_point(field_add:pb.ArcherScene.StandTileIndexArr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ArcherScene::standtileindexarr() const {
  // @@protoc_insertion_point(field_list:pb.ArcherScene.StandTileIndexArr)
  return standtileindexarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ArcherScene::mutable_standtileindexarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.ArcherScene.StandTileIndexArr)
  return &standtileindexarr_;
}

// required uint32 PlayerBronTileIndex = 9;
inline bool ArcherScene::has_playerbrontileindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArcherScene::set_has_playerbrontileindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArcherScene::clear_has_playerbrontileindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArcherScene::clear_playerbrontileindex() {
  playerbrontileindex_ = 0u;
  clear_has_playerbrontileindex();
}
inline ::google::protobuf::uint32 ArcherScene::playerbrontileindex() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.PlayerBronTileIndex)
  return playerbrontileindex_;
}
inline void ArcherScene::set_playerbrontileindex(::google::protobuf::uint32 value) {
  set_has_playerbrontileindex();
  playerbrontileindex_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherScene.PlayerBronTileIndex)
}

// required string ArtScenePath = 10;
inline bool ArcherScene::has_artscenepath() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ArcherScene::set_has_artscenepath() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ArcherScene::clear_has_artscenepath() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ArcherScene::clear_artscenepath() {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_->clear();
  }
  clear_has_artscenepath();
}
inline const ::std::string& ArcherScene::artscenepath() const {
  // @@protoc_insertion_point(field_get:pb.ArcherScene.ArtScenePath)
  return *artscenepath_;
}
inline void ArcherScene::set_artscenepath(const ::std::string& value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ArcherScene.ArtScenePath)
}
inline void ArcherScene::set_artscenepath(const char* value) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ArcherScene.ArtScenePath)
}
inline void ArcherScene::set_artscenepath(const char* value, size_t size) {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  artscenepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ArcherScene.ArtScenePath)
}
inline ::std::string* ArcherScene::mutable_artscenepath() {
  set_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    artscenepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ArcherScene.ArtScenePath)
  return artscenepath_;
}
inline ::std::string* ArcherScene::release_artscenepath() {
  clear_has_artscenepath();
  if (artscenepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = artscenepath_;
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArcherScene::set_allocated_artscenepath(::std::string* artscenepath) {
  if (artscenepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete artscenepath_;
  }
  if (artscenepath) {
    set_has_artscenepath();
    artscenepath_ = artscenepath;
  } else {
    clear_has_artscenepath();
    artscenepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ArcherScene.ArtScenePath)
}

// -------------------------------------------------------------------

// ArcherGridBlock

// required .pb.EArcherGridType GridType = 1;
inline bool ArcherGridBlock::has_gridtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArcherGridBlock::set_has_gridtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArcherGridBlock::clear_has_gridtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArcherGridBlock::clear_gridtype() {
  gridtype_ = 1;
  clear_has_gridtype();
}
inline ::pb::EArcherGridType ArcherGridBlock::gridtype() const {
  // @@protoc_insertion_point(field_get:pb.ArcherGridBlock.GridType)
  return static_cast< ::pb::EArcherGridType >(gridtype_);
}
inline void ArcherGridBlock::set_gridtype(::pb::EArcherGridType value) {
  assert(::pb::EArcherGridType_IsValid(value));
  set_has_gridtype();
  gridtype_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherGridBlock.GridType)
}

// required uint32 GridIndex = 2;
inline bool ArcherGridBlock::has_gridindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArcherGridBlock::set_has_gridindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArcherGridBlock::clear_has_gridindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArcherGridBlock::clear_gridindex() {
  gridindex_ = 0u;
  clear_has_gridindex();
}
inline ::google::protobuf::uint32 ArcherGridBlock::gridindex() const {
  // @@protoc_insertion_point(field_get:pb.ArcherGridBlock.GridIndex)
  return gridindex_;
}
inline void ArcherGridBlock::set_gridindex(::google::protobuf::uint32 value) {
  set_has_gridindex();
  gridindex_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherGridBlock.GridIndex)
}

// required uint32 ConfigId = 3;
inline bool ArcherGridBlock::has_configid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArcherGridBlock::set_has_configid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArcherGridBlock::clear_has_configid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArcherGridBlock::clear_configid() {
  configid_ = 0u;
  clear_has_configid();
}
inline ::google::protobuf::uint32 ArcherGridBlock::configid() const {
  // @@protoc_insertion_point(field_get:pb.ArcherGridBlock.ConfigId)
  return configid_;
}
inline void ArcherGridBlock::set_configid(::google::protobuf::uint32 value) {
  set_has_configid();
  configid_ = value;
  // @@protoc_insertion_point(field_set:pb.ArcherGridBlock.ConfigId)
}

// -------------------------------------------------------------------

// CameraArcher

// required string Name = 1;
inline bool CameraArcher::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraArcher::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraArcher::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraArcher::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CameraArcher::name() const {
  // @@protoc_insertion_point(field_get:pb.CameraArcher.Name)
  return *name_;
}
inline void CameraArcher::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.CameraArcher.Name)
}
inline void CameraArcher::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.CameraArcher.Name)
}
inline void CameraArcher::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.CameraArcher.Name)
}
inline ::std::string* CameraArcher::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.CameraArcher.Name)
  return name_;
}
inline ::std::string* CameraArcher::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CameraArcher::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraArcher.Name)
}

// required float Fov = 2;
inline bool CameraArcher::has_fov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraArcher::set_has_fov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraArcher::clear_has_fov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraArcher::clear_fov() {
  fov_ = 0;
  clear_has_fov();
}
inline float CameraArcher::fov() const {
  // @@protoc_insertion_point(field_get:pb.CameraArcher.Fov)
  return fov_;
}
inline void CameraArcher::set_fov(float value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:pb.CameraArcher.Fov)
}

// required .pb.PbVector3_Int Position = 3;
inline bool CameraArcher::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraArcher::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraArcher::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraArcher::clear_position() {
  if (position_ != NULL) position_->::pb::PbVector3_Int::Clear();
  clear_has_position();
}
inline const ::pb::PbVector3_Int& CameraArcher::position() const {
  // @@protoc_insertion_point(field_get:pb.CameraArcher.Position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::PbVector3_Int* CameraArcher::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.CameraArcher.Position)
  return position_;
}
inline ::pb::PbVector3_Int* CameraArcher::release_position() {
  clear_has_position();
  ::pb::PbVector3_Int* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CameraArcher::set_allocated_position(::pb::PbVector3_Int* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraArcher.Position)
}

// required .pb.PbVector3_Int Direction = 4;
inline bool CameraArcher::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraArcher::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraArcher::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraArcher::clear_direction() {
  if (direction_ != NULL) direction_->::pb::PbVector3_Int::Clear();
  clear_has_direction();
}
inline const ::pb::PbVector3_Int& CameraArcher::direction() const {
  // @@protoc_insertion_point(field_get:pb.CameraArcher.Direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::pb::PbVector3_Int* CameraArcher::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::pb::PbVector3_Int;
  // @@protoc_insertion_point(field_mutable:pb.CameraArcher.Direction)
  return direction_;
}
inline ::pb::PbVector3_Int* CameraArcher::release_direction() {
  clear_has_direction();
  ::pb::PbVector3_Int* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void CameraArcher::set_allocated_direction(::pb::PbVector3_Int* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.CameraArcher.Direction)
}

// -------------------------------------------------------------------

// SceneConfArcher

// required int32 Id = 1;
inline bool SceneConfArcher::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneConfArcher::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneConfArcher::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneConfArcher::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SceneConfArcher::id() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfArcher.Id)
  return id_;
}
inline void SceneConfArcher::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.SceneConfArcher.Id)
}

// required string ConfName = 2;
inline bool SceneConfArcher::has_confname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneConfArcher::set_has_confname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneConfArcher::clear_has_confname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneConfArcher::clear_confname() {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_->clear();
  }
  clear_has_confname();
}
inline const ::std::string& SceneConfArcher::confname() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfArcher.ConfName)
  return *confname_;
}
inline void SceneConfArcher::set_confname(const ::std::string& value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.SceneConfArcher.ConfName)
}
inline void SceneConfArcher::set_confname(const char* value) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SceneConfArcher.ConfName)
}
inline void SceneConfArcher::set_confname(const char* value, size_t size) {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  confname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SceneConfArcher.ConfName)
}
inline ::std::string* SceneConfArcher::mutable_confname() {
  set_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    confname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.SceneConfArcher.ConfName)
  return confname_;
}
inline ::std::string* SceneConfArcher::release_confname() {
  clear_has_confname();
  if (confname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = confname_;
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SceneConfArcher::set_allocated_confname(::std::string* confname) {
  if (confname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete confname_;
  }
  if (confname) {
    set_has_confname();
    confname_ = confname;
  } else {
    clear_has_confname();
    confname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfArcher.ConfName)
}

// required .pb.ArcherScene FieldConf = 3;
inline bool SceneConfArcher::has_fieldconf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneConfArcher::set_has_fieldconf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneConfArcher::clear_has_fieldconf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneConfArcher::clear_fieldconf() {
  if (fieldconf_ != NULL) fieldconf_->::pb::ArcherScene::Clear();
  clear_has_fieldconf();
}
inline const ::pb::ArcherScene& SceneConfArcher::fieldconf() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfArcher.FieldConf)
  return fieldconf_ != NULL ? *fieldconf_ : *default_instance_->fieldconf_;
}
inline ::pb::ArcherScene* SceneConfArcher::mutable_fieldconf() {
  set_has_fieldconf();
  if (fieldconf_ == NULL) fieldconf_ = new ::pb::ArcherScene;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfArcher.FieldConf)
  return fieldconf_;
}
inline ::pb::ArcherScene* SceneConfArcher::release_fieldconf() {
  clear_has_fieldconf();
  ::pb::ArcherScene* temp = fieldconf_;
  fieldconf_ = NULL;
  return temp;
}
inline void SceneConfArcher::set_allocated_fieldconf(::pb::ArcherScene* fieldconf) {
  delete fieldconf_;
  fieldconf_ = fieldconf;
  if (fieldconf) {
    set_has_fieldconf();
  } else {
    clear_has_fieldconf();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfArcher.FieldConf)
}

// required .pb.CameraArcher Camera = 4;
inline bool SceneConfArcher::has_camera() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneConfArcher::set_has_camera() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneConfArcher::clear_has_camera() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneConfArcher::clear_camera() {
  if (camera_ != NULL) camera_->::pb::CameraArcher::Clear();
  clear_has_camera();
}
inline const ::pb::CameraArcher& SceneConfArcher::camera() const {
  // @@protoc_insertion_point(field_get:pb.SceneConfArcher.Camera)
  return camera_ != NULL ? *camera_ : *default_instance_->camera_;
}
inline ::pb::CameraArcher* SceneConfArcher::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) camera_ = new ::pb::CameraArcher;
  // @@protoc_insertion_point(field_mutable:pb.SceneConfArcher.Camera)
  return camera_;
}
inline ::pb::CameraArcher* SceneConfArcher::release_camera() {
  clear_has_camera();
  ::pb::CameraArcher* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline void SceneConfArcher::set_allocated_camera(::pb::CameraArcher* camera) {
  delete camera_;
  camera_ = camera;
  if (camera) {
    set_has_camera();
  } else {
    clear_has_camera();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.SceneConfArcher.Camera)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::EArcherGridType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EArcherGridType>() {
  return ::pb::EArcherGridType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fSceneConfArcher_2eproto__INCLUDED
