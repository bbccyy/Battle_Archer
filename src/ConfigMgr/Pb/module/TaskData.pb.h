// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module/TaskData.proto

#ifndef PROTOBUF_module_2fTaskData_2eproto__INCLUDED
#define PROTOBUF_module_2fTaskData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "module/BehaviorData.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_module_2fTaskData_2eproto();
void protobuf_AssignDesc_module_2fTaskData_2eproto();
void protobuf_ShutdownFile_module_2fTaskData_2eproto();

class TaskAccept;
class TaskTrigger;
class TaskTarget;
class TaskExtraInfo;
class TaskData;

enum ETaskMainType {
  ALLMAIN = 0,
  RPG = 1,
  SLG = 2
};
bool ETaskMainType_IsValid(int value);
const ETaskMainType ETaskMainType_MIN = ALLMAIN;
const ETaskMainType ETaskMainType_MAX = SLG;
const int ETaskMainType_ARRAYSIZE = ETaskMainType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskMainType_descriptor();
inline const ::std::string& ETaskMainType_Name(ETaskMainType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskMainType_descriptor(), value);
}
inline bool ETaskMainType_Parse(
    const ::std::string& name, ETaskMainType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskMainType>(
    ETaskMainType_descriptor(), name, value);
}
enum ETaskSubType {
  ALLSUB = 0,
  MAINLINE = 1,
  BRANCH = 2,
  FEMALEMASTER = 3,
  MASTER = 4,
  ACHIEVEMENT = 5,
  ACTIVITY = 6,
  DAILY = 7,
  FAVORITE = 8,
  REWARD_ACTIVITY = 9
};
bool ETaskSubType_IsValid(int value);
const ETaskSubType ETaskSubType_MIN = ALLSUB;
const ETaskSubType ETaskSubType_MAX = REWARD_ACTIVITY;
const int ETaskSubType_ARRAYSIZE = ETaskSubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskSubType_descriptor();
inline const ::std::string& ETaskSubType_Name(ETaskSubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskSubType_descriptor(), value);
}
inline bool ETaskSubType_Parse(
    const ::std::string& name, ETaskSubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskSubType>(
    ETaskSubType_descriptor(), name, value);
}
enum EBehavoirBlackboardType {
  BEHAVIOR_BLACKBOARD_INVALID = 0,
  BEHAVIOR_BLACKBOARD_INTERACTIVE = 1
};
bool EBehavoirBlackboardType_IsValid(int value);
const EBehavoirBlackboardType EBehavoirBlackboardType_MIN = BEHAVIOR_BLACKBOARD_INVALID;
const EBehavoirBlackboardType EBehavoirBlackboardType_MAX = BEHAVIOR_BLACKBOARD_INTERACTIVE;
const int EBehavoirBlackboardType_ARRAYSIZE = EBehavoirBlackboardType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBehavoirBlackboardType_descriptor();
inline const ::std::string& EBehavoirBlackboardType_Name(EBehavoirBlackboardType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBehavoirBlackboardType_descriptor(), value);
}
inline bool EBehavoirBlackboardType_Parse(
    const ::std::string& name, EBehavoirBlackboardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBehavoirBlackboardType>(
    EBehavoirBlackboardType_descriptor(), name, value);
}
enum ETaskAcceptType {
  NULL_ACCEPT = 0,
  ENTER_TRIGGER_COPY = 1,
  ENTER_TRIGGER_DUNGEON = 2,
  ENTER_TRIGGER_AREA = 3,
  USER_TRIGGER_LEVEL = 4,
  BUILDING_TRIGGER_LEVEL = 5,
  USE_TRIGGER_ITEM = 6,
  SLG_MAP_OPEN_DAY = 7,
  COMPLETE_TASK = 8,
  TOUCH_TRIGGER_AREA = 9,
  TIME_LIMIT_RANGE = 10,
  FEMALEMASTER_FEELING = 11,
  ENTER_SPECIFIC_SECNE = 12,
  CONTINUED_CLICK = 13,
  FEMALEMASTER_GIFTS = 14,
  STRONGHOLD_PASS = 15,
  CHAPTER_PASS = 16,
  MULTI_TIME_LIMIT_RANGE = 17,
  ENTER_NPC_AREA = 18,
  USE_HERO_FAVOR_ITEM = 19,
  SERVICE_OPEN_TIME = 20
};
bool ETaskAcceptType_IsValid(int value);
const ETaskAcceptType ETaskAcceptType_MIN = NULL_ACCEPT;
const ETaskAcceptType ETaskAcceptType_MAX = SERVICE_OPEN_TIME;
const int ETaskAcceptType_ARRAYSIZE = ETaskAcceptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskAcceptType_descriptor();
inline const ::std::string& ETaskAcceptType_Name(ETaskAcceptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskAcceptType_descriptor(), value);
}
inline bool ETaskAcceptType_Parse(
    const ::std::string& name, ETaskAcceptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskAcceptType>(
    ETaskAcceptType_descriptor(), name, value);
}
enum ETaskTriggerType {
  NULL_TRIGGER = 0,
  TRIGGER_BEHAVIOR = 1,
  OBTAIN_ITEM = 2,
  OBTAIN_MONEY = 3,
  DESTORY_ITEM = 5,
  TRIGGER_DIALOG = 6,
  TRIGGER_NORMAL_DIALOG = 7
};
bool ETaskTriggerType_IsValid(int value);
const ETaskTriggerType ETaskTriggerType_MIN = NULL_TRIGGER;
const ETaskTriggerType ETaskTriggerType_MAX = TRIGGER_NORMAL_DIALOG;
const int ETaskTriggerType_ARRAYSIZE = ETaskTriggerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskTriggerType_descriptor();
inline const ::std::string& ETaskTriggerType_Name(ETaskTriggerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskTriggerType_descriptor(), value);
}
inline bool ETaskTriggerType_Parse(
    const ::std::string& name, ETaskTriggerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskTriggerType>(
    ETaskTriggerType_descriptor(), name, value);
}
enum ETaskTargetType {
  NULL_TARGET = 0,
  ENTER_DUNGEON = 1,
  JOIN_BATTLE = 2,
  BATTLE_VIVCTORY = 3,
  UPGRADE_BUILDING = 4,
  RECRUIT_HERO = 5,
  TOWER_CHALLENGE = 7,
  JOIN_ARENA = 8,
  USE_ITEM = 9,
  BUY_STAMINA = 10,
  LEVEL_UPGRADE = 11,
  USER_LEVEL = 12,
  ADD_FRIEND = 13,
  JOIN_UNION = 14,
  VIP_LEVEL = 15,
  COMBAT_VALUE = 16,
  EQUIP_LEVEL = 18,
  EQUIP_REFINE_LEVEL = 67,
  ACCESSORY_ENHANCE_LEVEL = 68,
  ACCESSORY_REFINE_LEVEL = 69,
  HERO_EQUIP_ARM = 74,
  HERO_EQUIP_ACCESSORY = 75,
  BUILDING_LEVEL = 19,
  TOWER_LEVEL = 20,
  ARENA_RANK = 21,
  OBTAIN_ITEM_TOTAL = 22,
  OBTAIN_MONEY_TOTAL = 23,
  ATTACK_ENEMY = 24,
  ATTACK_CITY = 25,
  ATTACK_ENEMY_TOTAL = 26,
  COMPLETE_ALL_SUB_TASK = 27,
  TARGET_ENTER_TRIGGER_AREA = 28,
  TARGET_HERO_LEVEL_UP = 29,
  TARGET_HERO_STAR_UP = 30,
  TARGET_HERO_ADVANCE_UP = 31,
  TARGET_EQUIP_ENHANCE_COUNT = 32,
  TARGET_HERO_LEVEL_REACH = 33,
  TARGET_HERO_START_REACH = 34,
  TARGET_HERO_ADVANCE_REACH = 35,
  TARGET_INTERACTIVE_SCENE_UI = 36,
  TARGET_TOUCH_TRIGGER_AREA = 37,
  TARGET_FINISH_FEMALEMASTER_DIALOG = 38,
  TARGET_ENTER_SPECIFIC_SECNE = 39,
  TARGET_GUILD_DONATE = 40,
  TARGET_BUILD_CITY = 41,
  TARGET_EXPEDITION = 42,
  TARGET_EXPEDITION_LEVEL_PASS = 70,
  TARGET_TASK_MAINLINE = 43,
  TARGET_HERO_RELATION = 44,
  TARGET_SKILL_LEVELUP = 45,
  TARGET_ADVENTURE = 46,
  TARGET_ARM_REFINE = 47,
  TARGET_ACCESSORY_REFINE = 48,
  TARGET_RECYCLE_EQUIP = 49,
  TARGET_EQUIP_ACCESSORY = 50,
  TARGET_BUY_ITEM_IN_SHOP = 51,
  TARGET_ENTER_NATIONALWAR = 52,
  TARGET_START_FEMALEMASTER_DIALOG = 53,
  TARGET_START_STORY_DIALOG = 54,
  TARGET_FINISH_STORY_DIALOG = 55,
  TARGET_ELITE_BATTLE_VICTORY = 56,
  TARGET_GUILD_DONATE_TOTAL = 57,
  TARGET_ARENA_BATTLE_VICTORY = 58,
  TARGET_INSTANCE_STAR_COUNT = 59,
  TARGET_HERO_COUNT = 60,
  TARGET_GET_EQUIP = 61,
  TARGET_GET_SUIT = 62,
  TARGET_PASS_ADVENTURE = 63,
  TARGET_RECEIVE_MONTHCARD = 64,
  TARGET_INSTANCE_INTERACTIVE = 65,
  TARGET_FINISH_MINIGAME = 66,
  TARGET_GUILD_BOSS_ATTACK = 71,
  TARGET_ILLUSTRATION_UNLOCK = 72,
  TARGET_INSTANCE_PASS = 76,
  TARGET_ELITEINSTANCE_PASS = 77,
  JOIN_BATTLE_WIN = 78,
  DAILY_LOGIN = 79,
  PRESENT_STRENGTH_TO_FRIEND = 80,
  BUY_SILVER = 81,
  PRESENT_GUILD_CHIPS = 82,
  PRESENT_SOUVENIR_TO_FEMALEMASTER = 83,
  TOWER_BATTLE_WIN = 84,
  HERO_UPGRADE_COUNT = 86,
  SKILL_UPGRADE_COUNT = 87,
  TARGET_HERO_IN_SQUAD = 88,
  TARGET_INSTANCE_ITEM_EXCHANGE = 89,
  GAINED_TOTAL_HANDBOOK_NUM = 90,
  SEND_GUILD_RED_ENVELOPE = 91,
  MESSAGE_WAS_THUMB_UP_COUNT = 92,
  HERO_HAS_EXCLEQUIP = 93,
  HERO_FAVORITE_LEVEL = 94,
  SEND_HERO_FAVORITEGIFT_COUNT = 95,
  EXCLEQUIP_ADVANCE_ARRIVE_LEVEL = 96,
  ENTER_ADVATURE_TYPE_AND_NUM = 97,
  ADVATURE_PASS_NUM = 98,
  MULTITIMES_PUBS_ONCE_RED_HERO_NUM = 99,
  MULTITIMES_PUBS_TEN_TIMES_ALL_WORST_HERO = 100,
  PASS_LATENT_INSTANCE_NUM = 101,
  GET_ALL_OBJECTIVE_IN_CHAPTER_NUM = 102,
  WORLDBOSS_ATTACK_TIMES = 103,
  EXCAVATE_TREASURE_TIMES = 104,
  LEVY_DEFEAT_PLAYER_TIMES = 105,
  LEVY_GET_BENEFITS_TIMES = 106,
  WORLDBOSS_ARRIVE_RANKING = 107,
  LEVY_GET_GAME_CURRENCY_TOTAL = 108,
  TARGET_EXPEDITION_CHALLENGE_WIN_TIMES = 109,
  ADVANCED_ARENA_CHANLLENGE_TIMES = 110,
  ADVANCED_ARENA_CHANLLENGE_WIN_TIMES = 111,
  TRIAL_LAND_CHANLLENGE_TIMES = 112,
  TRIAL_LAND_CHANLLENGE_WIN_TIMES = 113,
  TRIAL_LAND_ACHIEVE_HIERARCHY = 114,
  BEAST_INSTANCE_CHANLLENGE_TIMES = 115,
  BEAST_INSTANCE_CHANLLENGE_WIN_TIMES = 116,
  BEAST_INSTANCE_ACHIEVE_LEVEL = 117,
  HALL_FAME_THUMBS_UP_TIMES = 118,
  GUILD_WISH_TIMES = 119,
  HERO_STAR_LEVEL_TOTAL = 120,
  DEFEAT_REBELS_TIMES = 121,
  TRIAL_LAND_PASS_PILES = 122,
  LOGIN_TIMES_TOTAL = 123
};
bool ETaskTargetType_IsValid(int value);
const ETaskTargetType ETaskTargetType_MIN = NULL_TARGET;
const ETaskTargetType ETaskTargetType_MAX = LOGIN_TIMES_TOTAL;
const int ETaskTargetType_ARRAYSIZE = ETaskTargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskTargetType_descriptor();
inline const ::std::string& ETaskTargetType_Name(ETaskTargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskTargetType_descriptor(), value);
}
inline bool ETaskTargetType_Parse(
    const ::std::string& name, ETaskTargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskTargetType>(
    ETaskTargetType_descriptor(), name, value);
}
// ===================================================================

/*FOR2LUA
<Record>
	<name>TaskAccept</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/TaskData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TaskAccept : public ::google::protobuf::Message {
 public:
  TaskAccept();
  virtual ~TaskAccept();

  TaskAccept(const TaskAccept& from);

  inline TaskAccept& operator=(const TaskAccept& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskAccept& default_instance();

  void Swap(TaskAccept* other);

  // implements Message ----------------------------------------------

  TaskAccept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskAccept& from);
  void MergeFrom(const TaskAccept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ETaskAcceptType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TaskAccept</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ETaskAcceptType type() const;
  inline void set_type(::pb::ETaskAcceptType value);

  // repeated string Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TaskAccept</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const char* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:pb.TaskAccept)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  int type_;
  friend void  protobuf_AddDesc_module_2fTaskData_2eproto();
  friend void protobuf_AssignDesc_module_2fTaskData_2eproto();
  friend void protobuf_ShutdownFile_module_2fTaskData_2eproto();

  void InitAsDefaultInstance();
  static TaskAccept* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TaskTrigger</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/TaskData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TaskTrigger : public ::google::protobuf::Message {
 public:
  TaskTrigger();
  virtual ~TaskTrigger();

  TaskTrigger(const TaskTrigger& from);

  inline TaskTrigger& operator=(const TaskTrigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskTrigger& default_instance();

  void Swap(TaskTrigger* other);

  // implements Message ----------------------------------------------

  TaskTrigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskTrigger& from);
  void MergeFrom(const TaskTrigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ETaskTriggerType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TaskTrigger</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ETaskTriggerType type() const;
  inline void set_type(::pb::ETaskTriggerType value);

  // repeated string Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TaskTrigger</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const char* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:pb.TaskTrigger)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  int type_;
  friend void  protobuf_AddDesc_module_2fTaskData_2eproto();
  friend void protobuf_AssignDesc_module_2fTaskData_2eproto();
  friend void protobuf_ShutdownFile_module_2fTaskData_2eproto();

  void InitAsDefaultInstance();
  static TaskTrigger* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TaskTarget</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/TaskData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TaskTarget : public ::google::protobuf::Message {
 public:
  TaskTarget();
  virtual ~TaskTarget();

  TaskTarget(const TaskTarget& from);

  inline TaskTarget& operator=(const TaskTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskTarget& default_instance();

  void Swap(TaskTarget* other);

  // implements Message ----------------------------------------------

  TaskTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskTarget& from);
  void MergeFrom(const TaskTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ETaskTargetType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TaskTarget</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ETaskTargetType type() const;
  inline void set_type(::pb::ETaskTargetType value);

  // repeated string Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TaskTarget</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const char* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // optional int32 Index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TaskTarget</name>
  	<Function>
  		<name>index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_index</name>
  		<replaceName>Index</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.TaskTarget)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  int type_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_module_2fTaskData_2eproto();
  friend void protobuf_AssignDesc_module_2fTaskData_2eproto();
  friend void protobuf_ShutdownFile_module_2fTaskData_2eproto();

  void InitAsDefaultInstance();
  static TaskTarget* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TaskExtraInfo</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/TaskData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TaskExtraInfo : public ::google::protobuf::Message {
 public:
  TaskExtraInfo();
  virtual ~TaskExtraInfo();

  TaskExtraInfo(const TaskExtraInfo& from);

  inline TaskExtraInfo& operator=(const TaskExtraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskExtraInfo& default_instance();

  void Swap(TaskExtraInfo* other);

  // implements Message ----------------------------------------------

  TaskExtraInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskExtraInfo& from);
  void MergeFrom(const TaskExtraInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TaskExtraInfo</name>
  	<Function>
  		<name>type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_type</name>
  		<replaceName>Type</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated .pb.BehaviorKeyValue Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TaskExtraInfo</name>
  	<Function>
  		<name>data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_data</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>data_size</name>
  		<replaceName>Data</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::BehaviorKeyValue& data(int index) const;
  inline ::pb::BehaviorKeyValue* mutable_data(int index);
  inline ::pb::BehaviorKeyValue* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:pb.TaskExtraInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue > data_;
  friend void  protobuf_AddDesc_module_2fTaskData_2eproto();
  friend void protobuf_AssignDesc_module_2fTaskData_2eproto();
  friend void protobuf_ShutdownFile_module_2fTaskData_2eproto();

  void InitAsDefaultInstance();
  static TaskExtraInfo* default_instance_;
};
// -------------------------------------------------------------------

/*FOR2LUA
<Record>
	<name>TaskData</name>
	<Function>
		<name>CopyFrom</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_copyfrom_cpp()</handler>
	</Function>
	<Function>
		<name>operator_equal</name>
		<replaceName>MergeFrom</replaceName>
		<handler>descripter = pb_operator_equal_cpp()</handler>
	</Function>
	<Function>
		<name>new</name>
		<replaceName>module/TaskData.proto</replaceName>
		<handler>descripter = pb_new_cpp()</handler>
	</Function>
	<Function>
		<name>ParsePartialFromArray</name>
		<replaceName>ParseFromString</replaceName>
		<handler>descripter = pb_decode_cpp()</handler>
	</Function>
	<Function>
		<name>SerializePartialToArray</name>
		<replaceName>SerializeToString</replaceName>
		<handler>descripter = pb_encode_cpp()</handler>
	</Function>
</Record>
FOR2LUA*/
class TaskData : public ::google::protobuf::Message {
 public:
  TaskData();
  virtual ~TaskData();

  TaskData(const TaskData& from);

  inline TaskData& operator=(const TaskData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskData& default_instance();

  void Swap(TaskData* other);

  // implements Message ----------------------------------------------

  TaskData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskData& from);
  void MergeFrom(const TaskData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_id</name>
  		<replaceName>ID</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .pb.ETaskMainType MainType = 2;
  inline bool has_maintype() const;
  inline void clear_maintype();
  static const int kMainTypeFieldNumber = 2;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>maintype</name>
  		<replaceName>MainType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_maintype</name>
  		<replaceName>MainType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_maintype</name>
  		<replaceName>MainType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ETaskMainType maintype() const;
  inline void set_maintype(::pb::ETaskMainType value);

  // optional .pb.ETaskSubType SubType = 3;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 3;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>subtype</name>
  		<replaceName>SubType</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_subtype</name>
  		<replaceName>SubType</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_subtype</name>
  		<replaceName>SubType</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::pb::ETaskSubType subtype() const;
  inline void set_subtype(::pb::ETaskSubType value);

  // optional string Name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_name</name>
  		<replaceName>Name</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_desc</name>
  		<replaceName>Desc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string Icon = 6;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 6;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>icon</name>
  		<replaceName>Icon</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_icon</name>
  		<replaceName>Icon</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_icon</name>
  		<replaceName>Icon</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional int32 LocalName = 11;
  inline bool has_localname() const;
  inline void clear_localname();
  static const int kLocalNameFieldNumber = 11;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>localname</name>
  		<replaceName>LocalName</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_localname</name>
  		<replaceName>LocalName</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_localname</name>
  		<replaceName>LocalName</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 localname() const;
  inline void set_localname(::google::protobuf::int32 value);

  // optional int32 LocalDesc = 12;
  inline bool has_localdesc() const;
  inline void clear_localdesc();
  static const int kLocalDescFieldNumber = 12;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>localdesc</name>
  		<replaceName>LocalDesc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_localdesc</name>
  		<replaceName>LocalDesc</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_localdesc</name>
  		<replaceName>LocalDesc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 localdesc() const;
  inline void set_localdesc(::google::protobuf::int32 value);

  // repeated .pb.TaskAccept AcceptArr = 7;
  inline int acceptarr_size() const;
  inline void clear_acceptarr();
  static const int kAcceptArrFieldNumber = 7;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>acceptarr</name>
  		<replaceName>AcceptArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_acceptarr</name>
  		<replaceName>AcceptArr</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_acceptarr</name>
  		<replaceName>AcceptArr</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_acceptarr</name>
  		<replaceName>AcceptArr</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>acceptarr_size</name>
  		<replaceName>AcceptArr</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TaskAccept& acceptarr(int index) const;
  inline ::pb::TaskAccept* mutable_acceptarr(int index);
  inline ::pb::TaskAccept* add_acceptarr();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskAccept >&
      acceptarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TaskAccept >*
      mutable_acceptarr();

  // repeated .pb.TaskTrigger TriggerOnAccept = 8;
  inline int triggeronaccept_size() const;
  inline void clear_triggeronaccept();
  static const int kTriggerOnAcceptFieldNumber = 8;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>triggeronaccept</name>
  		<replaceName>TriggerOnAccept</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_triggeronaccept</name>
  		<replaceName>TriggerOnAccept</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_triggeronaccept</name>
  		<replaceName>TriggerOnAccept</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggeronaccept</name>
  		<replaceName>TriggerOnAccept</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>triggeronaccept_size</name>
  		<replaceName>TriggerOnAccept</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TaskTrigger& triggeronaccept(int index) const;
  inline ::pb::TaskTrigger* mutable_triggeronaccept(int index);
  inline ::pb::TaskTrigger* add_triggeronaccept();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >&
      triggeronaccept() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >*
      mutable_triggeronaccept();

  // repeated .pb.TaskTrigger TriggerOnComplete = 9;
  inline int triggeroncomplete_size() const;
  inline void clear_triggeroncomplete();
  static const int kTriggerOnCompleteFieldNumber = 9;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>triggeroncomplete</name>
  		<replaceName>TriggerOnComplete</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_triggeroncomplete</name>
  		<replaceName>TriggerOnComplete</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_triggeroncomplete</name>
  		<replaceName>TriggerOnComplete</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_triggeroncomplete</name>
  		<replaceName>TriggerOnComplete</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>triggeroncomplete_size</name>
  		<replaceName>TriggerOnComplete</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TaskTrigger& triggeroncomplete(int index) const;
  inline ::pb::TaskTrigger* mutable_triggeroncomplete(int index);
  inline ::pb::TaskTrigger* add_triggeroncomplete();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >&
      triggeroncomplete() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >*
      mutable_triggeroncomplete();

  // optional .pb.TaskTarget CompleteTarget = 10;
  inline bool has_completetarget() const;
  inline void clear_completetarget();
  static const int kCompleteTargetFieldNumber = 10;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>completetarget</name>
  		<replaceName>CompleteTarget</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_completetarget</name>
  		<replaceName>CompleteTarget</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_allocated_completetarget</name>
  		<replaceName>CompleteTarget</replaceName>
  		<handler>descripter = pb_set_message_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_completetarget</name>
  		<replaceName>CompleteTarget</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TaskTarget& completetarget() const;
  inline ::pb::TaskTarget* mutable_completetarget();
  inline ::pb::TaskTarget* release_completetarget();
  inline void set_allocated_completetarget(::pb::TaskTarget* completetarget);

  // repeated .pb.TaskExtraInfo ExtraInfo = 13;
  inline int extrainfo_size() const;
  inline void clear_extrainfo();
  static const int kExtraInfoFieldNumber = 13;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>mutable_extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>add_extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_repeated_add_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_extrainfo</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  	<Function>
  		<name>extrainfo_size</name>
  		<replaceName>ExtraInfo</replaceName>
  		<handler>descripter = pb_repeated_size_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline const ::pb::TaskExtraInfo& extrainfo(int index) const;
  inline ::pb::TaskExtraInfo* mutable_extrainfo(int index);
  inline ::pb::TaskExtraInfo* add_extrainfo();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskExtraInfo >&
      extrainfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TaskExtraInfo >*
      mutable_extrainfo();

  // optional bool UseForTriggerBehavior = 14;
  inline bool has_usefortriggerbehavior() const;
  inline void clear_usefortriggerbehavior();
  static const int kUseForTriggerBehaviorFieldNumber = 14;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>usefortriggerbehavior</name>
  		<replaceName>UseForTriggerBehavior</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_usefortriggerbehavior</name>
  		<replaceName>UseForTriggerBehavior</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_usefortriggerbehavior</name>
  		<replaceName>UseForTriggerBehavior</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool usefortriggerbehavior() const;
  inline void set_usefortriggerbehavior(bool value);

  // optional int32 TargetDesc = 15;
  inline bool has_targetdesc() const;
  inline void clear_targetdesc();
  static const int kTargetDescFieldNumber = 15;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>targetdesc</name>
  		<replaceName>TargetDesc</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_targetdesc</name>
  		<replaceName>TargetDesc</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_targetdesc</name>
  		<replaceName>TargetDesc</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline ::google::protobuf::int32 targetdesc() const;
  inline void set_targetdesc(::google::protobuf::int32 value);

  // optional bool NeedSpecialDisplay = 16;
  inline bool has_needspecialdisplay() const;
  inline void clear_needspecialdisplay();
  static const int kNeedSpecialDisplayFieldNumber = 16;
  /*FOR2LUA
  <Record>
  	<name>TaskData</name>
  	<Function>
  		<name>needspecialdisplay</name>
  		<replaceName>NeedSpecialDisplay</replaceName>
  		<handler>descripter = pb_cpp()</handler>
  	</Function>
  	<Function>
  		<name>set_needspecialdisplay</name>
  		<replaceName>NeedSpecialDisplay</replaceName>
  		<handler>descripter = pb_set_cpp()</handler>
  	</Function>
  	<Function>
  		<name>has_needspecialdisplay</name>
  		<replaceName>NeedSpecialDisplay</replaceName>
  		<handler>descripter = pb_has_cpp()</handler>
  	</Function>
  </Record>
  FOR2LUA*/
  inline bool needspecialdisplay() const;
  inline void set_needspecialdisplay(bool value);

  // @@protoc_insertion_point(class_scope:pb.TaskData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_maintype();
  inline void clear_has_maintype();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_localname();
  inline void clear_has_localname();
  inline void set_has_localdesc();
  inline void clear_has_localdesc();
  inline void set_has_completetarget();
  inline void clear_has_completetarget();
  inline void set_has_usefortriggerbehavior();
  inline void clear_has_usefortriggerbehavior();
  inline void set_has_targetdesc();
  inline void clear_has_targetdesc();
  inline void set_has_needspecialdisplay();
  inline void clear_has_needspecialdisplay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int maintype_;
  ::std::string* name_;
  ::std::string* desc_;
  int subtype_;
  ::google::protobuf::int32 localname_;
  ::std::string* icon_;
  ::google::protobuf::RepeatedPtrField< ::pb::TaskAccept > acceptarr_;
  ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger > triggeronaccept_;
  ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger > triggeroncomplete_;
  ::google::protobuf::int32 localdesc_;
  ::google::protobuf::int32 targetdesc_;
  ::pb::TaskTarget* completetarget_;
  ::google::protobuf::RepeatedPtrField< ::pb::TaskExtraInfo > extrainfo_;
  bool usefortriggerbehavior_;
  bool needspecialdisplay_;
  friend void  protobuf_AddDesc_module_2fTaskData_2eproto();
  friend void protobuf_AssignDesc_module_2fTaskData_2eproto();
  friend void protobuf_ShutdownFile_module_2fTaskData_2eproto();

  void InitAsDefaultInstance();
  static TaskData* default_instance_;
};
// ===================================================================


// ===================================================================

// TaskAccept

// optional .pb.ETaskAcceptType Type = 1;
inline bool TaskAccept::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskAccept::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskAccept::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskAccept::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::ETaskAcceptType TaskAccept::type() const {
  // @@protoc_insertion_point(field_get:pb.TaskAccept.Type)
  return static_cast< ::pb::ETaskAcceptType >(type_);
}
inline void TaskAccept::set_type(::pb::ETaskAcceptType value) {
  assert(::pb::ETaskAcceptType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskAccept.Type)
}

// repeated string Data = 2;
inline int TaskAccept::data_size() const {
  return data_.size();
}
inline void TaskAccept::clear_data() {
  data_.Clear();
}
inline const ::std::string& TaskAccept::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskAccept.Data)
  return data_.Get(index);
}
inline ::std::string* TaskAccept::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskAccept.Data)
  return data_.Mutable(index);
}
inline void TaskAccept::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.TaskAccept.Data)
  data_.Mutable(index)->assign(value);
}
inline void TaskAccept::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskAccept.Data)
}
inline void TaskAccept::set_data(int index, const char* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskAccept.Data)
}
inline ::std::string* TaskAccept::add_data() {
  return data_.Add();
}
inline void TaskAccept::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.TaskAccept.Data)
}
inline void TaskAccept::add_data(const char* value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.TaskAccept.Data)
}
inline void TaskAccept::add_data(const char* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.TaskAccept.Data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskAccept::data() const {
  // @@protoc_insertion_point(field_list:pb.TaskAccept.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskAccept::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskAccept.Data)
  return &data_;
}

// -------------------------------------------------------------------

// TaskTrigger

// optional .pb.ETaskTriggerType Type = 1;
inline bool TaskTrigger::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskTrigger::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskTrigger::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskTrigger::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::ETaskTriggerType TaskTrigger::type() const {
  // @@protoc_insertion_point(field_get:pb.TaskTrigger.Type)
  return static_cast< ::pb::ETaskTriggerType >(type_);
}
inline void TaskTrigger::set_type(::pb::ETaskTriggerType value) {
  assert(::pb::ETaskTriggerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskTrigger.Type)
}

// repeated string Data = 2;
inline int TaskTrigger::data_size() const {
  return data_.size();
}
inline void TaskTrigger::clear_data() {
  data_.Clear();
}
inline const ::std::string& TaskTrigger::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskTrigger.Data)
  return data_.Get(index);
}
inline ::std::string* TaskTrigger::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskTrigger.Data)
  return data_.Mutable(index);
}
inline void TaskTrigger::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.TaskTrigger.Data)
  data_.Mutable(index)->assign(value);
}
inline void TaskTrigger::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskTrigger.Data)
}
inline void TaskTrigger::set_data(int index, const char* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskTrigger.Data)
}
inline ::std::string* TaskTrigger::add_data() {
  return data_.Add();
}
inline void TaskTrigger::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.TaskTrigger.Data)
}
inline void TaskTrigger::add_data(const char* value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.TaskTrigger.Data)
}
inline void TaskTrigger::add_data(const char* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.TaskTrigger.Data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskTrigger::data() const {
  // @@protoc_insertion_point(field_list:pb.TaskTrigger.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskTrigger::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskTrigger.Data)
  return &data_;
}

// -------------------------------------------------------------------

// TaskTarget

// optional .pb.ETaskTargetType Type = 1;
inline bool TaskTarget::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskTarget::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskTarget::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskTarget::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::ETaskTargetType TaskTarget::type() const {
  // @@protoc_insertion_point(field_get:pb.TaskTarget.Type)
  return static_cast< ::pb::ETaskTargetType >(type_);
}
inline void TaskTarget::set_type(::pb::ETaskTargetType value) {
  assert(::pb::ETaskTargetType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskTarget.Type)
}

// repeated string Data = 2;
inline int TaskTarget::data_size() const {
  return data_.size();
}
inline void TaskTarget::clear_data() {
  data_.Clear();
}
inline const ::std::string& TaskTarget::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskTarget.Data)
  return data_.Get(index);
}
inline ::std::string* TaskTarget::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskTarget.Data)
  return data_.Mutable(index);
}
inline void TaskTarget::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.TaskTarget.Data)
  data_.Mutable(index)->assign(value);
}
inline void TaskTarget::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskTarget.Data)
}
inline void TaskTarget::set_data(int index, const char* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskTarget.Data)
}
inline ::std::string* TaskTarget::add_data() {
  return data_.Add();
}
inline void TaskTarget::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.TaskTarget.Data)
}
inline void TaskTarget::add_data(const char* value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.TaskTarget.Data)
}
inline void TaskTarget::add_data(const char* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.TaskTarget.Data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskTarget::data() const {
  // @@protoc_insertion_point(field_list:pb.TaskTarget.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskTarget::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskTarget.Data)
  return &data_;
}

// optional int32 Index = 3;
inline bool TaskTarget::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskTarget::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskTarget::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskTarget::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 TaskTarget::index() const {
  // @@protoc_insertion_point(field_get:pb.TaskTarget.Index)
  return index_;
}
inline void TaskTarget::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskTarget.Index)
}

// -------------------------------------------------------------------

// TaskExtraInfo

// optional string Type = 1;
inline bool TaskExtraInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskExtraInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskExtraInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskExtraInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& TaskExtraInfo::type() const {
  // @@protoc_insertion_point(field_get:pb.TaskExtraInfo.Type)
  return *type_;
}
inline void TaskExtraInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TaskExtraInfo.Type)
}
inline void TaskExtraInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskExtraInfo.Type)
}
inline void TaskExtraInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskExtraInfo.Type)
}
inline ::std::string* TaskExtraInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TaskExtraInfo.Type)
  return type_;
}
inline ::std::string* TaskExtraInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskExtraInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskExtraInfo.Type)
}

// repeated .pb.BehaviorKeyValue Data = 2;
inline int TaskExtraInfo::data_size() const {
  return data_.size();
}
inline void TaskExtraInfo::clear_data() {
  data_.Clear();
}
inline const ::pb::BehaviorKeyValue& TaskExtraInfo::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskExtraInfo.Data)
  return data_.Get(index);
}
inline ::pb::BehaviorKeyValue* TaskExtraInfo::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskExtraInfo.Data)
  return data_.Mutable(index);
}
inline ::pb::BehaviorKeyValue* TaskExtraInfo::add_data() {
  // @@protoc_insertion_point(field_add:pb.TaskExtraInfo.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >&
TaskExtraInfo::data() const {
  // @@protoc_insertion_point(field_list:pb.TaskExtraInfo.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BehaviorKeyValue >*
TaskExtraInfo::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskExtraInfo.Data)
  return &data_;
}

// -------------------------------------------------------------------

// TaskData

// optional int32 ID = 1;
inline bool TaskData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TaskData::id() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.ID)
  return id_;
}
inline void TaskData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.ID)
}

// optional .pb.ETaskMainType MainType = 2;
inline bool TaskData::has_maintype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskData::set_has_maintype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskData::clear_has_maintype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskData::clear_maintype() {
  maintype_ = 0;
  clear_has_maintype();
}
inline ::pb::ETaskMainType TaskData::maintype() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.MainType)
  return static_cast< ::pb::ETaskMainType >(maintype_);
}
inline void TaskData::set_maintype(::pb::ETaskMainType value) {
  assert(::pb::ETaskMainType_IsValid(value));
  set_has_maintype();
  maintype_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.MainType)
}

// optional .pb.ETaskSubType SubType = 3;
inline bool TaskData::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskData::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskData::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskData::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::pb::ETaskSubType TaskData::subtype() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.SubType)
  return static_cast< ::pb::ETaskSubType >(subtype_);
}
inline void TaskData::set_subtype(::pb::ETaskSubType value) {
  assert(::pb::ETaskSubType_IsValid(value));
  set_has_subtype();
  subtype_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.SubType)
}

// optional string Name = 4;
inline bool TaskData::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskData::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskData::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskData::name() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.Name)
  return *name_;
}
inline void TaskData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TaskData.Name)
}
inline void TaskData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskData.Name)
}
inline void TaskData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskData.Name)
}
inline ::std::string* TaskData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TaskData.Name)
  return name_;
}
inline ::std::string* TaskData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskData.Name)
}

// optional string Desc = 5;
inline bool TaskData::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskData::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskData::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskData::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TaskData::desc() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.Desc)
  return *desc_;
}
inline void TaskData::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TaskData.Desc)
}
inline void TaskData::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskData.Desc)
}
inline void TaskData::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskData.Desc)
}
inline ::std::string* TaskData::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TaskData.Desc)
  return desc_;
}
inline ::std::string* TaskData::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskData::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskData.Desc)
}

// optional string Icon = 6;
inline bool TaskData::has_icon() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskData::set_has_icon() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskData::clear_has_icon() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskData::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& TaskData::icon() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.Icon)
  return *icon_;
}
inline void TaskData::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:pb.TaskData.Icon)
}
inline void TaskData::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.TaskData.Icon)
}
inline void TaskData::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.TaskData.Icon)
}
inline ::std::string* TaskData::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.TaskData.Icon)
  return icon_;
}
inline ::std::string* TaskData::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskData::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskData.Icon)
}

// optional int32 LocalName = 11;
inline bool TaskData::has_localname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskData::set_has_localname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskData::clear_has_localname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskData::clear_localname() {
  localname_ = 0;
  clear_has_localname();
}
inline ::google::protobuf::int32 TaskData::localname() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.LocalName)
  return localname_;
}
inline void TaskData::set_localname(::google::protobuf::int32 value) {
  set_has_localname();
  localname_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.LocalName)
}

// optional int32 LocalDesc = 12;
inline bool TaskData::has_localdesc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskData::set_has_localdesc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskData::clear_has_localdesc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskData::clear_localdesc() {
  localdesc_ = 0;
  clear_has_localdesc();
}
inline ::google::protobuf::int32 TaskData::localdesc() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.LocalDesc)
  return localdesc_;
}
inline void TaskData::set_localdesc(::google::protobuf::int32 value) {
  set_has_localdesc();
  localdesc_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.LocalDesc)
}

// repeated .pb.TaskAccept AcceptArr = 7;
inline int TaskData::acceptarr_size() const {
  return acceptarr_.size();
}
inline void TaskData::clear_acceptarr() {
  acceptarr_.Clear();
}
inline const ::pb::TaskAccept& TaskData::acceptarr(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskData.AcceptArr)
  return acceptarr_.Get(index);
}
inline ::pb::TaskAccept* TaskData::mutable_acceptarr(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskData.AcceptArr)
  return acceptarr_.Mutable(index);
}
inline ::pb::TaskAccept* TaskData::add_acceptarr() {
  // @@protoc_insertion_point(field_add:pb.TaskData.AcceptArr)
  return acceptarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskAccept >&
TaskData::acceptarr() const {
  // @@protoc_insertion_point(field_list:pb.TaskData.AcceptArr)
  return acceptarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TaskAccept >*
TaskData::mutable_acceptarr() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskData.AcceptArr)
  return &acceptarr_;
}

// repeated .pb.TaskTrigger TriggerOnAccept = 8;
inline int TaskData::triggeronaccept_size() const {
  return triggeronaccept_.size();
}
inline void TaskData::clear_triggeronaccept() {
  triggeronaccept_.Clear();
}
inline const ::pb::TaskTrigger& TaskData::triggeronaccept(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskData.TriggerOnAccept)
  return triggeronaccept_.Get(index);
}
inline ::pb::TaskTrigger* TaskData::mutable_triggeronaccept(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskData.TriggerOnAccept)
  return triggeronaccept_.Mutable(index);
}
inline ::pb::TaskTrigger* TaskData::add_triggeronaccept() {
  // @@protoc_insertion_point(field_add:pb.TaskData.TriggerOnAccept)
  return triggeronaccept_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >&
TaskData::triggeronaccept() const {
  // @@protoc_insertion_point(field_list:pb.TaskData.TriggerOnAccept)
  return triggeronaccept_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >*
TaskData::mutable_triggeronaccept() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskData.TriggerOnAccept)
  return &triggeronaccept_;
}

// repeated .pb.TaskTrigger TriggerOnComplete = 9;
inline int TaskData::triggeroncomplete_size() const {
  return triggeroncomplete_.size();
}
inline void TaskData::clear_triggeroncomplete() {
  triggeroncomplete_.Clear();
}
inline const ::pb::TaskTrigger& TaskData::triggeroncomplete(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskData.TriggerOnComplete)
  return triggeroncomplete_.Get(index);
}
inline ::pb::TaskTrigger* TaskData::mutable_triggeroncomplete(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskData.TriggerOnComplete)
  return triggeroncomplete_.Mutable(index);
}
inline ::pb::TaskTrigger* TaskData::add_triggeroncomplete() {
  // @@protoc_insertion_point(field_add:pb.TaskData.TriggerOnComplete)
  return triggeroncomplete_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >&
TaskData::triggeroncomplete() const {
  // @@protoc_insertion_point(field_list:pb.TaskData.TriggerOnComplete)
  return triggeroncomplete_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TaskTrigger >*
TaskData::mutable_triggeroncomplete() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskData.TriggerOnComplete)
  return &triggeroncomplete_;
}

// optional .pb.TaskTarget CompleteTarget = 10;
inline bool TaskData::has_completetarget() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskData::set_has_completetarget() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskData::clear_has_completetarget() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskData::clear_completetarget() {
  if (completetarget_ != NULL) completetarget_->::pb::TaskTarget::Clear();
  clear_has_completetarget();
}
inline const ::pb::TaskTarget& TaskData::completetarget() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.CompleteTarget)
  return completetarget_ != NULL ? *completetarget_ : *default_instance_->completetarget_;
}
inline ::pb::TaskTarget* TaskData::mutable_completetarget() {
  set_has_completetarget();
  if (completetarget_ == NULL) completetarget_ = new ::pb::TaskTarget;
  // @@protoc_insertion_point(field_mutable:pb.TaskData.CompleteTarget)
  return completetarget_;
}
inline ::pb::TaskTarget* TaskData::release_completetarget() {
  clear_has_completetarget();
  ::pb::TaskTarget* temp = completetarget_;
  completetarget_ = NULL;
  return temp;
}
inline void TaskData::set_allocated_completetarget(::pb::TaskTarget* completetarget) {
  delete completetarget_;
  completetarget_ = completetarget;
  if (completetarget) {
    set_has_completetarget();
  } else {
    clear_has_completetarget();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TaskData.CompleteTarget)
}

// repeated .pb.TaskExtraInfo ExtraInfo = 13;
inline int TaskData::extrainfo_size() const {
  return extrainfo_.size();
}
inline void TaskData::clear_extrainfo() {
  extrainfo_.Clear();
}
inline const ::pb::TaskExtraInfo& TaskData::extrainfo(int index) const {
  // @@protoc_insertion_point(field_get:pb.TaskData.ExtraInfo)
  return extrainfo_.Get(index);
}
inline ::pb::TaskExtraInfo* TaskData::mutable_extrainfo(int index) {
  // @@protoc_insertion_point(field_mutable:pb.TaskData.ExtraInfo)
  return extrainfo_.Mutable(index);
}
inline ::pb::TaskExtraInfo* TaskData::add_extrainfo() {
  // @@protoc_insertion_point(field_add:pb.TaskData.ExtraInfo)
  return extrainfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TaskExtraInfo >&
TaskData::extrainfo() const {
  // @@protoc_insertion_point(field_list:pb.TaskData.ExtraInfo)
  return extrainfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TaskExtraInfo >*
TaskData::mutable_extrainfo() {
  // @@protoc_insertion_point(field_mutable_list:pb.TaskData.ExtraInfo)
  return &extrainfo_;
}

// optional bool UseForTriggerBehavior = 14;
inline bool TaskData::has_usefortriggerbehavior() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TaskData::set_has_usefortriggerbehavior() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TaskData::clear_has_usefortriggerbehavior() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TaskData::clear_usefortriggerbehavior() {
  usefortriggerbehavior_ = false;
  clear_has_usefortriggerbehavior();
}
inline bool TaskData::usefortriggerbehavior() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.UseForTriggerBehavior)
  return usefortriggerbehavior_;
}
inline void TaskData::set_usefortriggerbehavior(bool value) {
  set_has_usefortriggerbehavior();
  usefortriggerbehavior_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.UseForTriggerBehavior)
}

// optional int32 TargetDesc = 15;
inline bool TaskData::has_targetdesc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TaskData::set_has_targetdesc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TaskData::clear_has_targetdesc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TaskData::clear_targetdesc() {
  targetdesc_ = 0;
  clear_has_targetdesc();
}
inline ::google::protobuf::int32 TaskData::targetdesc() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.TargetDesc)
  return targetdesc_;
}
inline void TaskData::set_targetdesc(::google::protobuf::int32 value) {
  set_has_targetdesc();
  targetdesc_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.TargetDesc)
}

// optional bool NeedSpecialDisplay = 16;
inline bool TaskData::has_needspecialdisplay() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TaskData::set_has_needspecialdisplay() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TaskData::clear_has_needspecialdisplay() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TaskData::clear_needspecialdisplay() {
  needspecialdisplay_ = false;
  clear_has_needspecialdisplay();
}
inline bool TaskData::needspecialdisplay() const {
  // @@protoc_insertion_point(field_get:pb.TaskData.NeedSpecialDisplay)
  return needspecialdisplay_;
}
inline void TaskData::set_needspecialdisplay(bool value) {
  set_has_needspecialdisplay();
  needspecialdisplay_ = value;
  // @@protoc_insertion_point(field_set:pb.TaskData.NeedSpecialDisplay)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::ETaskMainType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ETaskMainType>() {
  return ::pb::ETaskMainType_descriptor();
}
template <> struct is_proto_enum< ::pb::ETaskSubType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ETaskSubType>() {
  return ::pb::ETaskSubType_descriptor();
}
template <> struct is_proto_enum< ::pb::EBehavoirBlackboardType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EBehavoirBlackboardType>() {
  return ::pb::EBehavoirBlackboardType_descriptor();
}
template <> struct is_proto_enum< ::pb::ETaskAcceptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ETaskAcceptType>() {
  return ::pb::ETaskAcceptType_descriptor();
}
template <> struct is_proto_enum< ::pb::ETaskTriggerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ETaskTriggerType>() {
  return ::pb::ETaskTriggerType_descriptor();
}
template <> struct is_proto_enum< ::pb::ETaskTargetType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ETaskTargetType>() {
  return ::pb::ETaskTargetType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_module_2fTaskData_2eproto__INCLUDED
